{
 "questions": [
  {
   "qid": 1, 
   "question": "Give a definition for the term \"artificial neural network\" and mention, how it resembles the human brain!", 
   "answers": [
    {
     "answer": [
      "YOUR ANSWER HERE: Artificial neural network is a massively distributed parallel processor which is composed of simple processing units called neurons, which have the natural propensity for storing experiential information and making it available for use. It resembles the human brain in the following aspects.\n", 
      "- Knowledge is acquired by the network from its environment through a learning process.\n", 
      "- Synaptic links are used to store the acquired knowledge."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "ANN is huge parallel distributed processor ,\n", 
      "\n", 
      "consist of simple processing units and \n", 
      "\n", 
      "which has propensity of storing experintial knowlegde \n", 
      "\n", 
      "and making it available for use."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Artificial neural network is a massively parrallal distributed processor made up of simple processing units which has a natural propensity to acquire knowledge from the environment and make it available for future use.\n", 
      "\n", 
      "It resembels the human brain in following ways.\n", 
      "\n", 
      "1. Both of them acquire knowledge from the environment.\n", 
      "2. The neurons are connected by synapses cahrecterized by their weights which can be adjusted."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE\n", 
      "\n", 
      "An artificial neural network is a massively distributed parallel processor made of simple processing units. It has natural propensity to store experential knowledge and it makes the knowledge available for further use.\n", 
      "\n", 
      "An artificial neural network uses inter neuron connections called synaptic weights to store the knowledge acquired knowledge which is very similar to how human brain works."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "ANN is a massively distributed processor, consisting of simple processing units called neurons. These neurons in terms of ANN are similar to neurons in human brain. Both neurons are characterized by synapses(connection links). They represent connections used for data flow between neurons. In both ANN and Human brain, the knowledge is represented by its very structure and activation state of neurons.  "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Artificial neural network is massive parallel processor made up of simple processing units called neurons. \n", 
      "\n", 
      "They are capable of storing experential knowledge and make it available for later use. \n", 
      "\n", 
      "Similarity to human brain: \n", 
      "1. they learn from the envirnoment \n", 
      "2. they store knowledge as synaptic weight in the interneuron connection "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "An artificial neural network is a highly distributed processor which consists of several simple processing units. It resembles the human brain, because the processing units are neurons, which are connected with weights. The human brain also consists of neurons."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Artificial neural network is a **massively parallel distributed processor** with synaptic links that can able to **store experimental knowledge** and make it available for use.\n", 
      "\n", 
      "It resembles human brain in two ways,\n", 
      "\n", 
      "* Knowledge is acquired by the neural network from its environment through learning process.\n", 
      "* Interneuron connection called synaptic links stores the acquired knowledge."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Artificial neural network are the network of the units that learn data from the environment and store them using synaptic weights.\n", 
      "\n", 
      "The structure of the artificial neural network is similar to human brain. It has neurons, ie., the store units and the axoms called synapses which link the stored data."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Definition:\n", 
      "1. Artificial neural networks are massively distributed parallel processor.\n", 
      "2. It is made up of small units, \n", 
      "3. Which has the propensity for storing the experential knowledge.\n", 
      "4. And making it available for use. \n", 
      "\n", 
      "It resembles the brain in 2 aspects. \n", 
      "1. Similar to the brain, artificial neural network does the process of learning from the environment. \n", 
      "2. It as a pair of inter neuron links known as the synaptic weights, which is used for storing the information. "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Artificial neural network is massive parallely distributed processor. It comprises of small processing units called neurons. It learns from experiencial knowledge which is then stored and can be used for making predictions. It resembles human brain in 2 ways:\n", 
      "* It learns from experiencial knowledge\n", 
      "* Knowledge is stored in synaptic interneuron connections."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "It is a massively parallel distributed processor consisting of simple processing units, which can store experiential knowledge and make it available for use. it resembles the human brain in 2 ways: 1. knowledge is acquired from environment through a learning process; 2. interneuron connections are used to store the experiential knowledge."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "It is a massive parallel distributed processor made up of smaller processing units, that aquire knowledge through the environmnet through a learning process and makes it available for use. It resembles the brain in two ways:\n", 
      "\n", 
      "- Knowledge is aquired through a stimulating process in the environment\n", 
      "- The knowledge is embedded in the synaptic links (weights) of the neurons. "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "ANN is a learning machine which is composed of neurons as units of computation. The ANN learns via interacting with its environment. The ANN has built-in capacity to dynamically adapt upon input stimulus.\n", 
      "\n", 
      "The ANN is motivated from biological brain and resembles human brain in terms of its localized representation for the inputs. In terms of motor cortex, the sensory stimulus to diffrent body-parts activates local part of the brain, similar to ANN local representation of similar type of input."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "A neural network is a massively parallel distributed prcoessor made up for simple processing units that has a natural propensity for storing experiential knowledge and making it available for use. It resembles the brain in two respects\n", 
      "* Knowledge is acquired by the network from its environment through the learning process\n", 
      "* Interneuron connection strengths known as synaptic weights, are used to stor the acquired knowledge."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Artificial neural network is a massively parallel distributed processor which consists of one or more processing unit called neuron. It resembles the human brain for that it acquires knowledge from the environment through learning process, and that the acquired knowledge is stored in the synapses."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "A ANN is a massively distributed processor. It has the propensity to store experiental knowledge and make it available for use. The knowledge is gained throug a process of learning. The knowledge is stored in the weights between the neurons. This structure resembles the structure of the brain. Neurons are a the basic information unit in the ANN and act similiar to real neurons."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "An artificial neural network is defined as a learning machine which is divided by layers and each layer is composed by neurons. The neurons from different layers can be connected between each other, and give an output or multiple outputs by a given input. This structure is very similar with the neurological structure of our brain, where neurons are interconnected by synapses. Also important to mention, if a feature is really important for a given task, this wil have more connections and neurons participating (like in the human brain, the important humasn functions have more synapses)."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "A massively distributed processor, consisting of single processing units that have a natural prospensity of storing experimental knowledge and making it available for use."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Artificial neural network is highly parralel processing. It has a mathematical model similar to human brain, which it was inspired from, as human brain does computation in an extremely parallel manner. Similarities also lay in terminology, ANN is using neurons that are smallest computing unit of a network, similarly to human brain."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "An ANN is a layered graphical model containing neurons and weighted connections, resembling the excitatory properties of the human brain. Weights of the ANN are changed after presenting it training examples from an environment, where weights are changed based on the training procedure used. Artificial neurons also are biased, just like real ones, adding a constant level of activation before being activated by a (nonlinear) activation function. Depending on the training procedure, both weights, topology or even activation functions may be learned."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Artificial Neural Networks are large parallel processing units that have the natural ability to learn experiential knowledge. They are composed of interconnected neurons as basic units; which in turn cosists of weights, squashing functions and adder functions.\n", 
      "\n", 
      "ANN resembles brain in the manner that like in human brain, it is composed of a network of neurons which help in learning by adjusting the synaptic weights of the connections between neurons. This enables it to learn experiential knowledge."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Artificial neural network consists of:\n", 
      "\n", 
      "    . Largely parallel distributed processor\n", 
      "    \n", 
      "    . simple processing units\n", 
      "    \n", 
      "    . that has ability to store the experential knowledge and making it available to use\n", 
      "    \n", 
      "It resembles to human brain in two ways:\n", 
      "\n", 
      "    . Knowledge is acquired from the environment by the network as learning process\n", 
      "    . Synaptic strengths called weights are used to store the knowledge"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "An artificial neural network is a massive distributed processor. It consists of several information processing units which are able to acquire and store knowledge."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "An artificial neural network is a massively parallel distributed processor with simple processing units that has the natural propensity to store experiential knowledge and make use of them.\n", 
      "\n", 
      "An artificial neural network is similar to the human brain in two ways:\n", 
      "\n", 
      "1. The ANN works by the process of learning from its environment.\n", 
      "2. Interneuron connections called synaptic weights are used to store the knowledge gained.\n"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "An articial neural network consists of neurons. Each neuron can have several weighted inputs, an activation function and output. Usually several neurons are connected together. Often in layers. The network then calculates the output given an input to the network. The human brain works in a similar way. It also consits of neurons that are connected in several ways."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "An ANN is a\n", 
      "- massivly parallel distibuted Processor\n", 
      "- made up of simple processing units\n", 
      "- which have the capability of storing experiantal knowlenge\n", 
      "- and is made up for use.\n", 
      "\n", 
      "An ANN resembles the brain because:\n", 
      "\n", 
      "1) it gets its knowlenge through a learning process from its environment.\n", 
      "\n", 
      "2) it stores its knowlenge in its interneuron connections (synaptic weights)"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "An ANN is a massivly parrallel distributed learing machine made up of small computational units. Computational units are connected via synapses defined by a weight. It resembles the human brain in two aspectes:  \n"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "An artificial neural network is a highly parallel working machine which consists of simple processing units (neurons) wich are connected to each other in layers. they are function approximators \n", 
      "the brain is resembled in the architecure, the processing units and thge weights and how the learning process takes place and the properties of the brain: fault tolerance, parallel computing, ... "
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "An artificial neural network is a highly parallel computation model with learning and memory capacities. Similar to the brain it learns from the environment by strengthening the synapses between neurons. Once a task is learned it can be quickly used by reactivating those learned synapses."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Artificial neural network is massively parallel distributed processor made up of simple computing units called neurons which aquires knowledge from environment through learning. It resembles brainlike structure in two ways, \n", 
      "\n", 
      "1. It aquires knowledge through learning and experience \n", 
      "2. It stores knowledge in interneuron connections called synapses. "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Artificial neural network is massively distributed paralled processor containing simple processing units and has natural propensity to store experiential knowledge and use it.It resembles the human brain in two aspects, it gains knowledge from the environment and adapts the synaptic weight to store the knowledge."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "ANN is a learning machine which can perform complex parallel computation. It has the ability to learn through the interactions withthe environment and store the learned knowedge. \n", 
      "\n", 
      "It resembles the human brain in performing complex learning tasks, acquiring information, apadpting to the environment, and exploiting the acquired information."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "An artificial neural network is a graph of small and identical processing units that these small units called neurons and they are connected to each other in different architectures and the whole network adapt and itself to the environment inputs by trying to decrease the error or the cost function and increase its preciseness by manipulating the free variables of the network which are the synaptic weights.\n", 
      "\n", 
      "It is similar to human brain because similar to the human brain we have many small processing units that are connected together and they react to the environment and learn from the environment."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "An Artificial Neural Network is a massively parallel distributed processor which interacts with its surrounding environment, with a propensity to store knowledge and make it available to use.  \n", 
      "It resembles the brain in two aspects:  \n", 
      "1. It has the ability to learn from its environment  \n", 
      "2. The knowledge is stored in synaptic weights"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "An artificial neural network is a massively distributed parallel processor made up of simple processing units that have the natural propensity for storing experiental knowledge and making it available for future use.\n", 
      "\n", 
      "It resembles the brain in the following ways:\n", 
      "\n", 
      "1. Artificial neural networks have the ability to acquire knowledge from the environment in which they are are embedded.\n", 
      "2. Inter-neuron connection strenghts called synaptic links activate each neuron during the learning process."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "An artificial neural network consists of neurons, which are small computation devices,and synapses, the connections between the neurons. This resembles the brain because it also has neurons and synapses. Also a artificial neural network has weights, which are used to store learned features from the environment. Like the brain a neural network learns from the environment. An artificial neural network also has an activation function, which creates the output."
     ], 
     "points": 2
    }
   ]
  }, 
  {
   "qid": 2, 
   "question": "Define the mathematical model of a neuron, use the appropriate technical terms!", 
   "answers": [
    {
     "answer": [
      "YOUR ANSWER HERE: The neuronal model consists of the following:\n", 
      "- Synaptic links characterized by their weights which connects the network to the environment it is embedded in.\n", 
      "- An adder function which sums up the weighted inputs and outputs the induced local field of the neuron.\n", 
      "-  An activation function which takes the induced local field of the neuron as it's input and limits the output of the neuron."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "1) Neuron is consist of sysnaptic  links which measured in terms of weights. neuron is given with inputs.\\\n", 
      "\n", 
      "2)it has adder funtion or combiner which adds all the inputs mulitplied by the weights and bias is extra input to the neuron as well.\n", 
      "\n", 
      "3) it has a activation link which limit the amplitude of the output of the neuron.\n"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Neuron is the basic information processing unit which is the main component of a neural network. A neuron is charecterized by its input ($x_i$), synaptic weight ($w_i$) and activation function $\\phi(v)$. Mathematically it can be modelled as $\\phi(w_ix_i)$. Activation function bounds the input to a certain level."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE\n", 
      "\n", 
      "A neuron has three components\n", 
      "\n", 
      "* Synaptic weight: w\n", 
      "* Adder function: it multiplies input x with the weight\n", 
      "* Activation function: It squashes the output of the adder function. Sigmoid, hyperbolic tangent, Rectified linear unit etc."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "A neuron consist of set of inputs that takes data from environment. Each neuron contains synapses(connection links) that are characterized by weights. All inputs are connected to the summing (adder) function, that computes weighted sum of all input values. This weighted sum is called local field of neuron. The value of this local field (V) is limited(squased) by an activation funtion $\\theta(V)$. The result from this squasing funtion is output of a neuron ($y = \\theta(V)$).  Additionally, a bias term $(b)$ is added to the input, and its value is always 0, but its associated weight is being changed over training period. Finally, output of neuron is $y = \\theta(V)$, where $V = \\sum W_j * X_j + b$"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The neurons are the basic processing units in neural network\n", 
      "\n", 
      "output of the neuron = $  \\phi (\\sum w_{i} x_{i})$ \n", 
      "\n", 
      "\n", 
      "they consist of three parts\n", 
      "\n", 
      "Synaptic weight: the connections between the neurons. characterised by weights\n", 
      "\n", 
      "Adder function: calculates the weighted sum of the inputs of the neuron\n", 
      "\n", 
      "Activation function: limits the amplitude of the output of the neuron. ($\\phi$)"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The model of a neuron consists of synaptic weights which are applied to the input signals. The weighted inputs are then summed which gives the local field. This local field is put into an activation function whose output will be the output of the neuron."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "A neuron is a basic information processing unit that have a adder function to compute **weighted sum of inputs plus bias** and apply activation function on the result.\n", 
      "\n", 
      "$$ \\phi(v) = \\sum\\limits_{i=1}^n \\omega(i)x(i) + bias $$"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Each neuron has a set of inputs and their respective weights.\n", 
      "\n", 
      "The local field is,\n", 
      "\n", 
      "$v = \\sum(w_{ij} * x_i)$\n", 
      "\n", 
      "The local field is passed through a activation function.\n", 
      "\n", 
      "So the output of the neuron is,\n", 
      "\n", 
      "$y = \\phi(v)$\n", 
      "\n", 
      "$y = \\phi(\\sum(w_{ij} * x_i))$"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE\n", 
      "A Mathematical model of a neurons consits of a \n", 
      "\n", 
      "1. A set of synaptic links which are classified based on weights(w1, w2, w3...w_n)\n", 
      "2. It consits of a adder function, which performs the weighted sum of the inputs and the bias.\n", 
      "$\\Sigma_{i=1....n} w_n.x + b$\n", 
      "\n", 
      "3. It consists of an activation function, used to minimize the amplitude of the neuron output.\n", 
      "$\\Phi(\\Sigma_{i=1....n} w_n.x + b)$"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "A mathematical model of neuron comprises of 2 main units:\n", 
      "* Adder functions: it sums up all the product of all synaptic connections and inputs of neuron\n", 
      "* Synaptic weights: these are interneuron connections in which the knowledge is stored\n", 
      "* Activation function: it is used for introducing non-linearity "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "$v_k = \\sum_{j=1}^{m} w_{kj} x_j + b_k$, $y_k = \\phi(v_k)$, $w_{kj}$ is the synaptic weight  connecting neuron k and input data j, $x_j$ is input data, $b_k$ is bias, $v_k$ is induced local field, $y_k$ is output of neuron."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The neuron is the basic processing unit of a neural network and is made of three main component:\n", 
      "- Weights: $w_1, w_2, ...,w_n$\n", 
      "- Adder function: it is the linear combination of the input and weights plus bias. (induced local field) $v = \\sum w_i x_i + b$\n", 
      "- Squashing function: it is the activation function applied to the local field used to limit the output of the neuron. $\\phi(v)$\n"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "A neuron is a computational unit composed of\n", 
      "+ synapses which are stored in the form of weights $w$. These are the variables that can are dynamical.\n", 
      "+ summing function that computes the weighted sum of inputs: $v = \\sum_i (w_ix_i)$\n", 
      "+ activation function $\\phi$: gives nonlinear nature to network, determines and normalizes the output produced by neuron. e.g. sigmoid function\n", 
      "+ bias: another synaptic tunable variable with input 1. Therefore the net output of neuron: $ y = \\sum_i (w_ix_i) +b$."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The following equations describe a nonlinear model of a neuron, labeled k.\n", 
      "\n", 
      "1)u_k = sum from j=1 to m w_{kj} x_{j}\n", 
      "\n", 
      "2)y_k = phi(u_{k} + b_{k})\n", 
      "\n", 
      "where x_{j} are the input signals; w_{kj} are the weights of the neurons; u_{k} is the linear combiner output due to the input signals; b_{k} is the bias; phi() is the activation function; and y_k is the output signal of te neuron."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "A neuron is a processing unit that contains three main components: a set of synaptic weights that connect the neuron with other neurons; an adder that computes the induced local field, or the weighted sum of the signals flowing through the neuron; an activation function that constrains the magnitude of the output signal from the neuron."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The neuron consists of synapses/connecting link each characterised by a weight. A linear combiner sums up the weighted sum of inputs to a local field. The local field is then passed through an activation function. The result of the activation function is the output."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "A neuron is defined by the following elements:\n", 
      "- A number of input values x\n", 
      "- A number of weights w\n", 
      "- A bias b\n", 
      "- An activation function $/phi$.\n", 
      "\n", 
      "The inputs x are multiplied with the weights, and the result is summed with the bias (also, the bias can be used just as a weight value b and a single connetion with an stable input equal to 1, for mathematical simplicity). The resulting value, known as local field (v), will be the input to the activation function.\n", 
      "\n", 
      "The mathematical model can be summarized in the formula:\n", 
      "\n", 
      "$v = \\sum^{n}_{i = 0} x(i)*w(i) + b$\n", 
      "\n", 
      "$y = \\phi(v)$"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "$y = \\sum_{i=0} \\Phi(w*x_i)$ \n", 
      "\n", 
      "A neuron consists of inputs $x$, synpatic weights $w$, an extra input $w_0$ which is fixed to 1 for the bias, an Adder function, that creates the local field $v$ and a squashing function $\\Phi$."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Neuron is a simplest computation unit of a neural network that consists of input variables, weights, bias, summation term (combiner), activation function and output variables."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Input vector $x$\n", 
      "\n", 
      "Weight matrix $w$\n", 
      "\n", 
      "Net input $net=\\sum x^Tw$\n", 
      "\n", 
      "Net output $o=\\phi(net)$"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "A neuron consists of three basic components:\n", 
      "   - *Synaptic Weights*: The synaptic weights are connections between neurons and are adjusted through training.\n", 
      "   - *Squashing/Activation Functions*: The squashing functions may be non linear or linear functions that that are applied to the signals from the neurons\n", 
      "   - *Adder Functions*: The adder functions help in combining outputs from several neurons. \n", 
      "   \n", 
      "\n"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Mathematical model of a neuron is given as :\n", 
      "\n", 
      "   y = $\\phi(V)$ , where activation function is applied to local field(V)\n", 
      "   \n", 
      "   V = $\\summation (w_{i}x_{i} + b)$  . Local field is weighted(w) sum of inputs(x) plus bias(b)\n", 
      "   \n", 
      "   "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE A neuron is an information processing unit. It consits of: inputs associated with weights, sum of inputs and an acitvation function\n", 
      "\n"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "A neuron is the simplest processing unit of a neural network which has:\n", 
      "\n", 
      "1. synaptic weights to store the knowledge gained.\n", 
      "2. Adder function (linear combiner) which adds the weighted values of the input signals to produce the local field.\n", 
      "3. An activation function which squashes the local field to a range of values.\n", 
      "\n", 
      "$ \\phi(\\sum_{i=0}^{N} w_i \\cdot x_i) $"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "$N$ number inputs, $x_i$ input i, $v_j$ local field, $\\varphi(v_j)$ activiation function, $y_j$ output, $w_{ji}$ weight from node i to j\n", 
      "\n", 
      "$y_j = \\varphi(v_j)$\n", 
      "\n", 
      "$v_j = \\sum_{i=0}^{N}w_{ji}x_i$"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "A neuron is a simple processing unit of an ANN, that is made up of\n", 
      "\n", 
      "- the synaptik links which are defines by a weights $(w_1,...,w_n)$\n", 
      "- a adder function that combines the weighted input $(w_i*x_i)$ plus some bias $(b)$ to the local field  $(\\sum{w_i*w_i}) +b=v$\n", 
      "- a activation function phi that squaches the local field to the output $(phi(v)=y)$ "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "A neuron consists of input nodes x_1 to x_n and weights w_1 to w_n, a linear combiner v= SUM( $ x_i * w_i $) + b, where b is some bias. The result v is called local field and is used as input for an acivation function $ phi(v) $"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "A neuron consist of input connection links with a synaptic weight, a bias, an adder which adds the input singnals and the bias and produces the local field. The local field is processed by the activation function and produces the output of the neuron. "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "A neuron consists of one or multiple inputs which are gathered by a summation function. The hereby induced local field of the neuron is processed by a squashing function and generates the output of the neuron."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Neuron is consists of three units. \n", 
      "\n", 
      "1. Synaptic links characterizex by weights which linearly ways the input.\n", 
      "2. Adder which adds weighted inputs to generate local field\n", 
      "3. Activation function which is nonlinear function sqashing the output of the neuron"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The mathematical model of neuron has three parts:\n", 
      "- a set of synapses or connencting links characterized by weight ,w .\n", 
      "- an adder function that calculates the weighted sum of inputs plus some bias\n", 
      "- an activation function (squashing function) to minimize the amplitude "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "A mathematical model of neuron consists of 3 important parts.\n", 
      "A neuron is the smallest computaional node with:\n", 
      "1) Input vectors : set of vectors of a certan dimension to train the model\n", 
      "2) Weights (and biases): each of the input vectors are weighted using weight vectors in accordance withthe output that is required. Bias is added when necessary.\n", 
      "3) Activation function : The linear combination of weights and inputs are passed through the activation function which produces an output."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "A neuron consists of a set of inputs and a bias which these inputs and predefined bias will be multiplied by a weight and then we have sum the results of all the inputs and bias multiplied by the weights which called induced field and after that we send this to an activation function which can be a linear or non-linear function and the output of this function is the final output of our neuron. "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Let $x_1$, $x_2$, ... , $x_N$ be the inputs to the neuron, $w_i$ be the corresponding weights of connections, $b$ be the bias and $\\varphi(.)$ be the activation function. \n", 
      "Then, the induced field $v$ is given by -\n", 
      "\n", 
      "$$v = \\sum_{i = 1}^{N} w_i .x_i + b$$\n", 
      "\n", 
      "The output $y$ is given by -  \n", 
      "$$y = \\varphi(v)$$"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The neuron is the fundamental processing unit of an aritificial neural network that is characterised by the followig features:\n", 
      "\n", 
      "1. A neuron has a set of non-linear synaptic links, an externally applied bias, and possibly one or more linear activation links. The bias is represented by a synaptic link from an input fixed at +1.\n", 
      "2. The synaptic links of the neuron weight the respective inputs.\n", 
      "3. An adder function (linear combiner) computes the weighted sum of the inputs to the neurons.\n", 
      "4. An activation function (squashing function) limits the amplitude of the neuron's output."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "$y = \\sum f(wx + b)$, where w are the weights, which change the input according to the learned weights, x is the input from the environment, b is the bias, which shifts the learned decision plane, and f() is the activation function, which limits the output to a desired region of values."
     ], 
     "points": 2
    }
   ]
  }, 
  {
   "qid": 3, 
   "question": "Assume you want to binary classify linear separable data point using a perceptron. Write down the learning algorithm in pseudo code!", 
   "answers": [
    {
     "answer": [
      "YOUR ANSWER HERE: Perceptron learning algorithm:\n", 
      "- Initialize the network by assigning random weights to the synaptic links.\n", 
      "- Calculate error as the difference of the desired output with the actual output.\n", 
      "- If the input is misclassified with positive error, $w_(new)$ = $w_(current) + input$.\n", 
      "- If the input is misclassified with negative error, $w_(new)$ = $w_(current) - input$.\n", 
      "- If the input is correctly classified, no changes are made in the weights.\n", 
      "- Repeat from step 2 as long as the error is under some defined threshold value."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "for a binary classifier we can use threshold activation funtion.\n", 
      "\n", 
      "1) randomly initilize the weights \n", 
      "\n", 
      "2) you calculte the output of the neruon \n", 
      "\n", 
      "3) find out the error by subtracting expected output and current output.\n", 
      "\n", 
      "4) modify the weights related to that input with respect to the error.\n", 
      "\n", 
      "5)repeat the process 2-4 till the you get minimal error.\n"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE\n", 
      "\n", 
      "continue_process = true\n", 
      "\n", 
      "w = randomly_initialize()\n", 
      "\n", 
      "while continue_process\n", 
      "\n", 
      "  for x in list of points\n", 
      "  \n", 
      "    y = w.x\n", 
      "    \n", 
      "    diff = d-y  // d is  the desired output\n", 
      "    \n", 
      "    if(diff >= 0)\n", 
      "    \n", 
      "      w = w + x\n", 
      "      \n", 
      "    else\n", 
      "    \n", 
      "      w = w - x\n", 
      "      \n", 
      "      \n", 
      "  if all points are classified without error\n", 
      "  \n", 
      "    continue_process = false"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "n<- learinig rate\n", 
      "\n", 
      "Repeat until the MSE is small enough:\n", 
      "\n", 
      "t=t+1\n", 
      "\n", 
      "    for each point in training set do:\n", 
      "\n", 
      "        compute local vield of percepron: V = W*X\n", 
      "\n", 
      "        apply linear activation function: $y =  \\theta(V) = V$\n", 
      "\n", 
      "        compute current error: e = (d-y)\n", 
      "        \n", 
      "        \n", 
      "        apply delta rule: W(t+1) = W(t) + n*e*X \n", 
      "\n", 
      "    end"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "w = [random number betrween -1 and 1]\n", 
      "\n", 
      "\n", 
      "for every data in training set\n", 
      "\n", 
      "\n", 
      "{\n", 
      " In the first layer: \n", 
      " \n", 
      " calculate the weighted sum  using adder function\n", 
      " \n", 
      " calculate the output of the activation function\n", 
      " \n", 
      " In the ouput layer\n", 
      " \n", 
      " calculate the output y  \n", 
      " \n", 
      " calculate the error e = d - y ; d- desired output\n", 
      " \n", 
      " \n", 
      " change the weights using the formula $ \\delta w = \\eta x_j e_j$\n", 
      "\n", 
      "} \n", 
      "\n", 
      "continue till the error converges "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "    Initialize as many random weights as the dimension of the data points\n", 
      "\n", 
      "    For each data point:\n", 
      "        if the output matches the desired output\n", 
      "            do nothing\n", 
      "        else:\n", 
      "            change the weights in the direction of the datapoint so that the datapoint is classified correctly\n", 
      "        end if\n", 
      "    end for\n", 
      "\n", 
      "    if some weight was changed:\n", 
      "        start again with the for loop\n", 
      "    end if"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "* Randomly assign values to initial weights\n", 
      "* Run the perceptron network and calculate the error (e = y-d) where, e is error, y is output and d is desired response.\n", 
      "* Update the weights based on the error.\n", 
      "* If error is positive, add the error with the input and update weight.\n", 
      "* If error is negative, subtract the error with the input and update weight.\n", 
      "* If there is no error, don't update the weights.\n", 
      "* Repeat the above process until the calulated error is approximately equal to zero."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "We use threshold function as activation function. \n", 
      " \n", 
      " if w.x + b >= 1 \n", 
      " \n", 
      " label class 1.\n", 
      " \n", 
      " else label class 0."
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "e(n) = current error  <br>\n", 
      "eps = convergence criteria  <br>\n", 
      "n = learning rate  <br>\n", 
      "while (change in e(n) not less then eps) {<br>\n", 
      "    calculate error e(n) <br>\n", 
      "    w(n+1) = w(n) + n e(n) x(n)  (Widrow Hoffmen rule) <br>\n", 
      "    }"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "apply input data to input layer and initialize small values weights\n", 
      "\n", 
      "minimize error according to difference between desired signal and output signal\n", 
      "\n", 
      "assign the test vector the class that has smallest error"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Initialize the weight vector $\\hat{w} = 0$\n", 
      "- do\n", 
      "-    for every training sample x,d\n", 
      "\n", 
      "         $v = \\sum w_i x_i + b$\n", 
      "         $y = \\phi(v)$\n", 
      "         \n", 
      "         if d is not equal to y then\n", 
      "             $e = d - y$\n", 
      "             $w = w + \\eta e(i) x_i$\n", 
      "-  until convergence\n", 
      "   "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "**Pseudo code**\n", 
      "+ initiate weights and bias randomly.\n", 
      "+ compute output for the given input data $ y' = \\sum_i (w_ix_i) +b$.\n", 
      "+ compute error between computed $y'$ and desired output $y$.\n", 
      "+ update weights: $w(n+1) = w(n) + \\eta (y-y') x$\n", 
      "+ stop when the error is below some specified threshold or becomes zero in case of data that is perfectly linearly separable."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "Initialize the perceptron with each weight equal to 0: $w(0) = 0$.\n", 
      "\n", 
      "Present the labeled examples $(x_i, d_i)$ to the perceptron.\n", 
      "> for each example $(x_i, d_i)$\n", 
      ">> Compute actual output $y_i$ and error signal\n", 
      "\n", 
      ">> Update weight based on the dlelta rule: $w(n+1) = w(n) + \\eta (d(n) - y(n)) x(n)$"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "weights # a weight vector\n", 
      "phi = activation function\n", 
      "eta = learning rate\n", 
      "for each datapoint (x_i,y_i) do:\n", 
      "    weights[i] = weights[i] + eta * (x_i[i]-y_i)*weights[i]"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "1: w, b = init_weights_bias() // the weights can be initialized to 0 or random initialized\n", 
      "\n", 
      "2: n = 0\n", 
      "\n", 
      "3: WHILE !stop_criteria() DO // iteration until stop criteria is fulfilled\n", 
      "\n", 
      "4: y = w(n) * x(n) + b // calculate output\n", 
      "\n", 
      "5: IF x is in C1: e = 1 // if the x belongs to class C1, error i 1, otherwise is -1\n", 
      "\n", 
      "6: ELSE IF x is in C2: e = -1\n", 
      "\n", 
      "7: w = w + e * x // update weights using the calculated error\n", 
      "\n", 
      "8: n = n + 1\n", 
      "\n", 
      "9: END\n", 
      "\n", 
      "The stop criteria can be, if the number of misclassified input data is 0, then stop."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "1. Initialize the weights at random or as 0.\n", 
      "2. Activate the Perceptron by giving an example.\n", 
      "3. Compute the actual output of the neuron.\n", 
      "4. Adjust the parameters of there perceptron.\n", 
      "5. Continue until convergence is achieved.\n", 
      "\n", 
      "w = rand\n", 
      "\n", 
      "y = sum($\\Phi$(w*x))\n", 
      "\n", 
      "for w_i in w:\n", 
      "\n", 
      "    w_i = w_i+$\\eta$*e*y "
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Define a bias in order to be able to trigger to which class data points will be classefied to. Assign initial randomly chosen weights, use a squashing function for example McCullon Pits, start training proccess and stop when error of output and desired output has reached desired percentage."
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "initialize weights with zero or small values;\n", 
      "\n", 
      "sample data point, feed into network;\n", 
      "\n", 
      "compute net output, use the step activation function;\n", 
      "\n", 
      "compute error $e=(d-o)$, where d is the true label, o is the predicted label;\n", 
      "\n", 
      "correct weights based on $w(t+1)=w(t)+\\alpha(d-o)x$, where alpha is the training rate and x is the input pattern;\n", 
      "\n", 
      "repeat for each pattern until convergence is reached;"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "For this case, the parameters that need to be learned are the slope of the line and the intercept. These are the parameters for the weight vector.\n", 
      "\n", 
      "\n", 
      "1. Initialize random small values for weight vector.\n", 
      "2. For input_data $x_i$ in Training Data:\n", 
      "     - Apply the input to the weight vector.\n", 
      "     - e = the difference between the local field and the desired output $(d_i-y_i)$\n", 
      "     - Update weight: w(n+1) = w(n) + $\\eta e x_i$     "
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "1. Initialization: n(time step or iteration) = 1 and weights are small but randomly initialized\n", 
      "2. Activation of perceptron:  Apply training pattern to activate the perceptron\n", 
      "3. Compute Output: Apply Activation function to the local field(weighted sum of inputs plus bias)\n", 
      "4. Adjust Weights: Adjust weight if current output(y) != desired output(d)\n", 
      "5. Continuation: We continue by increasing n during each iteration and repeat from step 2 untill all input pattern are applied to network and also error is minimized "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE: \n", 
      "y denotes the actual result, d denotes the desired result\n", 
      "positive train error: y = 0, d=1 $w_{new} = w_{old} + x $\n", 
      "negative train error: y = 1, d = 0 $w_{new} = w_{old} - x$"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "1. Label one class a positive with label +1 and the other class as negative with -1.\n", 
      "2. Augment the data with an additional value for the bias term.\n", 
      "3. Invert the sign of the data in the negative class.\n", 
      "4. Randomly initialize weights.\n", 
      "5. If $w^T \\cdot x <= 0$, update weight by $ w(n+1) = w(n) + \\eta x(n) $, else leave the weight unchanged.\n", 
      "6. Continue step 5.\n", 
      "7. terminate when there is no longer a change in any weight."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "$\\varphi(v) = \\tanh(v)$, single node network, $\\mu$ learning rate\n", 
      "\n", 
      "repeat as long as error is too high:\n", 
      "\n", 
      "1. present sample to network and collect output.\n", 
      "2. compare actual output with desired output (d).\n", 
      "3. If not equal adapt weights: $w_i(n + 1) = w_i(n) + \\mu(d-y)x_i$"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "given $k$ date points $(x_i,y_i)$ and $y_i\\in\\{1,-1\\}$\n", 
      "\n", 
      "given a learning rate\n", 
      "\n", 
      "for each point i\n", 
      "\n", 
      "    add a bias 1 so that point i == (1,x_i,y_i) ;\n", 
      "    \n", 
      "for each point i there y_i == -1\n", 
      "\n", 
      "    point = -1 * point;\n", 
      "    \n", 
      "w= Nullvector;\n", 
      "\n", 
      "b = 0;\n", 
      "\n", 
      "convergance = false;\n", 
      "\n", 
      "while(convergence == false)\n", 
      "\n", 
      "    convergance = true;\n", 
      "    \n", 
      "    for each point i in the training set:\n", 
      "\n", 
      "        if(w*x<=0) do\n", 
      "        \n", 
      "            w = w+learningrate*point_i; \n", 
      "            convergance = false;\n", 
      "    "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "training_set := set of labeled linear seperable data points  \n", 
      "w := weight vector with dimension of input data  \n", 
      "v := local field  \n", 
      "phi(v): activation_function (threshold function)  \n", 
      "y:= output  \n", 
      "e := error (y - d) where d is the desired output from labeled training data  \n", 
      "n := learning rate (0.1)  \n", 
      "  \n", 
      "assign random values for w  \n", 
      "  \n", 
      "for x in training_set:  \n", 
      "    v = sum(x_i * w_i)  \n", 
      "    y = phi(v)   \n", 
      "    e = y - d  \n", 
      "    w = w + n*x*e // delta rule  \n", 
      "end     \n"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "pick random decision boundary\n", 
      "while one of data points is in wrong class\n", 
      "    turn decision boundary by using vector of wrong data point\n", 
      "    (negative rule or positive)"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "for n iterations\n", 
      "\n", 
      "    for each datapoint d\n", 
      " \n", 
      "        error = desired - output\n", 
      "        \n", 
      "        if error > 0\n", 
      "        \n", 
      "            weights = weights - error\n", 
      "            \n", 
      "        if error < 0\n", 
      "        \n", 
      "            weights = weights + error"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "initialize weights w and bias b\n", 
      "\n", 
      "set learning rate n\n", 
      "\n", 
      "set error_threshold (upper bound on error)\n", 
      "\n", 
      "while error < error_threshold :\n", 
      "\n", 
      "    for every datapoint x in tarining dataset :\n", 
      "        y = [w, b] . [x, 1]       (bias is represented as weight of fixed input 1)\n", 
      "        if y is positive then x belongs to C1 otherwise to C2\n", 
      "        store above predicted class.\n", 
      "        find error in predicted output with respect to the labels\n", 
      "        store error e\n", 
      "    e_sum = sum of all errors e for every data point \n", 
      "    w = w + n * e_sum\n", 
      "    \n", 
      "  "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "The linear binary classifiable data consists of input vector $X$ which when multipled with weights and added bias, fall into class+ or class- depending on the linear combination output of $WX + b$ being above 0(+) or below 0(class -).\n", 
      "\n", 
      "Algo:\n", 
      "Para,meters : X,Y(desired output), W, b\n", 
      "\n", 
      "1) weight vector W is initialized with small random values.\n", 
      "\n", 
      "2) Input vector is chosen with a probabiity and output is computed using $WX + b$ . If the class Y of vector X is + and output is $<0$, or if the class of X is - and output if >0, then the weights are updated accordingly.\n", 
      "Otherwise weights are left unchanged.\n", 
      "\n", 
      "3) iterated over other input vectors until convergence of output."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The learning process consists of three main steps:\n", 
      "\n", 
      "1- Positive error:\n", 
      "    - calculate the error of all the data sets in the learning set \n", 
      "    - change the w(weight): w(n+1) = w(n)+positive error\n", 
      "    - seperate the data points based on the new w\n", 
      "2- Negative error:\n", 
      "    - calculate the error of all the data sets in the learning set \n", 
      "    - change the w(weight): w(n+1) = w(n)+negative error\n", 
      "    - seperate the data points based on the new w\n", 
      "3- No error: \n", 
      "    - when we have no error this is the end of the training"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "1. Inputs X: $x_1$, $x_2$, ... , $x_N$  \n", 
      "2. Desired outputs y: $y_1$, $y_2$, ... , $y_N$  \n", 
      "3. Initialize weight vector $w$ to random small values  \n", 
      "4. For each data point $x_n$ in X:  \n", 
      "     Calculate $\\hat{y}_n$ from $w$ and $x_n$  \n", 
      "     Calculate error $e_n = y_n - \\hat{y}_n$  \n", 
      "     Update $w$ according to delta rule    \n", 
      "   end\n", 
      "    "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "1. Initialization : At time step  n(0), initialize weight vectors with random values $w_j(0)$\n", 
      "2. Activation : Apply the input example $(x_i(n),d_i(n))$ to activate the perceptron with heavyside step function as the activation function. \n", 
      "3. If output of the perceptron $y(n) \\neq d(n) $, adjust the weight vector using the rule : $w(n+1) = w(n) + \\eta x(n)(d(n) - y(n))$\n", 
      "4. Go to Activation and repeat until no more change in weight vector is observed"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Initialize the weights randomly.\n", 
      "\n", 
      "$y = \\sum f(wx + b)$, compute the output of the perceptron using the input x, the weight w, the bias b and the activation function f().\n", 
      "\n", 
      "$e = d - y$, calculate the error by substracting the actual output from the desired output.\n", 
      "\n", 
      "$w_{new} = w_{old} + learning\\_rate \\cdot x \\cdot e$, update the weights with this formula. The learning rate is a parameter which changes how fast the perceptron learns."
     ], 
     "points": 2
    }
   ]
  }, 
  {
   "qid": 4, 
   "question": "Explain classification and regression; what is the difference?", 
   "answers": [
    {
     "answer": [
      "YOUR ANSWER HERE:\n", 
      "- Classification is a problem of assigning labels or classes to the input. The output is a discrete variable.\n", 
      "- Regression is a problem of assigning a continuous variable to the input."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "classification is type of problem where algorithm needs to saperate the one data class from the another data class. \n", 
      "If there is 2 classes C1 , C2 . algorithm classify the given data into these two classes. \n", 
      "it is discreet process.\n", 
      "\n", 
      "Regression is the pridicting the next point depending on the previous points.\n", 
      "it is continuous process."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Classification is the problem where the input data has to be put in two or more classes distinctively different from each other. For example in case of binary classification on class can be -1 and the other +1\n", 
      "\n", 
      "Regression on the other hand is data fitting. THe main aim is to find a hyperplane which can fit a given input pattern."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE\n", 
      "\n", 
      "Classification: Is a task to partition the given input into one of several classes. The calsses are descrete values.\n", 
      "\n", 
      "Regression: Regression is the tasks of predicting output in a continuous range. The prediction can be any value within a range."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "In classification task the aim to separate data in  different classes, such that output of NN gives value of class index for each input point. E.g in the task is to classify binary data, then the output of the NN will 0 or 1, and each value, represent on class.\n", 
      "\n", 
      "In case of regression task, the aim is to fit data, namely a function that perform input-ouput mapping. Output of NN in this case, will be error value, such that we know how close is out function fitted to data points."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Regression: \n", 
      "\n", 
      "Tries to fit a line are curve among the given points\n", 
      "\n", 
      "The have continuous output\n", 
      "\n", 
      "the output is a function\n", 
      "\n", 
      "Classification: \n", 
      "\n", 
      "Tries to classify the given points into two or more calsses\n", 
      "\n", 
      "They have a discrete output\n", 
      "\n", 
      "the output is a value representing the class"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Classification: Each datapoint is assigned with a class\n", 
      "\n", 
      "Regression: Each datapoint is assigned with a value\n", 
      "\n", 
      "In classification we assign classes or labels to datapoints. The error signal here can be only true or false. In regression we try to learn a function, the error for each prediction can be a number."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Classifaction problem is used to classify set of data points into specific groups.\n", 
      "\n", 
      "Regression is used to predict time series data.\n", 
      "\n", 
      "Classification works on discreate set of values and regression works on continuous values."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Classification: Classification is done between the classes. The machine determines to what class the data belongs to.\n", 
      "\n", 
      "Regression: Regression is a expecting output for an input. The machine learns from the given data and models a function and when new input is given it expects the output.\n", 
      "\n", 
      "Difference: Classification is discrete output where as Regression is a continuous output."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Classification: \n", 
      "We need to predict the output data discretely. That is the output space is a discrete space. \n", 
      "\n", 
      "Regression:\n", 
      "We need to predict the output data continuously. That is the output space is continuous space\n", 
      "\n", 
      "The main difference is the discreteness and contionousness."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Classification is a problem of assigning a particular class to each data point in a given dataset. <br>\n", 
      "Regression is a problem of fitting the given dataset on a particular hyperplane which can be used for representing the given data. It finds the hyperplane which minimises the mean square error. "
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "classification: assign a test data to a class that is prescribed\n", 
      "\n", 
      "regression: approximating an unknown function with minimization errors for input-output mapping. "
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Classification if to assign a class or category to the data, while regression is when you fit the data to a function."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "+ Regression: learns model/function that can predict other unseen data well. Target/output is real spaced.\n", 
      "+ Classification: learns a model that classifies/maps input to a discrete target label. Targetlabel/output is binary/discrete."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Classification describes the application, in which a sample is assigned to one specific pattern of the problem. In comparison to regression is the output deterministic an not continiously. In regression the output is continuous describing "
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Classification is the task of classifying the input signals into a finite number of groups, so the output is a number that indicates a certain class. Regression is the task of approximating a function by estimating the values given the input signals, so the output can be any real number."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Both are learning tasks of a ANN. \n", 
      "In classification the goal is to assign a class label to new datapoints.\n", 
      "\n", 
      "In regression the goal is to eastimate a unkown function.\n", 
      "\n", 
      "The only difference between both is that classification uses discrete class labels, while in  regression a continuous output is used"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "The approach of classification is to classify sets of input data into their correct classes (for example, used in pattern recognition). The approach of regression is to approximize to a defined function f by calculating the error between this function and the result of an algorithm. THe difference is that, the classification approach is applied to a discret data (the samples are the different points of the input space), and regression is an analogic approach where the whole function must be approximize (for any input given)."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "In classification a binary pattern has to be partitioned into the two classes. In regression a line has to be fitted closest to some datapoints. The difference is, that in Classification mthe output is a single class label, while in regression the output is continuous"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Classification is a problem of destinguishing to which discrete classes input variables are to be assigned to, regression is estimation of the output, by figuring out the continuous trend of the whole dataset."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "In classification tasks, we assign discrete labels to data points of our training dataset, either being assigned a specific label or not (binary). For supervised learning, these datapoints are labeled with a label vector ground truth. In regression, we try to model a function which fits the data points of the training data, and thus model a function with continous values."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "_Classification_: \n", 
      "   - It refers to classifying given data into discrete classes.\n", 
      "   - The output is discrete values.\n", 
      "   - Use for activity like pattern recognition, etc.\n", 
      "\n", 
      "_Regression_: \n", 
      "   - It refers to estimating the value of some continuous function given an input.\n", 
      "   - The output is continuous value.\n", 
      "   - used for activities like motor control, etc."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "In classification, output values are always discrete.\n", 
      "\n", 
      "\n", 
      "In regression, output values are continuous"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE\n", 
      "A hyerplane is given by y = w*x + b . Regression wants to determine w\n", 
      "\n", 
      "Classification wants to assign a class to a set of observations.\n", 
      "\n", 
      "Regression wants to determine separating hyerplane, classification wants to label data points with a class"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Classification:\n", 
      "\n", 
      "In classification, the output produced by the NN is a discrete value which indicates which class the input belongs to.\n", 
      "\n", 
      "Regression:\n", 
      "\n", 
      "In regression, the output produced by the NN is a continuous variable. This could be used for instance, to approximate a continuous function."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "In classification we try to assign classes to input data. Regression we want the network to behave like a given system/formala. This can also be a time series of input and output data."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "In classification the goal is to saperates points into different classes. The outcome is a class lable. \n", 
      "\n", 
      "Regression trys to fit a hyperplante to a point cloud best, so that future data is representet by that hyperplane best (LMS). It trys to minimize the distance to all data points. The outcome is a countinius variable."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Classification means mapping inptut data a class label, for example 1 and -1. IN regression on the other hand a continuous function is learned in way that f(x) - F(x) is minimized, where f(x) is the function learned by a learning machine and F(x) is the original function.  "
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "In classification the task is to give an discrete output value to an input. It assignes one of all defined classes to the current input. Regression try to approximate a function while minimizing error and produces a continous output value. "
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Classification tries to label discrete data points with distinct classes, while regression tries to approximate a continuous function from discrete data points. Results of these methods are respectively a labeled data set or a continuous function."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Classification is supervised learning where underlying function  representing the trining data is learn from training data to predict classes of datapoints or patterns drawn from similar distribution as of tarining data. Weights of the neural network are learned to minimize the error in classification. \n", 
      "\n", 
      "Regression is supervised learning algorithm where underlying function  representing the trining data is learn from training data to predict the value of label or output of some system  for new datapoint or pattern of similar type. Weights of the neural network are learned to minimize the error in prediction of function.\n", 
      "\n", 
      "\n", 
      "Differences. :\n", 
      "1. Output of classification is discrete ( Class 1,2,3 ) whereas output of regression is continuous \n", 
      "2. Error in classification is number of wrong classifications whereas Error in classification regression is distance between lable value and predicted value\n"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Classification is about classifying the given data into different classes, where as regresssion is about finding the local/global minima.We use perceptrons to classify the data and we use unconstrained optimization techniques like newton's method to find regression."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "\n", 
      "Classification is a problem of catergorization into discrete classes where as regression is a problem in a continuous space where the goal is to ether minimize or maximize a cost function.\n", 
      "\n", 
      "Classification is the process of dividing a set of discrete inputs into classes corresponding to similar patterns such as clustering.\n", 
      "Regression could be finding a pattern of the distribution of the data such as ftting a line."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "- Classification: In classification problems we have different groups of data that have some common properties and after training we want that our model can detect the class of the new sample correctly\n", 
      "- Regression: In regression we have a series of values and we want to use the previuos values in this series and predict the next value"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Classification is separating the data into classes and the output is a discontinuous variable. Regression is fitting a model and the output is a continuous variable."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Classification in machine learning is used to find a decision surface in the form of a hyperplane that can separate a set of input examples (or set of patterns) into their respective classes. Regression on the other hand is used to find the parameters (i.e, the weight vector $w$ and the bias b) for the function thatcan best fit the given data points $\\{x_i,d_i\\}$ . Thus classification deals with predicting the class label for discrete data points whereas regression deals with fitting a continuous real valued function."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "In classification the input data is split in 2 or more classes. The goal of the neural network is to learn the input data and then be able to classify new input data into the classes. Based on the learned information the network then maps input data into one of the classes, which is discrete space.\n", 
      "\n", 
      "In regression the input data is learned aswell. But here the network tries to predict feature values, which are in continuous space. The network tries to predict close as possible to new input data only using the learned model."
     ], 
     "points": 1
    }
   ]
  }, 
  {
   "qid": 5, 
   "question": "Write down the SOM learning in pseudo code.", 
   "answers": [
    {
     "answer": [
      "YOUR ANSWER HERE: SOM learning\n", 
      " - Initialization with random small weights.\n", 
      " - Sampling: Picking a input pattern with certain probability.\n", 
      " - Similarity matching: Finding the most matching neuron i.e., the winning neuron.\n", 
      " - Synaptic updation: Updating the weights of the neuron and also the neurons in it's neighbourhood.\n", 
      " - Continuation: Repeat steps 2 to 4 till there is no considerable change in the map."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "randomly inilize the weights\n", 
      "\n", 
      "draw sample of inputs \n", 
      "\n", 
      "Increase the weights of the local neihburhood of winning neuron\n", 
      "\n", 
      "repeat the process above process till there is only one winning neuron"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE\n", 
      "\n", 
      "for i in num_of_epochs\n", 
      "\n", 
      "  for p in input_points\n", 
      "  \n", 
      "    find the winning neuron\n", 
      "    find the neighbours of the winning neuron within distance sigma\n", 
      "    update winning neuron and neighbours weight\n", 
      "    update sigma and learning_rate so that both reduces over time"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "\n", 
      "{\n", 
      "take a rondom point from the training data\n", 
      "\n", 
      "competitive phase: find the winning neuron - the neuron similar feature, using the eucledian distance formula\n", 
      "\n", 
      "cooperative phase: find the neighbors of the winning neuron based on the neighbor function (eg: gaussian function)\n", 
      "\n", 
      "adaption phase: change the weights of the all the neighboring neuron of the winning node using the formula $ \\del w = \\eta x_j - w_j $\n", 
      "\n", 
      "}\n", 
      "\n"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "    input: distance function d(x, y), learning rate mu, neighborhood distance n\n", 
      "    \n", 
      "    Initialize the map layer with random weights\n", 
      "    for each input:\n", 
      "        find the weight which is closest to the input (minimum d(x, y))\n", 
      "        change the weight in the direction of the input depending on the learning rate\n", 
      "        change all weights which are within the neighborhood distance n depending on their distance and the learning rate\n", 
      "        reduce learning rate and neighborhood distance"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "* Initialize the neuron weights randomly in a way that all neurons have different weights.\n", 
      "* Generate random samples x from the input space.\n", 
      "* Iterate the samples and **Compare distance between current input and all neurons** in the weight space.\n", 
      "* **Find a winning neuron** with shortest distance from current input.\n", 
      "* Distance is calculated using **euclidean or manhatten distance**.\n", 
      "* Find the neurons in the neighborhood boundary of winning neuron.\n", 
      "* **Update the weights** of neighborhood neurons using delta rule.\n", 
      "* Adapt the size of neighborhood $(\\lambda)$ and learning rate $(\\eta)$ at each iteration\n", 
      "* Repeat the process until there is no neurons in the neighborhood boundary or all the inputs moved to some neuron."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Step1: It selects a datapoint in random through sampling.\n", 
      "\n", 
      "Step2: Finds the nearest neuron through competitive learning.\n", 
      "\n", 
      "Step3: Updates the weight of the winner neuron and updates the weight of neighbouring neurons by a fraction.\n", 
      "\n", 
      "Step4: Continues steps 1, 2, 3 until there is no change in the weights or some stopping criteria is met."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Begin\n", 
      " n = range of data set\n", 
      " \n", 
      " Initialise the weights. #We give a small random weights. \n", 
      " \n", 
      " for the range of n:\n", 
      " \n", 
      "     Select a input signal, \n", 
      " \n", 
      "     Find the winning neuron based on the similarity between the weights. \n", 
      " \n", 
      "     Update the weights of the neighboring neuron\n", 
      " \n", 
      "     Repeat until the convergence.\n", 
      "     \n", 
      "     \n", 
      "1. initalising \n", 
      "2. Sampling\n", 
      "3 Similarity matching.\n", 
      "4. Updating the weights\n", 
      "5. continuation. "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "intialise weights <br>\n", 
      "while( significant change is observed in topographic pattern) {<br>\n", 
      "take a random input (sampling) <br>\n", 
      "find the winning output neuron     (competition)  <br>\n", 
      "adjust the weights of the winning neuron and its neighbourhood neurons (cooperation) <br>\n", 
      "continue <br>\n", 
      "}"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Initialization: set random small values to weights wj is different for each neuron\n", 
      "\n", 
      "Sampling: draw n-th sample x from input space\n", 
      "\n", 
      "Competition: identify winning neuron i using arg min $||x-w_i||$ which means weight vector of i is most similar to input \n", 
      "\n", 
      "Cooperation: identify neighbors of winning neuron i using neighborhood function $h_{j,i(x)} (n)$ which shrinks with time\n", 
      "\n", 
      "Weight adaptation: adjustments made to synaptic weights of winning neuron and its neighbors\n", 
      "\n", 
      "go to sampling until no large changes in the feature map."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "\n", 
      "- Find the winning neuron\n", 
      "- Find the neighbors of the winning neuron."
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "**Pseudo code**\n", 
      "+ 1. Initialize map neurons, based on topology it could be a lattice, on a circle, etc.\n", 
      "+ 2. competition: find map neuron that is closest to an input neuron by computing distances $d$.\n", 
      "+ 3. update the position of closest map neuron with update rule.\n", 
      "+ 4. Do 2 and 3 until all input neurons are assigned a map neuron.\n", 
      "+ Do 2,3 and 4 until specified iterations or the net cumulative distance goes below some specified value or becomes zero."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Produce train_SOM;\n", 
      "\n", 
      "begin:\n", 
      "\n", 
      "    randomize weights for all neurons;\n", 
      "    \n", 
      "    for (i=1 to iteration_number) do:\n", 
      "    \n", 
      "        begin:\n", 
      "        \n", 
      "            take random input pattern;\n", 
      "            \n", 
      "            find the winning neuron;\n", 
      "            \n", 
      "            find neighbors of the winner;\n", 
      "            \n", 
      "            modify synaptic weights of these neurons;\n", 
      "            \n", 
      "            reduce learning rate and lambda;\n", 
      "            \n", 
      "        end;\n", 
      "        \n", 
      "end;"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Initialize the network with small and random weights.\n", 
      "\n", 
      "Sample the data set by  picking an input randomly.\n", 
      "\n", 
      "> Determine the winning neuron based on the output value.\n", 
      "\n", 
      "> Determine the coopertaing neurons based using the neighborhood function.\n", 
      "\n", 
      "> Update the weights of the cooperating neurons.\n", 
      "\n", 
      "> Adjust the learning rate.\n", 
      "\n", 
      "> Stop if the network converges."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "1: w = init_weights() // equal to zero or random initialized\n", 
      "\n", 
      "2: n = 0\n", 
      "\n", 
      "3: WHILE !stop_criteria() \n", 
      "\n", 
      "4: winner_neuron, y = (x, w) // find on the map layer which neuron is closer to the input (euclidean distance)\n", 
      "\n", 
      "5: neighborhood = define_neighboor(winner_neuron, n) // define the neighborhood size (first iterations big, and being reduced)\n", 
      "\n", 
      "6: eta = define_learning_rate(n) // define the learning rate (large value at the first iterations and being reduced)\n", 
      "\n", 
      "7: diff_w = adapt_weights(neighborhood, eta) // adapt the weights just for the winner neuron and its neighborhood\n", 
      "\n", 
      "8: w = w + diff_w // update the weights\n", 
      "\n", 
      "9: stop_critera = must_stop(y, x) // look if the distance between input and the winner neuron is 0 (or really close to 0)\n", 
      "\n", 
      "9: END"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "1. Initialize small random weights.\n", 
      "2. Draw the nth sample from the input space.\n", 
      "3. Similarity matching: Determine the winning neuron.\n", 
      "4. Update the weights of the neuron an the topological neighborhood.\n", 
      "5. Repeat steps 2-4 \n", 
      "\n", 
      "w = random\n", 
      "\n", 
      "n = example.draw()\n", 
      "\n", 
      "w_max = get_min(w_i*n)\n", 
      "\n", 
      "h_n = get_neighborhood(w_max)\n", 
      "\n", 
      "for w_i in h_n:\n", 
      "\n", 
      "    w_i = w_i+$\\eta$*h*y "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Has three parts in it - Competition, Cooperation, Adaptation\n", 
      "\n", 
      "get input variable and choose amount of neurons to be more than amount of variables\n", 
      "\n", 
      "then run competition, where from the input neurons will be compiting to each other on choosing which fits the most\n", 
      "after finding winning neuron change weight of neighbouring neuron only\n", 
      "\n", 
      "in cooperation weights of neighbouring neurons are adjusted to clusters\n", 
      "\n", 
      "in adaptation neurons are pulled to input variables to establish the classification"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "initialize weights with small values (such that all of the weight vectors are different);\n", 
      "\n", 
      "sample a datapoint, feed into network;\n", 
      "\n", 
      "determine the winning neuron on the lattice, picking the neuron with the least euclidean distance of its weight vector to the input vector;\n", 
      "\n", 
      "determine the neighbourhood of the winning neuron through the neighbourhood function;\n", 
      "\n", 
      "change weights of the neurons, namely spatially 'pulling' the weight vectors of the neighbourhood neurons towards the input vector;\n", 
      "\n", 
      "depending on the timestep, reduce learning rate and neighbourhood size based on wether we are in the organizing or finetuning step;\n", 
      "\n", 
      "repeat until maximum number of steps;"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "1. Randomly initialize weights.\n", 
      "2. Randomly select an input from the training data.\n", 
      "3. Find the nearest neighbour of this input in the weights. This is done by finding the euclidean distance of the input from each weight. And selecting the weight with least distance.\n", 
      "4. Update the weights of all the neurons within the neighbourhood $h(n)$ (which is gaussian function, with an exponentially decaying $\\sigma(n)$) of the winning neuron with some learning rate $\\eta(n)$.\n", 
      "    $$\\Delta w_{ij}=\\eta(n)h(n)(||x_i-x_j||)$$\n", 
      "  where,\n", 
      "  $$\\eta(n)= \\eta_0e^{-n/T_1}$$ and $$\\sigma(n)= \\sigma_0e^{-n/T_1}$$"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "i. First we initialize random weights for neurons\n", 
      "\n", 
      "ii.  Then we choose random input from input space\n", 
      "\n", 
      "iii. We compute distance between input vector and each weight vector. \n", 
      "\n", 
      "iv. Neuron that have minimium euclidean distance with input vector is considered as winner neuron\n", 
      "\n", 
      "v. Then, we find the neighborhood neurons of the winning neuron\n", 
      "\n", 
      "vi. We adjust the weights of all neighborhood neurons\n", 
      "\n", 
      "vii. Reduce the learning parameter and neighborhood size\n", 
      "\n", 
      "viii. Continue until it converges."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE\n", 
      "w denote weights\n", 
      "t denotes threshold\n", 
      "h denotes the neighborhood function, which decreases with distance d from winning neuron\n", 
      "\n", 
      "h(x, x_{win} //neighborhood function\n", 
      " return (exp(-2/||x-x_{win}||)\n", 
      "\n", 
      "w = rand(); //initialize weights with random value\n", 
      "while (w_{delta} > t){ //proceed until there are no notieable changes\n", 
      "    x_{win} = arg min ||x-w||^{2}//determine x which is closest to w (competetive learing) \n", 
      "    // Update weights of winning neuron\n", 
      "    // weights of losing neurons are not updated\n", 
      "    w_{new} = w_{old} + x*h(x, x_{win})*(x-w)//update weights of neuron which a are in neighborhood of winning neuron\n", 
      "    \n", 
      "    \n", 
      "}\n", 
      "\n", 
      "    "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "1. Arrange the weights in the required topology according to the problem.\n", 
      "2. Initialize the weights randomly such that all the weights are different.\n", 
      "3. Sample the input from the input space.\n", 
      "4. Similarity matching: match the input to a neuron in the topological lattice which becomes the winning neuron.\n", 
      "5. Update the weights of the winning neuron and its neighbours determined by the neighbourhood function. Reduce the neighbourhood and reduce the learning rate and make sure learning rate is above zero.\n", 
      "6. If ordering and convergence is complete, stop. Else continue to step 3."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "In SOM we start with randomized weights, $\\mu$ learning reate, $d_{ji}$ distance between j and i, $h$ neighbour function\n", 
      "\n", 
      "repeat as long as error is too high/max iterations are not reached:\n", 
      "\n", 
      "1. take input sample\n", 
      "2. find closest node/weight\n", 
      "3. find all it neighbours\n", 
      "4. move the weight and its neighbours closer to the given input, use the neighbour function (e.g. gaussian) to reduce effect to far distance neighbours\n", 
      "5. (optional) adapt learning rate and neighbour function"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "given a neigbourhood function $h_{ij}(n)$ and a lerning rate over time\n", 
      "\n", 
      "randomly assing different weights from the input layer to the neurons in the second layer\n", 
      "\n", 
      "for each training point x_i do:\n", 
      "\n", 
      "- find the winner-takes-all neuron $k$ with $min ||x_i-w_i||$\n", 
      "- find the neighbours of $k$ with the neigbourhood function\n", 
      "- compute the new weights for those neurons using the neighbourhood function and the learning rate\n", 
      "- update (decrease) the neighbourhood function and the learning rate\n", 
      "end"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "given a map layer \n", 
      "set random small values for weights from input to map layer\n", 
      "repeat until not converged:\n", 
      "    find best match of input value and weight of the neurons (competitive process)\n", 
      "    adapt (increase) weight of winning neuron and neighboorhood (with gauss function and neighboorhood size) (cooperating process and weight adjustment)\n", 
      "    decrease neighboorhood size "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "for n iterations\n", 
      "\n", 
      "    winner = competition_between_neurons()\n", 
      "    \n", 
      "    neighbourhood = cooperation_with_neighbourhood_function(winner)\n", 
      "    \n", 
      "    update_weights(neighbourhood)"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Initialize weight vectors of hidden neurons with same dimmension as of data.\n", 
      "\n", 
      "Number of hidden neuron should be signifiacntly greater than number of data points.\n", 
      "\n", 
      "initialize learning rate n and neghbouring function h\n", 
      "\n", 
      "while (rate of change in weights is significant):\n", 
      "\n", 
      "    for every datapoint:\n", 
      "\n", 
      "        calculate distance of each neuron from data.\n", 
      "        select winner neuron w with minimum distance (maximum similarity)\n", 
      "        error = distnce of winner form datapoint\n", 
      "        adjust weights of neurons with the rule w = w + n*h*error\n", 
      "        "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "SOM is refered to as Self organized maps which is an unsupervised training algorithm for finding spatial pattern in data without using any external help.The process in SOM is explained below:\n", 
      "-Initialization: Initialize random weights w_j for input patterns\n", 
      "- Sampling: Take n_th random sample from the input (say x)\n", 
      "- similarity matching :for the input x, find the best match in the weight vector.\n", 
      "  $i(x) = argmin(x - w)$\n", 
      "- update: the next step is to update the weights\n", 
      "$w(n+1) = w(n) + eta*h_ji(x)*i(x)$\n", 
      "- continuation : continue from sampling until there is no significant change in the feature map"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Parameters: $X$ data vectors, $W$ weights vectors in lattice , $\\eta(n)$ -learning rate, $\\sigma(n)$ - neighbourhood width, $h_{ji(x)}$- neighbourhood function \n", 
      "\n", 
      "algo:\n", 
      "\n", 
      "1) Initialize the weights to a small, random , non-repeatible values.\n", 
      "\n", 
      "2) Sample a data vector with a probabiity \n", 
      "\n", 
      "3) Compute the euclidean distance to weight vectors from the data points and find the winning neuron with minimum distance .\n", 
      "\n", 
      "4) Update the weights of the winning neuron and its neighbourhood towards the input direction using neighbourhood function.\n", 
      "\n", 
      "5) reduce the learning rate and the neighbour hood width and iterate from step 2 until no significant changes between weight vectors and inputs are seen.\n"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "- randomly define some values for the synapitc connections in the network\n", 
      "- send the first input to the network\n", 
      "- in the output layer(map layer) select the neuron that has lowest error(competition phase)\n", 
      "- based on a predefined method define the neighborhood of the selected neuron(cooparation phase)\n", 
      "- change the weights of the selected neuron and the neurons located in its neighborhood(adaptation phase)\n", 
      "- if the stop condition satisfied stop the process"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "1. Initailization: Initialize the weights of each neuron to small random values such that weight of each neuron is different.\n", 
      "2. Sampling: Sample an input from the input set\n", 
      "3. Similarity matching: Determine the neuron nearest to the sampled input based on its distance\n", 
      "4. Weight updation: Update the weights of the neighbouring neurons chosen by the neighbourhood function $h_{ij}(n)$\n", 
      "5. Continuation: Continue from sampling until there is no more change in the weights"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "1. Initialization : Initialize the weight vectors with random values such that the $w_j(0)$ is different for all weights.\n", 
      "2. Sampling : Draw sample example $x$ from input space.\n", 
      "3. Similarity matching : Find the best matching weight vector for the input vector : $W_i = argmin_i  (x - W_i(n))$\n", 
      "4. Adjust the weight vectors of neurons in the neighbourhood of the winning neuron \n", 
      "5. Go to Sampling step and repeat until no more changes are observed in the local neighbourhood of the winning neuron."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Initialize the weights randomly. Create a term T1 and T2, which decrease the learning\\_rate and neighbourhood function respectively.\n", 
      "\n", 
      "Calculate $i(x) = argmin | w - x |$, the weight which is closest to the input data received.\n", 
      "\n", 
      "i(x) is the neuron, which wins the competetive process, this neuron and its neighbours weights are updated using $w_{new} = w_{old} - learning\\_rate \\cdot h(x) \\cdot (w - x)$. h(x) is the neighbourhood function which determines, which neurons are updated and how strong they are changed by the update. It is defined using the distance between the neurons.\n", 
      "\n", 
      "The learning\\_rate is updated using $learning\\_rate / T1$, also is the neighbourhood function updated in the same way using T2. The learning\\_rate cannot get lower than 0.01, while the neighbourhood function can get as low as only the winning neuron. So in the beginning almost every neuron is updated and at the end only a small neighbourhood or the neuron itself is updated."
     ], 
     "points": 2
    }
   ]
  }, 
  {
   "qid": 6, 
   "question": "Give the basic idea of an SVM using the correct terminology!", 
   "answers": [
    {
     "answer": [
      "YOUR ANSWER HERE: SVM is a linear machine whose goal is to construct a optimal hyperplane such that the marginal separation is the maximum between the decision boundaries. The decision boundaries are drawn parallel to the hyperplane which just push the datapoints closest to the hyperplane. The datapoints closer to the hyperplane are called support vectors."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "support vector machines are the finding classfiers, draw  the dision boundary which push against the support vectors."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "The basic idea of Support Vector Machine (SVM) is to find the width of a line or hyperplane which which divides the input data into two classes. The points lying on the edge of the defined width are called support vectors.  "
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE\n", 
      "\n", 
      "SVM is a classifier that classifies a set of points in a way that maximizes the margin between the points of two classes. The classification can be linear or non linear."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "The idea behing SVM is to find a hyperplane which separate data into classes. First it is required to find a data point which are clossest to hyperplane, and these data points are called support vectors. Next task is to find a maximum possible width of the hyperplain such that support vectors are on the edge of that hyperplane.\n", 
      "\n", 
      "This problem is formulated as min-max constrained optimization problem. In order to find a optimum width of hyperplane, (optimimum of a funtction) the idea is to use method of Langrange multiplier. Additionally, when I data is not linearly separable, than an approach is to project data in higher dimension and then to find a hyperplane that separates data in that dimension."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Given a training set for classification, The basic idea of SVM is to construct a hyperplane as decision boundary such a way that the margin between the positive and negative points is maximum \n", 
      "\n", 
      "Support vector is a small subset of the of the training data against which the boundary is pushed"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "A support vector machine classifies given data using a decision boundary. The width of this decision boundary (margin) is maximized to ensure good results, because a maximized width is as robust as possible. The margin width is $\\frac{2}{\\sqrt{w * w}}$. To maximize it, quadratic programming is used. In order to handle noisy data, slack variables are introduced. To eliminate them, duality is used."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "SVM tries to find a **best hyperplane with widest margin with the help of support vectors** such that all the data points are classified correctly."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "SVM is used for linearly separable data. A hyperplane is used to separate the data, but there could be so many hyperplanes that separate the data. The best hyperplane is choosen which separates data with a bigger margin. So in SVM we find the hyperplane which has a bigger margin between the hyperplane and both the positive and negative data lines."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Given a dataset, support vector machines builds a hyperplane in a such a way that positive and negative samples are seperated to the maximum distance. Width of the margin should be maximum\n", 
      "\n", 
      "The vectors to which the margins(margin for positive and negative sample) are pushed on to it are called support vectors. "
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "SVM stands for Support Vector Machine. It creates a hyperplane such that margin of separation between positive and negative classes is maximised.  "
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "basic idea of SVM is to construct a hyperplane as the decision surface in such a way that the margin of separation between negative examples and positive examples is maximized."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Support vector machines are a type of neural network that build a desicion boundary around classes such that the margin of separation between classes is maximized. "
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "SVMs are binary classifier. They learn the classification by memorizing the marginal data points (called support vectors) that make up the decision boundaries (2 : positive and negative)."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "The abbreviation SVM stands for Suppor Vector Machine. SVMs represent a feedforward category of NN. SVMs are binary learning machines whose functionality can be summarized for classification problem as follows:\n", 
      "Given a training sample, the SVM constructs a hyperplane as the decision surface in such a way that the margin of seperation between positive and negative examples is maximized.\n", 
      "\n", 
      "One key innovation associated with SVMs is the kernel trick. The kernel trick consists of observing that many machine learning algorithms can be written exclusively in terms of dot products between examples. It allows us to learn models that are nonlinear as a function of x using convex optimization techniques that are guaranteed to converge efficiently. Besides, the kernel function k often admits an implementation that is significantly more computatinal efficient than naively constructing two vectors and explicetly taking their dot product."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "An SVM, or support vector machine, is a feedforward network with a hidden layer to learn a task in a supervised learning manner. The network tries to construct a hyperplane that separates the data points of two different classes by maximizing the margin of separation, which is the distance from the hyperplane to the closest data points called support vectors. "
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "The SVM is a maximum margin classifier. It is used the binary classify datapoints in a dichotomy. The idea is to find a line wich linearly seperates both classes. There perfect position of this line is in right in the middle of these classes. To find this line(descision boundary) we define a positive and a negative boundary which are parallel to this line. The boundarys define the margin between both classes. The idea of SVM is that the datapoints which are next to the boundary can be used to define the margin. They are called support vectors. \n", 
      "Addittionaly not every problem is linearly seperable so the idea was to transform the input into many higher dimensions using some kernel functions. We discussed the kernel function of polynomial terms and found out that it easy to compute. "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Support Vector Machines are a type of learning machines that try to classify different classes of an input space. For linear separable classes, the SVMs try to calculate the line that separates this two classes with maximum margin. The support vectors will be the points closer to this margin. When the input data is noisy, we have an optimization problem of two aspects (maximum margin, proper classification). So, a trade-off (C) will be defined. The trade-off will be calculated by the sum of the distance of misclassified points.\n", 
      "\n", 
      "For non-linear separable classes, a kernel will be defined that will transform the input data into a higher dimensional space."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "An SVM is a linear classifier that divides a binary pattern, by a line that maximizes the margin between its line and the respective support vectors."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Support vector machines are classifiers that are using support vectors, which are variables of the dataset. These variable are chosen during learning algorithm. Main advantage of SVMs is that it will not be overfitting by choosing correct margin. Activation functions can be both linear and nonlinear. Output of SVM is always TRUE or FALSE for given variable."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "An SVM is a binary, linear classifier spanning a seperating hyperplane between two classes of datapoints. The hyperplane is spanned between both the positive and negative decision boundaries, and supported by a number of support vectors. Support vectors are the outermost datapoints which span the hyperplane. During training, the distance of falsely classified data points to their correct side of the hyperplane is minimized, utilizing a quadratic programming formulation. "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "A SVM is a binary classifier with a maximum width boundary separating the two classes. This uses support vectors (vectors that pushes against the boundaries).\n", 
      "\n", 
      "The equations of the lines in an SVM are:\n", 
      "   - $wx+b>=1$:for class 1\n", 
      "   - $wx+b<=-1$:for class -1\n", 
      "   - M is the width between these boundaries."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Basic idea of SVM is to best segregate the data into two classes with the help of decision boundary. This decision boundary is margin, we always try to maximize the margin to make sure data is classified correctly"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE Support Vector Machines goal is to maximize margin between closest data points of separating hyperplane. Separating hyperplane is given by: 0 = w(n)*x(n) + b. By maximizing margin probability of classification errors is reduced. "
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "A support vector machine is a maximum margin classifier in which the width of the boundary of separation is maximized. A margin is defined as the width of the boundary before hitting a point. \n", 
      "\n", 
      "This maximum margin intuitively feels safe, and is experimentally good."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Because SVMs are binary classifiers we can use a border to sperate the data. The border is typically placed where it has the largest possible distance to both classes. The vectors the border touches on both sides with its margin are the support vectors."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "A SVM is an ANN for supervised learning, whicht is able to saperate two classes of data-points by using a hyperlane found by quadratic programming, by finding the biggest margin. The goal is to classify future data in there two classes."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "SVMs are used to linearly seperate Data points. The decision boundary is line or hyperplane in higher dimensions that defines the lable of a data point. The decion boundary is choosen in a way that the margin is maximized. Data points on the decion boundary are called support vectors and define the hyperplane. In 2 dimensions if the data is liner seperable the margin is equal to 2/sqrt(w.w) where w is the weight vector. If the data is not linear seperable, the input can be projected into higher dimension space. This increases the chance of linear seperablity."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "A SVM uses a few of the data points as support vectors to bild the maximum margin classifier. It searches for the seperating line, which has the maximum margin to the datapoints. In cases of Noise, the seperating line is searched, which minimizes the distance to the points in the wrong category. The data is cast to a higher dimensional space to use covers theorem while using kernels. The data is more likely linearly seperable in the higher dimensional feature space. Using structural risk minimization the dimensionality is reduced. "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "An SVM is a learning machine that tries to learn the support vectors of a two class data set to get the maximum margin, the optimal seperating hyperplane, between the two classes."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Support vector machine is classifier which maximizes the margin between boundries learned from two classes.\n", 
      "Margin is minimum distance by boundries can be increased before hitting datapoints.\n", 
      "Support vectors are the datapoints against which magin pushes up the boundary."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "SVM refers to support vector machines.In terms of a linear classification problem svm can be defined as creating a hyper plane which is a decision surface and to maximize the width of decision boundary.In cases where the problem is complex svm can be used as it classifies the data by projecting the data in higher dimension.If the data is to be separated in 3 classes , they can use 3 svm's for three different classes."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "The idea of SVM is to fit a supervised model onto the training data allowing maximum generalization ability. \n", 
      "\n", 
      "This is done by computing maximum margin between different classes of data using the support vectors.\n", 
      "The magrin can be computed using differeent kernels for a higher dimensional data."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "In linear SVM we have a linear border line classifier that seperate two different classes(positive and negative planes) and we calculate the distance of the data points from this border line classifier. Also a margin will be defined and this margin will be maximized until it touches some data points in the plane. The data points that the margin pushed agains them will be our support vectors. The error for the wrongly classified datapoints will be calculated by calculating the distance of the data point from its correct plane. The SVM tries to learn the classifier and the margin from the training data. "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The basic idea of SVM is to determine the best decision boundary i.e. the one which provides maximum margin so that the boundary can be widened most before it touches any datapoint. It is done using Support Vectors which are the the datapoints the margin pushes against."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "A SVM is a linear machine which is used in pattern classifcation problems to find a decision surface in the form of a hyperplane for linearly separable classes such that the margin of separation between the classes is as large as possible. SVM's are an approximate implementation of the induction principle of structural risk minimization which is based on the fact that the error rate in testing is bounded by a term that is dependent upon the sum of training error rate and the VC dimension of h. "
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "A SVM learns a decision boundary from the input data. Additionaly it learns two margins, which are parallel to the decision boundary and lie as close as possible at the data points, the support vectors. The decision boundary is chosen so that the margins are maximized. Using kernel functions higher dimensional data and non linearly separable data can be learned aswell."
     ], 
     "points": 2
    }
   ]
  }, 
  {
   "qid": 7, 
   "question": "What role does the method of steepest decent have when learning a network?", 
   "answers": [
    {
     "answer": [
      "YOUR ANSWER HERE: In steepest descent method, the network moves towards the direction of the maximum gradient. The learning with steepest descent method can be slow to converge and can exhibit zigzag behavior."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Steepest decent while move in the direction of the max improvement ( in terms of decrasing) in the cost funtion or error.\n", 
      "\n", 
      "if the learning rate is large then the it follows the zizag motion.\n", 
      "\n", 
      "if the learning rate is too low then it takes time for converging ."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "The method of steepest descent is responsible for weight adjustments in the network. The weights are adjusted in the direction of the steepest descent that is equal to the negative grad of the error. It ensures that the weights are decreased in every iteration step."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE\n", 
      "\n", 
      "Steepest decent method helps in making the adjustments of the weights in a neural network in a way that minimizes the average squared error.\n", 
      "\n", 
      "In each step it gives the direction towards which the maximum decrease of the average squared error can be achieved."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "The method of steepest decent is used for finding minimum of a cost(error) function. The steepest decent iterates over possible values of weight vector to optimize the function. It is used for deriving error function in ADALINE (adaptive linear element) algorithm, and it is used also in backpropagation method in training of Multi-layer NNs."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The steepest descent finds the direction of the error function and tries to reduce it by adding in the opposite direction\n", 
      "\n", 
      "$ del w = - \\eta g(n)$\n", 
      "\n", 
      "g(n)- gradient of the cost function"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The steepest descent is used to find the right direction in which the weights should be changed while learning a network. The derivate of the error is used and weights are changed in that direction which makes the error smaller as fast as possible."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Steepest decent helps to **minimize the value of error function $E$** by finding the **right direction **to move the weight vector to reach global minima.\n", 
      "\n", 
      "The direction is always **opposite to the direction of actual gradient vector**.\n"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Method of steepest descent is used to reduce the error. In backpropogation during backward pass we need to know how by how much amount the weights should be changed, this can be known if we use steepest descent, find the gradient of error and use it to reduce the error."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "In steepest descent the adjustments done on the weight vector are in the direction of the steepest descent which is in the direction opposite to that of a gradient descent. \n", 
      "\n", 
      "In a learning problem, it basically used to reduce the cost based on the weight. The main goal is to find an optimal weight."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Method of steepest decent is an unconstrained optimization technique used for learning in a network. It is used in iterative manner to minimize the error in supervised learning. It finds the direction of maximum gradient. So we go in the opposite direction hoping to find the minima. Convergence of the algorithm depends on the learning rate and also the condition that it doesn't get stuck in local minima."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "steepest decent method is based on minimization of error cost function $\\xi(w) = 0.5 e^2_k(n)$, so synaptic weight of network is updated in a direction opposite to gradient vector of $\\xi(w)$, that is $W_k(n+1) = W_k(n) - \\eta \\nabla \\xi(w) = W_k(n) - \\eta e_k(n) x(n)$, $\\eta $is learning rate.$e_k(n)$ is neuron k error signal, $x_j(n)$ is input data."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The steepest descent is an unconstrained optimization method that seeks to minimize an error function. This function is iteratively changed in direction oposite to the gradient vector."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Method of steepest descent updates the weights in the direction where the error is minimum."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "The steepest descent method is an algorithm for finding the nearest local minimum of a function which presupposes that the gradient of the function can be computed. This property is used to determine the optimal weights of the NN."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Steepest descent is used to update the synaptic weights of a network based on a cost function expressed by the errors of the output. The weights are adjusted in the direction opposite to the gradient of the cost function."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The idea of learning a network is to minimize a certain costfunction. We can use steepest descent to minimize this cost function. While there are other optimization techniques which can be used for optimization, steepest decent is a widly used optimization technique. To optimize a network we calulate the partial derivatives(gradient) and use it to update our weights. It is also used in BP."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The approach of the method of steepest descent is to find the direction for the minimization of the error in an approximation problem. The cost function e, dependent of the weights w, will be derivated (partial derivative) for all defined weights. This gradient will be used for updating the weights for the next iteration. The direction of the minimization of the error is the oposite direction of the gradien: - g."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The steepest descent can be used to optimize the weights of a network. In steepest descent the error function is a function of the weights. So we determine the direction of the steepest descent on the error surface and go into that direction to minimize the error of the weights on optimize them. "
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Steepest descent is a method of weight adaptation. It is using first order derivative to approximate the function. Therefore is rather slow."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "When learning weights with a SD method, we try to reduce the error based on following the gradient of an error function in the opposite direction, effectively trailing the error surface towards the minimum. Here, the error function (typically some form of mean squared error) is differentiated w.r.t. the individual weights, expressing how much a weight contributes to the network error and must thus be corrected. Due to the gradient pointing in the direction of steepest ascent, we must thus step in the negative direction."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "- Steepeset descent is used for error minimization when updating weights.\n", 
      "- According to this, we update the weights along a direction which minimizes the error; which is calculated by finiding the slope at the point."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Steepest descent is method of optimizing the algorithm by minimizing the error. Weights are adjusted in the direction of steeping descent, opposite to the direction of the gradient."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE Steepest descent moves the error within error surface a small step into the opposite direction of gradient. By help of steepest descent we want to minimize error. Steepest descent stops when gradient = 0."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "In steepest descent, the gradient of the cost function is found by partially differentiating it with respect to the weights. The weights are then updated in the opposite direction if the gradient. This ensures that the weight moves in the steepest direction are reduced. It can also be proven that the weights always reduce. Hence, steepest descent can be used to minimize the cost function."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Speepest decent is used to minimize the training error of a network given sample inputs and desired outputs. It uses the gradient of the error function to move the weights closer to an optimal weight with lowest output error. Using a learning rate we can influence the speed and stability of this algorithm."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The steepest decent is the direction the error function falls the most. We want to change the weights in the direction of the steepest decent (the opposide direction of the gradient) to have a smaller error in the next iteration and to optimize the ANN."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "In error correction learning the weights of a network are learned in a way that e(x) is minimized, where e(x) is some error function. In order to minimize the error function the method of steepest desend is used. The negative gradient of e(x) points in the direction of steepest decend. Doing steepest descend in a single layer feed forward network leads to the delta rule."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "the error function is computet. to adapt the weights (learn the network) the error function is followed in small steps in direction of steepest descent to decrease the error. using iterations the error is decreased in each step and end in a (local) minimum\n", 
      "used in back-propagation"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Steepest descent is the basic learning algorithm others are derived from. The goal when learning a network is to minimize the error. This is achieved by starting at a random position and going in the opposite direction of the gradient vector, the steepest descent."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Steepest descent adjust the parameters (weights and bias) of the NN to minimize the error. It does so by adjustinmg the weights in the direction of steepest descent of the error function. "
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "The method of steepest descent moves in the direction opposite to the gradient to minimize the cost funcion ."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Steepest descent involves weight updation in the direction of maximum steep or maximum derease in the cost function ot in the direction opposite to the gradient funcion. The weight update is $\\Delta w(n) = - \\eta g(n)$ where $\\eta$ is the learning rate which defines the magnitude of learning using the gradient g(n) which is the gradient of the cost function of errorsin the nth iteration. Higher $\\eta$ will result in rapid learning but with oscilations in responses."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "When the inputs are being send into a network and we calculate the error we need a mechanism to learn and manipopulate the free parameters of the network and the learning uses the error but we must know in which direction in the search(optimization) space we should move so that we can reach the global minima of the error for this we use steepest decent. This method tells us in which direction we need to move by getting the gradient from the error."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "When learning a network the steepest descent algorithm updates the weights in such a way that the error decreases in every iteration."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "The method of steepest descent is used to find the direction in which the error function viewed as a function of weights is decreasing most rapidly and then take a small step in that direction. When learning a network, steepest descent enables to iteratively adjust the weight vectors until the optimal weight vector that minimises the cost function (i.e, the error function where error is computed as the difference between the desired and actual response of the network) is found."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The method of steepest descent is used to minimize the error function. The error function is the gradient of the error $\\Delta e = d - y$, where d is the desired output and y is the actual output of the neuron."
     ], 
     "points": 2
    }
   ]
  }, 
  {
   "qid": 8, 
   "question": "Define: a hypothesis $h \\in H$ shatters a dataset $A \\subseteq X \\Leftrightarrow \\ldots$", 
   "answers": [
    {
     "answer": [
      "YOUR ANSWER HERE: a hypothesis $h \\in H$ shatters a dataset $A \\subseteq X \\Leftrightarrow \\ldots$ if the hypothesis can clearly distinguish the positive examples from the negative examples in A."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "and there exist a linear saperater which saperates positve examples from the negavtive examples correctly. then we say that A can be shatter at h."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Ginven a data set A if it is possible to find a hypotheis H which separates the data set into binary form without any error, we can say that hypothesis $h \\in H$ shatters dataaet $A \\subseteq X \\Leftrightarrow \\ldots$."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE\n", 
      "\n", 
      "It means that for all the points in A with input output pair (x,y), for any combination of ($x_i$,$y_i$) there exist parameter $\\alpha$ of h that enables h to classify the points with zero error"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "We say that a hypothesis h shatters a dataset A, iff the h produces a zero training error for certain data set A. In other words, we say that a hypothesis h shatters a dataset A, when h separates data A in two classes without erorr."
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "H is the vc dimension of a learning maching that can shatter h points. \n", 
      "\n", 
      "Vc dimension of a learning machine is the maximum number of points that can be arranged so that the learning machine can shatter them\n", 
      "\n", 
      "Shattering:\n", 
      "\n", 
      "The learning machine is said to shatter points $(x_1 ... x_r)$ if and only if all the possible training set of $((x_1,y_1) ... (x_r,y_r))$ can be classified with zero training error"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "A hypothesis shatters a dataset if it can correctly classify all combinations of labellings of the points in the dataset."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "A hypothesis space H shatters a dataset, if and only if there is a **possbile $\\alpha$ (weight vector)** on hypothesis space that **seperates all the positvie data from negative data**."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "a hypothesis $h \\in H$ shatters $A \\subseteq X$ if and only if there exists a value of $\\alpha$ for which the training error is zero"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Given a dataset $A \\subseteq X $ where X is the instent data space, for a given problem with the dataset A, if a learning machine is able to successfully split the positive and the negative data, then we say that A is shattered by the learning machine. "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Suppose X is a training dataset and A is the subset of training dataset then hypothesis h is said to shatter if can correctly classify all the points in A i.e zero training error."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "For all possible binary labeling of dataset A, we can find a hypothesis h that can separate the positive examples from negative examples, the H shatters A."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "A machine F can shatter a set of points $x_1, x_2, x3_,..., x_n$ if and only if for every training set, there is a weight vector $\\alpha$ that produces zero training error."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "A hypothesis $h \\in H$ shatters a dataset $A \\subset X \\Leftrightarrow$ for each assignable configuration of $(x_i, y_i)\\in A$, $h$ perfectly classifies all elements of the set $A$."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "A hypothesis $h \\in H$ shatters a dataset $A \\subseteq X \\Leftrightarrow$ \n", 
      "\n", 
      "at least on possible combination of dataset $A$ can be classified by the hypothesis $h \\in H$ with zero training error."
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "there exists an arrangement of these points in A sucht that for each possible combination of labels to these points  the hypothesis h has zero training error"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "An hypthesis *h* shatters a dataset A, if for a given data set, h is able to distinguish (or separate) the different classes of this data set."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      ", if there exists a configuration of $X$, so that $h$ gets zero training error on any dichotomy of the datapoints."
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "H shatters A when for example in given dataset (X_1,X_2...X_r) output are in a form (X_1, Y_1),(X_2,Y_2)...(X_r,Y_r) there has been found a 0 error."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "... when our learned machine achieves zero training error on every classification problem of the dataset A. Since we got a selection of $n$ points in the dataset A, the number of problems in binary classification is 2 to the power of $n$ (I didnt find the 'Dach' symbol on the english keyboard :) )"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Considereing a dataset $A \\subseteq X$ ,where X is the instance space and A contains N elements. Now there are $2^N$ binary maps or learning problems when we wnat to separate two classes.\n", 
      "\n", 
      "If any of these problems can be separated completely by hypothesis $h \\in H$ then h is said to shatter A.\n", 
      "\n", 
      "i.e., a hypothesis shatters a dataset, if it can completely separate the classes with zero error for all possible combination of labels in the dataset.\n"
     ], 
     "points": 2
    }, 
    {
     "answer": [], 
     "points": 0
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE A a hypothesis $h \\in H$ shatters a dataset $A \\subseteq X \\Leftrightarrow \\ldots$ if there exists a an $\\alpha for every training set with zero training error"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "A dataset $A \\subseteq X $ with N datapoints has $2^N$ binary maps. If for any of these binary maps, a hypothesis $h \\in H$ splits the positive data from the negative data such that there is no training error, then it is said that h shatters the dataset A."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "when every possible combination of input and desired output can be classified using $h$"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "A hypothesis $h \\in H$ shatters a dataset $A \\subseteq X$, then for every point $x_i \\in A$ there is a label $y_i \\in \\{1,-1\\}$ and the $H$ can saperate these two classes using $h$ with no training error."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "h shatters A when and only when for all possibilities of (a_1, y_1), (a_2, y2), ... ,(a_n, y_n), where y is the class lable (1 or -1) there exists some $ alpha  $ for a learning machine f that produces 0 training error."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "when all combinations of position and labeling of the data can be separated in the given classes by the hypothesis"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "for all possible classified subsets of dataset A the hypothesis h can seperate it"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "If there exist atleast one configuration of A for which training error of h is zero. i.e. it successfully classifies all oints in A. "
     ], 
     "points": 0
    }, 
    {
     "answer": [], 
     "points": 0
    }, 
    {
     "answer": [
      "A hypothesis h is model that separates a dataset consisting of {(x_i , y_i)} samples into positive and negative samples. h is said to shatter a given subset of a dataset if it can successfully separate at least one configuration of the subset of dataset."
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "\"h\" shatters A if for any set of input data points in A there exist at least one training error of zero."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "for each of the $2^N$ (where N is the size of A) combinations of input output mappings of the form $(X_i, y_i)$, h is able to classify the data correctly that is with zero error. "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "A hypothesis $h \\in H$ shatters a dataset $A \\subseteq X $ if there exists an $\\alpha$ for which there is zero training error"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "there exist w weights, which produce a perfect classification."
     ], 
     "points": 0
    }
   ]
  }, 
  {
   "qid": 9, 
   "question": "Write down and explain the Widrow-Hoff learning rule!", 
   "answers": [
    {
     "answer": [
      "YOUR ANSWER HERE: Widrow- Hoff rule:\n", 
      "- $\\Delta w$ = $\\eta e(n) x(n)$\n", 
      "- Widrow-Hoff rule states that when an input x(n) produces an error e(n), then the change in the weight is directly proportional to the error signal and the input signal."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "This the basicly the calulating mean squared  error (MSE) from the expected output and real output.\n", 
      "\n", 
      "Modifiying the weights for Minimizing MSE it . "
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "Widrow-Hoff rule states that the weight adjustment is proportional to the product of input and the error in the output. It is also called the delta rule.\n", 
      "$$\\Delta w_{ji}  = \\eta x_ie_{ji}$$\n", 
      "$\\eta$ is the proportional constant also called as learning constant\n", 
      "$$W(i)=W(i-1)+\\Delta W_{ji}$$"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE\n", 
      "\n", 
      "$\\Delta W_{ji}$ = $\\eta e_jx_i$\n", 
      "\n", 
      "Adjustment made to the weight of a neuron is proportional to the product of the error in that neuron and input applied to the neuron."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Widrow-Hoff learning rule is derived from LMS error method, and it is defined as: $W{t+1} = W{t} + \\mu \\cdot \\Delta W$, where $\\mu$ represent learning rate, and  $\\Delta W = -(gradient \\ of \\ instantaneus \\ erorr) = -(d - y)X $, Here $d$ represent desired signal, while $y$ represent output signal of a neuron. $X$ represent input of a neuron"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "delta $ w_{kj} =  \\eta e_k . x_j $\n", 
      "\n", 
      "Widrow hoff rules states that the change in synaptic weight is proportional to the product of the error signal and the input signal "
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "$\\Delta w(n) = \\mu * x(n) * e(n)$\n", 
      "\n", 
      "$\\mu = $ learning rate\n", 
      "\n", 
      "$x(n) = $ input at timestep n\n", 
      "\n", 
      "$e(n) = d(n) - y(n)$\n", 
      "\n", 
      "$d(n) = $ desired signal at timestep n\n", 
      "\n", 
      "$y(n) = $ output of the network at timestep n\n", 
      "\n", 
      "The Widroff-Hoff (or delta rule) changes the weights depending on the input and the error, which is the difference between the output of the network and the desired output. This weight change can be scaled by a learning rate."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "$$\\bigtriangleup \\omega_{ji} = e_j * x_i$$\n", 
      "$$\\omega(n+1) = \\omega(n) + \\eta \\bigtriangleup \\omega_{ji}$$\n", 
      "\n", 
      "Widrow Hoff learning rule says that, the synaptic weight update is directly proportional to the product of error and the input."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Widrow-Hoff learning rule: The rules states that the weight update is directly proportional to the product of the input to the neuron and the error.\n", 
      "\n", 
      "$\\Delta w_{ij} = \\eta e(n) \\sum x_i(n)$"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Widrow hoff's learning rule states that the adjustment of the weight of a synapses are propotional to the product of the error function and the input which is given by the synapses based on the problem. \n"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Widrow Hoff rule is based minimising the mean square error using gradient descent alogirthm. Weights are adjusted in following manner:<br> \n", 
      "w(n+1) = w(n) - n (gradient of mean square error) <br>\n", 
      "It takes the gradient of the mean square error $0.5 e^{2}(n) = e(n) \\frac{\\partial e(n)}{\\partial w} = e(n) x(n)$"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "it is based on minimization of error cost function $\\xi(w) = 0.5 e^2_k(n)$, so synaptic weight from neuron k to input j is updated in a direction opposite to gradient vector of $\\xi(w)$, that is $w_{kj}(n+1) = w_{kj}(n) - \\eta \\nabla \\xi(w) = w_{kj}(n) - \\eta e_k(n) x_j(n)$, $\\eta $ is learning rate.$e_k(n)$ is neuron k error signal, $x_j(n)$ is input data."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The Widrow-Holf or delta rule is a gradient descent learning rule used to adapt weight in a perceptron. \n", 
      "\n", 
      "$\\Delta w(n) = - \\eta(d(n) - y(n))x(n) $\n", 
      "\n", 
      "$\\Delta w(n) = - \\eta e(n)x(n) $"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "The widrow-Hoff (delta) learning rule is given by\n", 
      "$$ w(n+1) = w(n) - \\eta x(n) e(n)$$\n", 
      "where $e(n)$ is the error vector, $\\eta$ is learning parameter, $x(n)$ is input vector."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "The Widrow-Hoff Learning rule is also referred to as Delta, or Least Mean Square (LMS) Rule. It is used to minimize the cost function and is defined as follows:\n", 
      "\n", 
      "Delta w_ji(n) = eta (partial x_i(n) / (partial w_ji(n))\n", 
      "\n", 
      "where eta is the learning rate paramter, x_i(n) is the total instantaneous error energy and w are the weights."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "The Widrow-Hoff learning rule, also called delta rule, is used for learning a network by adjusting the synaptic weights of the network with the error signals:\n", 
      "\n", 
      "$$ w(n+1) = w(n) + \\eta (d(n) - y(n)) x(n) $$\n", 
      "\n", 
      "where $n$ is the number of iteration, $\\eta$ is the learning rate, $d(n)$ is the desired output signal, $y(n)$ is the actual output signal, and $x(n)$ is the input signal. $(d(n) - y(n))$ is the error signal."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "$$ \\Delta w(n) = \\eta * e(n)*w(n) $$\n", 
      "$$ e(n) = (y-d) $$\n", 
      "The widrow hoff learning rule is error correction learning. It is used to train a network in a supervised manner. The widrow hoff learning rule can be derived from gradient decent. The rule consists of the error e(n) the neuron has and is muliplied with the weight so that the impact of the weight to the error is incorporated into the update.  A learning rule is use as a adjustment in how much we trust the weight change. The error is calculate by the difference between the current and expected output."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The Widrow-Hoff learning rule is defined as: $w(n + 1) = w(n) + \\eta * x(n) * e(n)$\n", 
      "\n", 
      "The Widrow-Hoff learning rule is a rule for adjusting the weights of a NN for a error correction learning task. This learning rule is derived from the steepest descent method, where the direction for the minimization of the error is the defined as the oposite direction of the cost function's gradient. This gradient can be simplified as $x(n) * e(n)$, where e(n) is defined as the difference between the desired response and the actual response of the learning machine (NN): $e(n) = d(n) - y(n)$.\n", 
      "\n", 
      "$\\eta$ defines the learning rate used."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The Widrow-Hoff rule is used in error-correction learning and uses the current error and output of the system to determine the new weights.\n", 
      "\n", 
      "$w(n+1) = w(n)+\\eta \\cdot e(n) \\cdot y(n) $"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Windrow-Hoff rule is \n", 
      "$$W_{new}=x_{input}*W_{old}*(d_{output}-y_{output})*eta*a $$\n", 
      "\n", 
      "where \n", 
      "$W_{new}=new weight,W_{old}=old weight,d_{output}=desired output,y_{output}=actual output,x_{input}=input, eta=learning rate, a=learning constant$"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "For neurons with a linear activation function (ADALINE): $w(t+1)=w(t)+\\alpha (d-y)x$, where x is the input pattern, d is the true value and y is the net output. Notice that the delta rule looks similiar to the perceptron learning rule, but was derived from SD, whereas the perceptron works with a step function which is not fully differentiable."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Widrow-Hoff learning rule is also known as error correction rule is used to update the weights as:\n", 
      "$\\Delta w = \\eta (d_i-y_i)x_i$ where, d is the desired output and y is the output the network generates and x is the input."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Weights adjusted are proportional to the product of error signal and the input vector\n", 
      "\n", 
      "w(n + 1) = w(n) + $\\eta(d-y)x(n)$\n", 
      "\n", 
      "$\\eta$ is learning rate, d is desired output, y is current output. x(n) in input vector. "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE Adaption of weight is proportional to product of input and error:\n", 
      "$w_{new} = w_{old} + x*e$"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "$ \\Delta w = \\eta e(n)x(n) $, where $\\eta$ is the learning rate.\n", 
      "\n", 
      "Widrow-Hoff rule states that the change in weights is proportional to the product of the error and the input in the corresponding synapse."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "$w(n+1) = w(n) + \\mu (d(n) - y(n))x(n)$\n", 
      "\n", 
      "The change of the weights is determined using the error ($d(n) - y(n)$) and the input that was given to the network. The learning rate can improve learing speed. The new weights are dependent on the old ones and the change calculated"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "$w_{ij}(n)= w_{ij}(n-1)+ learningrate*(d_j-y_j)*x_i$\n", 
      "\n", 
      "we change the weights by computing the error $e_j= (d_j-y_j)$ for the input and multiply it by the learningrate and the $x_i$ and adding it to the old weight. This minimises the squared error function (our cost function) and is the online variant of the steepest decent method. "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Rule: w+1 = w + n * x * ( y - d)  where n is the learning rate, x is the input, y is the ouput of the network d is the desired output  \n", 
      "The widrow-Hoff rule minimizes the error (y-d). The weight change is proportional the ibnput x and the error. It can be derived from steepest descend."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "w_new = w_old + learning_parameter * error(n) * input(n)\n", 
      "\n", 
      "while error is: desired_input - current_output\n", 
      "\n", 
      "the new value for the synaptic weight is computed of the old value plus a learning rate times the current error and the input. The output error is decreased in each step until the change is to small or the generalization is sufficient "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "weights(t) = weights(t-1) * learning_rate * (desired(t) - output(t))\n", 
      "\n", 
      "The Widrow-Hoff rule, also the delta rule, is used to update the weights of neural networks in a learning algorithm. It uses the previous weights' result and compares it to the desired result. This discrepancy is then applied to update the weights based on a learning rate."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "Widrow -Hoff learning rule states that the adaptation made to the synaptic weights is proportional to the product of input and the error function.It basically states that if the error is high then the product of input and error will also be high , and thus the adjustment made to the weight would be more.\n", 
      "$w_j(n+1) = w_j(n) + eta*(error)*input$"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Widrow Hoff learning rule is also called as error corresction learning rule. The error is defined as the difference between the desired and the actua output of the learning machine. Assuming the desired signa is available, the error is computed and weights of the neural network are upadted in the direction of reduction of errors. The error for each input sample for a neuron k is computed using $e_k(i) = d_k(i) - y_k(i)$. weight change $\\Delta W = W*e$, that is the dot product of error and the weights is computed."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "The Widrow-Hoff learning rule is given by\n", 
      "$$w(n + 1) = w(n) + \\eta e(n) x(n)$$  \n", 
      "where \n", 
      "$w(n)$: Weight in iteration n  \n", 
      "$e(n) = d(n) - y(n)$: Error  \n", 
      "$d(n)$: Desired output  \n", 
      "$y(n)$: Actual output  \n", 
      "$x(n$: Input    \n", 
      "$\\eta$: Learning rate"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Given a neuron k excited by an input signal $x_i$, if $w_{ki}$ is the synaptic weight of the neuron, then the Widrow-Hoff learning rule gives the weight adjustment $\\Delta w_{ki}$ applied to the neuron k in mathematical terms  as follows: $\\Delta w_{ki} = \\eta x_i(n)e(n)$ where e(n) is the instantaneous value of the error signal. Thus the  Widrow-Hoff rule states that the synaptic adjustment applied to the weights of a neuron is proportional to the product of the input signal to the neuro and the instantaneous value of the error signal. This rule assumes that the neuron has an external supply of desired response so that the error can be computed. "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "$\\Delta w(n) = learning\\_rate \\cdot x(n) \\cdot e(n)$, where x is the input data, $e = d - y$ is the error from the desired output and the actual output, and the learning_rate is a parameter chosen as necessery to change the speed of learning.\n", 
      "\n", 
      "$w_{new} = w_{old} + learning\\_rate \\cdot x \\cdot e$, this is the formula to update the weights and to learn the input data."
     ], 
     "points": 2
    }
   ]
  }, 
  {
   "qid": 10, 
   "question": "Explain back propagation, use the correct technical terms!", 
   "answers": [
    {
     "answer": [
      "YOUR ANSWER HERE: Backpropagation is used for Multilayer perceptron network. It consists of two passes.\n", 
      "- Forward pass: The outputs are calculated at every computational node and passed till the output node where the error is calculated by difference of desired output and the actual output. In this pass, the weights of the synaptic links are not changed.\n", 
      "- Backward pass: The error generated at the output neuron is passed in the backward direction i.e., against the direction of the synapses and the local gradient of the error is calculated at every neuron."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "the back propagation algorithm  it consist of forward pass and backward pass\n", 
      "\n", 
      "computes the output of the neuron \n", 
      "\n", 
      "then it propagates in backward direction while recursively compute local gradient of the neuron \n", 
      "\n", 
      "weights are adjusted accordingle."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Back Propagation is the process of learning in Multi Layer Perceptron in which the error from, the output of the network is fed back into the network to adjust the weights in the hidden layer. That is the error back prpagates into the network to enable the network to learn by adjusting the synaptic weights based on it."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE\n", 
      "\n", 
      "* Back propagation is a process to make adjustment to the weights of a neural network in a way that minimizes the average squared error of the training data.\n", 
      "\n", 
      "* It uses steepest decent method. In each step it moves towards the direction that gives maximum decrease of the error.\n", 
      "\n", 
      "* In back propagation the error is propaged backward from the last layer towards the earlier layers. The adjustments made to the weights is proportional to the partial derivative of the error with respect to the weight.\n", 
      "\n", 
      "* The partial derivative is calculated using repeated application of the chain rule."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "The idea of back propagation method is to propagate error from ouput (final) layer backward to hidden layers, and adjust the weighs of neurond in hidden layer, based of this error. This is required because we do not have error information for hidden layers, only for output neurons. The error from output layer is propagated to hidden layers using idea from steepest descent method. Namely, local gradients are computed for each neuron in backpropagation, and these local gradients define how error changes, in terms of weights. Local gradients are derived from chain rule for each layer. The fact that local gradient for each hidden layer is derived based on local gradient of a previos layer, defines that as we propagate more and more in hidden layers of NN, the gradient of a error function vanishes, which means that as we go deeply back in NN, the change in weights is becominng smaller and smaller. This is a drawback of back propagation method. "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The back propagation is a learning method in neural networks. Back propagation enables the feed forward netwowrk to represent XOR gate.\n", 
      "\n", 
      "It has two phases:\n", 
      "\n", 
      "forward pass: the initial weights are used to calculate the value of the output neuron\n", 
      "\n", 
      "backward pass: starts from the output layer and travels backward. During this phase the weights are changed based on the local gradients of each neuron|"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Back propagation is used to learn weights in a multi-layer feed forward network. It is divided into two steps: forward and backward. In the forward step one input is passed through the network to calculate the output of the network. This output is used to calculate the error of each output neuron given the desired output. After this forward step, in the backward step the weights are changed beginning in the end of the network. Each weight is changed by taking the derivative of the activation function of the neuron times either the error, if the following neuron is an output neuron, or all local gradients of connected neurons times the corresponding weights. The weight changes are the local fields."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "* Backpropagation is a steepest decent method that calcualtes the error at the output neurons and backpropagates those errors backwards to update the weights of each neuron.\n", 
      "* The synaptic weight updated is directly proportional to **partial derivatives**\n", 
      "* Local gradient is calculated at ouput neurons and hidden neurons.\n", 
      "* Local gradient at output neurons are calculated using the observed error.\n", 
      "* But the error function is missing in the hidden neurons, so the local gradient of hidden neuron j is calculated recursively from the local gradients of all neurons which are connected directly to the hidden neuron j. "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Backpropogation has 2 steps. \n", 
      "\n", 
      "Forward pass: In forward pass the data is run through the network and the error is calculated.\n", 
      "\n", 
      "Backward pass: In Backward pass the weight is adjusted using local gradient of error such that the error is minimized.\n", 
      "\n", 
      "There are many ways for weight adjustment like, steepest descent, Newtons method, Gauss newton method."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Back propogation usually occurs in a multi layer perceptron. \n", 
      "\n", 
      "It uses a non linear activation function. \n", 
      "\n", 
      "Basic elements: \n", 
      "1. Functional signals: These are the input signals, which passes through the network from left to right. As the name denotes it performs a usefull function at the output of the neuron and another reason for the name is that the functional signals are calculated based on the parameters and the activation function. \n", 
      "\n", 
      "2. Error signals: Error signals propogate usually in the reverse direction which contains the error based on the desired output. \n", 
      "\n", 
      "It consists of 2 phases: \n", 
      "1. Forward phase: In the forward phase the signals propogate from left to right. Weights are fixed and passes through all the layers of the network, that is undergo all the activation. \n", 
      "\n", 
      "2. Reverse phase: In the reverse phase, the local gradients are calcualted and are propogated through in the backward direction. Here weights change."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Backpropogation is used for training multi layer networks. It constitutes of forward pass and backward pass. In forward pass network computes the output. Based on this the errors are calculated based on difference between network output and desired output. These errors are the backpropogated to network during backward pass and used for adjusting the synaptic weights. "
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "It contains forward pass and backward pass. In the forward pass, input is applied to the network and propagate it forward through the network, then compute the output of neurons in output layer and errors for output neurons. In the backward pass, compute local gradients and update the synaptic weights according to error correction rule for each neuron layer by layer in a backward direction."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Backpropagation is a learning algorithm in multi layer networks that consists of two phases, a forward pass and a backward pass. In the forward pass, the output is calculated by passing activations layer through layer starting from the input, then through hidden layer and finally output. Then the error is calculated in the output layer and propagated backward through the network. In the forward pass, the weight do not change. In the backward pass, the weights change in proportion to the local gradient."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Backpropagation is a neural network based learning algorithm where the network learns by propagating the error through the network. BP consists of two stages:\n", 
      "+ Forward pass: where the error is computed by feeding the input to the network.\n", 
      "+ Backward pass: where error is propagated through the network for doing the weight updates locally.\n", 
      "Since BP has vanishing gradient problem, it is useful to use activation functions which are infinitely differentiable such as sigmoid function."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "The back propagation algorithm is used to calculate the error contribution of each neuron after a batch of data is processed. Required is a known desired output of each input value. Thus the back propagation algorithm is a supervised method. The algorithm can be subdivided into two phases:\n", 
      "\n", 
      "1) Propagation:\n", 
      "* Propagation forward through the network to generate the output value(s).\n", 
      "* Calculation of the cost error term.\n", 
      "* Propagation of the output activation back through the network usin the training pattern target in order to generate the deltas (differences between desired and actual output) of all output and hidden neurons / by recursevliy computing the local gradient of each neuron.\n", 
      "\n", 
      "2) Weight update:\n", 
      "\n", 
      "For each weight the following steps need to be applied:\n", 
      "* The weight's output delta and input activation are multiplied to find the gradient of the weight.\n", 
      "* A ratio (percentage) of the weight's gradient is substracted from the weight. This ration is also referred to as the learning rate and influences the speed and quality of the learning.\n", 
      "\n", 
      "Learning is repeated for every new batch until the network performs adequately."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Backpropagation is an algorithm for training a neural network, and it contains of two main stages. The first stage is to compute the actual output given the input; in this stage, the signal flows forward from the input layer to the output layer, and the synaptic weights are fixed. The second stage is to update the synaptic weights by propagating the error signals backward from the output layer in a layer-by-layer manner; for each neuron, the local gradient, the partial derivative of cost function to the local field, is computed. "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Backpropagation is a learning algorithm for Multilayer FF NN. It is supervised error correction learning. \n", 
      "The weights are initialised randomly\n", 
      "\n", 
      "The algorithm has to steps:\n", 
      "\n", 
      "In the forward pass the the output is calculated by using the current weights.\n", 
      "\n", 
      "In the backward pass the weight update for the outputlayer is as like in single layer ff. The error is used to update the weights. BP allows us to also calculate the error of hidden layers. For each hidden layer we use a local gradient as the error. The local gradient is the sum of weighted error of the following layer, which is passed trough the derivate of the activation function. So it is possible to backpropagate the error from the output layer to to first layer.\n", 
      "\n", 
      "A common Problem in BP is the vainshing gradient problem. Depending on the activation function used the local gradient gets smaller in each layer until it is eventually less than the floating point precision used. This limits the number of layers that can be stacked."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The back propagation algorithm is a learning algorithm for updating in the weights in a multi-layer neural network. For updating the weights of all the layers, the error of each neuron must be calculated. In the back propagation algorithm, two phases will be defined:\n", 
      "- Forward phase: the output of the neural network will be calculated and also the error of the neurons in the output layer.\n", 
      "- Backward phase: the gradient of each neuron will be calculated, by using the calculated error on the output layer and the defined connections between the hidden layer and the output layer. If multiple hidden layers are defined, the error will be iteratevely will be given backwards and the weights at each neuron will be updated."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Backpropagation is used in Multilayer Perceptrons to give a method of adapting the weights. First the forward phase is run like in a regular feedforward network. Then after the output and thus the error is determined the error is backpropagated from ouput layer through the network. Since we have multiple layers, there is only a desired output of the network for the last layer. To counteract this problem a gradient is calculated for every neuron during the backward pass. The gradient is giving a measure of the contribution of this neuron to the final error. The gradient is then used to update the neurons weights. If the neuron is not part of the output layer, the previous gradients are used to calculate the new gradient instead of using the error."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Back propagation consists of two steps:\n", 
      "1. forward pass - data is passed through the network and weights are atapted\n", 
      "2. backward pass - by using local field of each neuron error signal is propagated backward by using local field of each neuron from end to beginning and stacking them up. Local field is partial derivative of the output signal of a a neuron, for output neuron it is simplest to calculate as it has only desired output and actual output to deal with."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Backpropagation is the general form of the delta rule, formulated for networks with multiple hidden layers. Here, we propagate the error of the network back to the input layer to determine the change of weights, using the error signal in the output layer and subsequently the local gradients in the hidden layers. In the forward pass, we compute the net output forwards. In the backward pass, we propagate the error backwards. The BP rule was derived from the error gradient w.r.t. the weights, and application of the chain rule."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Back propagation is propagation of error from the output layer to the hidden layer in network with multiple layers. \n", 
      "\n", 
      "This is done by calculating the local gradient of each node and then using this (along with the weight) to determine how much of the error is to be propagated to the particular node"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "In back propagation, there are two phases:\n", 
      "\n", 
      "1. Forward Phase: First we apply input to the network and compute the current output. \n", 
      "2. Backward Phase: We compute the error between current and desired output. Error is minimized by computing gradient of error with respect to weight. In return, weights are adjust.\n", 
      "\n", 
      "After adjusting weights in backward phase, we again go to forward phase and compute the current output, check whether error is minimized or not. "
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE Back propagation wants to minimize the error function E. E is given by: \\( $ \\frac{1}{2}\\sum e(n)^{2}$  \\). THe error function can be minimized by calculating the gradient starting from the output. Term for calculating the gradient differs. It depends on whether the neuron for which the gradient to be calculated is an output neuron or  a hidden neuron."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "In backpropagation, the gradient of the error produced at the output layer (by partially differentiating the cost function with respect to the weights) is propogated backwards one layer at a time back to the input layer. This propagated gradient is used to update the weights in the corresponding layer. Backpropagation is necessary because the desired output at every layer is not known and it is only possible to formulate the cost function at the output layer."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Back propagation is used in multi layer network. It consits of two phases: Forward and backward.\n", 
      "In the forward phase we give and input to the network and caculate its outputs. Also memorize the local field of each node. The local gradient (delta) is used to adapt the weights of the layers. It is different for output and the remaining layers. \n", 
      "\n", 
      "For node i in an output layer: $\\delta_i(v_i) = \\varphi^\\prime(v_i)(d_i - y_i)$\n", 
      "\n", 
      "For node i in other layers: $\\delta_i(v_i) = \\varphi^\\prime(v_i)\\sum_{j\\in C} w_ji \\delta_j(v_j)$, where $C$ are all the nodes that use node i output as an input\n", 
      "\n", 
      "repeat this process for all input data until error is small enough"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The back propagation algorithim is there to train a mulilayer feedforward ANN. We change the weights by computing the local gradiant at each neuron by using the neurons in the layer befor. The local gradient of the output neurons can be computed easaly. The activation function has to be differantable for the backpropagation algorithm.\n", 
      "\n", 
      "In the forwart pass we compute the output y at the output layer.\n", 
      "\n", 
      "In the backard pass we use the output y and our desired output d to compute the local gradients at the output layer. Then we go back layer by layer and use the local gradients from before to compute the new local gradients.\n", 
      "\n", 
      "By that we minimize the average squared error function."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "In multi layer ff networks the error is only available in the last layer. Therefore the error is propagated back through the network using the backpropagtion algorithm. In order to do so the local gradient has to be calculated. \n", 
      "Update of the weight: w+1 = w + n * x * gradient where the iput x is the output of the previous layer.\n", 
      "The local gradient is calculated diffrently depending if the neuron is in the output layer or in the hidden layer.  \n", 
      "Output layer: $ gradient = phi`(x) * (y -d) $  \n", 
      "Hidden Layer: $ gradient = phi_j`(x) * SUM(w_i * local gradient_i) $    "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "back propagation is used in multilayer feedforward networks. first the forward pass is computed. The given error at the output nodes is used to compute the weight changes using widrow-hoff learning rule. then the error is given back layer by layer in the backward pass to compute the error and weight changing for each layer recursivly. The learning can be done in sequential (online) or batch mode (offline) "
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Back propagation is a learning algorithm for multilayer neural networks. At first, the input is propagated through the network until the end is reached. Here the error is calculated with the desired result. Then the error is used to update the weights from the back to the front. For the output layer the weights can be updated directly with the calculated error. The following layers have to use the local gradient of the previous error, which is calculated with the derivative of the activation function and its error. This is then used to update the weights and repeated until the front is reached."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "In steepest gradient weights are adjusted in decreasing direction of error function. But for hidden neurons there is no labels available to calculate the error. Hence final ouput error is backpropogated through the layers inside the hidden layers of NN. This is possible with continuous activation function and chain rule on its derivatives. \n", 
      "Final error is differentiated with respect to hidden weights. Chain rule is applied to find local error on hidden neurons. "
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Backpropagation is a neural network which has two stages:\n", 
      "-Forward pass: In forward pass the error is calculated in the output layer with the help of the desired output and the given output. e = d - y\n", 
      "- Backward pass: It begins in the output layer , in this case the error is passed backwards with the calculation of gradients at each layer of the neural network\n", 
      "So in back propagation the adjustment to weights is made based on the local gradients which is calculated at each layer."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Back prop is a way of training a neural network by adapting the weights using error produced. It consists of two phases, forward and backward. Forward phase computes the output along the network using the function signal. In the backward phase, the error of thr outpur fromthe derired output is computed and a local gradient of the error is used to update the weights iof the network. The local gradient considers the credit or blame of the corresponding weights of neuron in producing the output."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Back propagation is a steepest decent method that uses the final produced error and the local gradient to define the amount of change needed for each synaptic weight.\n", 
      "\n", 
      "In this method we have two phase:\n", 
      "    - forward phase: in this phase we feed the input to the network and the network calculate the output\n", 
      "    - backward phase: in this phase we first calculate the error and then use the local gradient to propagate the error to the network from the last layer to the first and manipulate the synaptic weights"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Back propagation is moving the error backwards recursively through the network by calculating the local field of every neuron to update the weights. It is based on the chaining rule of derivatives."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "The back propagation algorithm is based on the error correction learning rule and consists of two passes:\n", 
      "1. Forward pass : The input signal applied to the source nodes of the network is propagated forwards through the different layers of the network, and the output is computed at the output layer of the network.\n", 
      "2. Backward pass : The error signal computed at the output is propagated backwards, with a local gradient computed at each of the hidden layer neurons, in order to adjust the synaptic weightsof the neuron in the network."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Back propagation consists of two steps:\n", 
      "1. step - Forward pass: Here the input data is fed into the network and the output is calculated at the output nodes. The usual calculations of the induced local field are done by using this formula $v = \\sum wx + b$. The output is then calculated using this formula $y = f(v)$, where f() is the activation function.\n", 
      "\n", 
      "2. step - Backward pass: Here the error is backpropagated through the network from the output layer to the input layer. In the output layer the error is calculated using this formula $\\delta = d - y$, using the desired output d and the actual output y. In the layers before the output layer the local gradient is used to calculate the error using the error from the output layer $\\delta = w\\delta x$. Additionally the weights are updated using $w_{new} = w_{old} - learning\\_rate \\cdot \\delta x$"
     ], 
     "points": 2
    }
   ]
  }, 
  {
   "qid": 11, 
   "question": "When learning using steepest descent, explain the role of the learning rate? What is a danger?", 
   "answers": [
    {
     "answer": [
      "YOUR ANSWER HERE:\n", 
      "- When the learning rate is small, the learning is very slow.\n", 
      "- When the learning rate is large, the learning is unstable and can exhibit zigzag behavior.\n", 
      "- When the learning rate is too large, the learning never converges."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "if the learning rate is large then the it follows the zizag motion.\n", 
      "\n", 
      "if the learning rate is too low then it takes time for converging .\n", 
      "\n", 
      "if the learning rate is very large or critcal then it becomes unstable.\n", 
      "\n", 
      "while processing there is possiblity that it will get stuck in local minima."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "When using steepest descent the learning rate($\\eta$) determines the speed at which the weihts are adjusted in the NN. There can be two possible danger related to leraning rate depending on its magnitude:\n", 
      "1. Low learning rate(eg, $\\eta = 0.01$)  results in smooth variation of the weights but makes the process becomes slow.\n", 
      "2. Hight learning rate (eg, $\\eta = 0.01$) results in faster weight adjustment but it leads to an oscillatory nature in the learning which is unwanted."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE\n", 
      "\n", 
      "* With a small learning rate the network will converge very slowly towards the optimal weight of the network but it will give better perfomance in generalization.\n", 
      "\n", 
      "* With a high learning rate there can be zigzag effect. because of the large rate the network may miss a local minima and jump to a higher point.\n", 
      "\n", 
      "* With a very high learning rate the network may become unstable."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The learning rate defines the speed of steepest descent search for min of a error funtion. In other words, it defines how strong the change in weights will be, throughout optimization procedure. Higher learning rate, faster learning, but then learning is characterized by oscilations in searhc for min. This is dangerous because if learning rate, becomes bigger that a certain value, it can make search with steepest descent unstable. IN this case steepest descent will start to diverge, istead of converging to min. \n", 
      "In other case, when learing rate is small that lerning is slower but safer, and the learining path is not oscilatory."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Learning rate is used to decide how fast the network should converge during the training phase\n", 
      "\n", 
      "If the learning rate is too high - the system oscillates and  becomes overdamped\n", 
      "\n", 
      "too low - the system becomes underdamped and learns very slow"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The learning rate tells how long one step in the method of steepest descent is. If the learning rate is too high, the learning will oscillate and may not converge. If the learning rate is too small the convergence will take many iterations."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "* Learning rate tells the network that how much steps it should move towards direction opposite to the gradient vector.\n", 
      "* If the learning rate is too large, the weight updation will be high. \n", 
      "* So the danger is, learning may oscillate or the network overfit the data."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Learning rate is used to regulate the speed of learning. If the learning rate is small then the learning is slow and if the learning rate is high then it oscillates. If it exceeds the critical value then the algorithm is unstable."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The learning rate is $\\eta$ So based on the learning rate, it undergoes various oscillation. \n", 
      "We could see zigzagging behaviours. \n", 
      "1. When the learning rate is large, the system is said to be under damped. \n", 
      "2. When the learning rate is small, the system is said to be over damped. Here we can see a zigzagging behaviour towards the convergence phase. \n", 
      "3. After the learning rate crosses a certain value it becomes unstable. \n", 
      "\n", 
      "It may stuck in a local minima which is considered to be another danger "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Learning rate in steepest descent can directly affect the convergence of the algorithm. If the learning rate is very small then algorithm can take long time to converge i.e response is ovderdamped. But if the learning rate is amde very high then we may observe zig-zagging (oscillatory) behaviour and sometimes algorithm may fail to converge  (underdamped response)."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "learning rate controls the speed and convergence of steepest descent method. 1. if it is small, the trajectory of weight vector follows a smooth path in W plane; 2. if it is large, the trajectory of weight vector follows a zigzaging path; 3. if it exceeds a critical value, then the algorithm is unstable."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The learning rate tells us how confident we are of the error, and it affect the convergence rate. A low learning rate will slow the convergence, making the system overdamped. A high learning rate will speed the convergence but the value oscilates, making the system underdamped. The system can become unstable if the learning rate is above a threshold value."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "+ If the learning rate is too small, then the system is overdamped and the algorithm takes a long time to converge.\n", 
      "+ If the learning rate is too large, then the system is underdamped and the algorithm oscillates around and optimal solution or could potentially make the system unstable."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The steepest descent method is an algorithm for finding the nearest local minimum of a function which presupposes that the gradient of the function can be computed. The method of steepest descent starts at a point P_0 and as many times needed moves from P_i to P_(i+1) by minimizing along the line extending from P_i in the direction of gradient f(P_i) the local downhill gradient. The danger of the algorithm is, that it can get stuck in a local minima."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The learning rate determines the rate of learning: the smaller the learing rate is, the slower the learning process is, but the path of weight adjustment is smoother. The larger the value is, the faster the learing process is, but it can result in oscillation and instability. "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The learning reate is a factor of how much we trust the datapoint. Normally it is in the range of [0,1]. A high learning rate normally results in a faster convergence while a lower rate in a slower conversion. If the rate is choosen to high, it is possible that the cost function diverges. If the rate is to slow it is possible that the rate so conversion is so slow that we never reach a local minimum."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The learning rate is a parameter using on updating the weights in a given iteration. This parameter represents the importance that is given to the adaptation of the weights. So when setting the learning rate small, the learning machine will learn slower but also in a more stable way. On the other hand, when setting the learning rate with a large value, the learning machine will learn faster but in an unstable way. The danger here, is that depending on the learning rate's value, the algorithm may never come into the perfect value. If the learning rate is too small, it may land into a local minimum and never approach the global minimum of the function. If the learning rate is too big, the learning progression will have a zig-zagging behaviour and never approach the ideal value."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "If we use steepest descent we use the learning rate to adjust the speed of the convergence to a minimum error. If the learning rate is too small, the learning is going on rather slow. If the rate is high, the error is zigzagging on the error surface towards the minimum. If the learning rate is to high, it might not converge but diverge."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "If learning rate is to large, then proccess will oscillate a lot and might not converge.\n", 
      "\n", 
      "If learning rate is to small, then convergance will happen very slowly"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "When training with SD, the learning rate determines the step size we take towards the negative gradient. When the learning rate is too small, the weights may be overdamped and reach the error function minimum slowly, eventually getting stuck in local minima. When step size is too big, the weights may be underdampened, bouncing between ridges of the error surface and never find the minimum (especially when the minimum is in a steep ravine of the error surface)"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "- Learning rate is used to control how much the wright update is affected by the error correction or so on.\n", 
      "- Learning rate too low: Learning is slow and takes more time\n", 
      "- Learning rate too high: Learning is fast, but causes zigzagging behaviour in convergence.\n", 
      "- If the learning rate is too high, it may result in situations where the zigzagging behaviour will cause it to overshoot, and may never finally converge."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "If learning rate is very smaller, then transition are over-damping, trajectory of weight vector follows the smooth path.\n", 
      "\n", 
      "If learning rate is large, then transition are under-damping, trajectory of weight vector exhibits the zigzagging(or oscillatory) behavior\n", 
      "\n", 
      "If learning gets higher than some threshold, then learning algorithm gets unstable or diverges"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE Learning rate n determines stride of delta of weight. If learning rate is too large weights starts to ziggerate. "
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Learning rate controls the speed of the descent. When learning rate is low, the weight updation is overdamped and convergence is slow. When the learning rate is high, the weight updation is underdamped and a zigzagging behaviour is exhibited in the weight space. When the learning rate is too large, learning becomes unstable."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The learning rate defines the speed of the weight change. A learning rate too high can lead to oscillation around the optimal weight such that its never reached. A learning rate to low results in very slow learning and slow convergence."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "The learning rate is needet to make the algorithm more stable. \n", 
      "\n", 
      "A high learning rate makes the weightchanges zickzacking and the algorithm might not converge\n", 
      "\n", 
      "A low learning rate makes the path in the W-plane more smooth.\n", 
      "\n", 
      "If the learning rate gets to a certan critical value the algorithm might not converge at all"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "A too small learing rate can lead to a very slow convergence or to no convergence at all if the time learn becomes too long. A high learning rate can lead to an oscillating behavior and prevent convergence."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The learning rate gives the speed of learning. It defines the stepwidth in direction of steepest descent. If the learning rate is small, the learning is more stable but slower. When it is high, the learning is more unstable but faster. The danger is to overcome a minimum and result in oscillating behaviour "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The learning rate defines the speed of the learning convergence. High values lead to faster learning und low values to slower learning. However, high values can lead to oscillations in the learning space and may overshoot the desired result and never reach it."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Learning rate is a scalar multiplied with adjustment term to adjsut the weights. It ensures the rate of learning. It is typical greater than 0 and less than equal to 1. It govers the rate of sliding alond the curve towards the minima. \n", 
      "\n", 
      "1. Lower learning rate will result in slow learning but chances of finding optimal minima are greater. \n", 
      "\n", 
      "2. Higher learning will result in hopping on either side of minima hence zigzag behaviour.\n", 
      "\n", 
      "3. Very high learning may not converge. "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Learning rate has huge impact on convergence of the network. If the learning rate is low then the transient response of the algorithm is overdamped and the trajectory of w(n) is smooth. If the learning rate is high then the transient response of the algorithm is underdamped and trajectory of the w(n) is zigzag. If we choose the wrong learning rate then  the network might not converge."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The learning rate defines the efficiency of learning machine. If it is small, the system response may be overdamped, if large , the response may be underdamped and if it exceeds a critical value, the response may diverge.\n", 
      "\n", 
      "The danger is the possibility of the system output to not converge. This should be ensured by scaling the learning rate using the largest eigen value of the correation matrix of the input."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "- The learning rate defines the size of steps that the method moves in the search space.\n", 
      "- If the learning rate is too small the method needs to take huge number of steps and maybe it stuck in a local minima\n", 
      "- If the learning rate is too big the method will converge very fast toward the global minima but there is a probability that it oscilates around the global minima and never reachs it\n"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Learning rate $\\eta$ has a profound impact on the learning in steepest descent. \n", 
      "1. If $\\eta$ is too small, the system is underdamped and convergence is slow. \n", 
      "2. For larger $\\eta$, the system is overdamped and tends to oscillate.  \n", 
      "3. If $\\eta$ exceeds a certain critical value, steepest descent may even diverge!"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The value of the learning rate parameter $\\eta$ controls the speed of descent and convergence towards the optimal weight vector. For small values of $\\eta$, the transient response of the algorithm is overdamped and the weight trajectory follows a smooth path. On the other hand if the value of $\\eta$  is large, the transient repsonse of the algorithm is underdamped, and the weight trajectory follows an oscillatory path in the W-plane."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The learning rate is a value between 0 and 1, which determines how fast the network learns. When using small values for the learning rate, the network converges slowly and needs alot of processing. When choosing big values the learning oscillates and becomes unstable. The goal is to choose the learning rate in a way that it does not learn to slow, which needs more input data for convergence, and that it does not become unstable."
     ], 
     "points": 2
    }
   ]
  }, 
  {
   "qid": 12, 
   "question": "How does a Reduced Boltzman Machine work (main idea)?", 
   "answers": [
    {
     "answer": [
      "YOUR ANSWER HERE"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "the main idea of the RBM is compute the Least mean square error of the difference between expected output and real output."
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE\n", 
      "\n", 
      "* It is a Recurrent neural netwokr\n", 
      "* It uses two groups of neurons, hidden and visible\n", 
      "* It process the training data by flipping the neurons"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Reduced Boltzman Machine is a biparted (two parts) Reccurent NN, that has two layers visible and hidden layers. In Reduced Boltzman Machine neurons can have two states, namely, + or - 1, depening on current time step. At each time step, the states of neurons are flipped. Here the visible layer represent interface for connection between evironment and hidden layer, and it operates in clamped mode (limited values by environment). WHile hidden layer, operates in free mode."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "It has the structure of recurrent neural network. \n", 
      "\n", 
      "It has two layers of neuron visible and hidden.\n", 
      "\n", 
      "the neuron can store only binary values\n", 
      "\n", 
      "they work based on flipping\n", 
      "\n", 
      "theere are modes free running and clamped\n", 
      "\n", 
      "the weights are changes based on the correlation of the neurons in the free running mode and clamped mode"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "In a Reduced Boltzman Machine there are one visible and at least one hidden layer. The visible layer is the input and acts as output at the same time. For each input the neurons of the visible layer will be assigned with a value. With their weights, hidden neurons may either be activated or not. Once the input has been passed through the hidden layers, the values are passed all the way back to the visible layer. For this, different weights are used since the values move in the opposite direction. "
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Reduced boltzman machine work based on **flipping operation** and calculating the probability invariances of clamped state and freely running state."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "RBMs run on boltzmann learning rule. The neurons have 2 modes of operation clipped and free running.\n", 
      "\n", 
      "All the neurons are binary units. Their status can be changed by flipping. All the neurons that are in on position are clipped together."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "RBM is an unsupervised learning technique. It has visible neurons and hidden neurons. Neurons are in either +1 or -1 states. It uses the idea of simuilated annealing to flip the neuron states based on energy function and pseudo temperature. It operates in 2 states - clamped state and free flowing state. In clamped state only hidden neurons are flipped and in free flowing state both visible and hidden neurons are flipped. Weights are adjusted based on avergage correlation difference between all the neurons in clamped and free flowing state."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The neurons operate in a binary states, \"on\" or \"off\". In clamped condition, all visible neurons are clamped into specific states by the environment; in free running condition, all neurons including visible and hidden neurons operate freely."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "The Reduced boltzman machine works by flipping neurons. It can operate in clamped or free running state.\n", 
      "- If two connected neurons are activated at the same time, the weight is increased.\n", 
      "- If any of the two neurons are fired asynchronously, then the weight is reduced or removed."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "+ Reduced Boltzman Machines (reduced because inputs do not share information via synapses) are one of the initial NNs which consists of input layer and hidden layer. The system adapts its internal weights and tries to reproduce the inputs."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "A RBM is a shallow two layer network containing a visible and a hidden layer. Each noden in the visible layer is connected to each node of the hidden layer. It is considered as restricted, because no two nodes of one layer share a connection. A RBM is the mathematical equivalent of a two way translator. In the forward pass a RBM takes the inputs and translates them to a set of numbers that encode the inputs. In the backward pass it takes the set of numbers and translates them back to form the reconstructed inputs. A well trained RBM will be able to perform the backward translation with a higher degree of accuracy. \n", 
      "\n", 
      "Three steps are repeated over and over through the training process:\n", 
      "\n", 
      "1) Forward pass.\n", 
      "\n", 
      "2) Backward pass.\n", 
      "\n", 
      "3) Evaluate quality of reconstruction as visible layer (often solved with KL divergece)"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "The structed of RBM is a bitpartied graph. It uses hebbian learning for training and the neurons used are binary stoachastic neurons, which have a binary state, which fire based on a probability. The training is achived by passing the information a many times between the hidden layer and the input layer. There weightsare updated on the pass into the hidden layer. Weigths between input and activations in the hidden layer are increased, weights between gernerated inputs of the rbm and the hidden layer are decreased."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The main idea of an RBM can be defined as follows:\n", 
      "\n", 
      "- Two layers will be defined, where each neuron will be connected to every neuron of the other layer.\n", 
      "- The input will be passed from the first layer to the second one, and the state of each neuron of the second layer will be calculated.\n", 
      "- The neurons with active states will pass again its values to the input layer.\n", 
      "- The values given from the second layer will be compared with the input values, and with the two states, the weights will be adjusted."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "In RBMs there are two states, the free running and the clamped state. During the clamped state, the input neurons are clamped to the output neurons. While the network is clamped the probabilities of the Hidden states to be in a certain state are calculated to determine a probability of the output to be correct."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "They are neural network with only one hidden layer, neurons from input to hidden layer are fully connected, neurons from hidden layer to output layer are fully connected as well. "
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "RBM implement a combination of graphical and probabalistic ideas, using probabilites of activations inspired from energy based networks. We present a training input to the RBM, and determine the hidden activations based on a probability of net input and edge weights. Then, when unclamping the training data from the network, sample from the distribution of the hidden layer, where the RBM tries to rebuild the distribution of the input data. RBM may be used for data completion or denoising, where e.g. incomplete images are complted based on the learned probability distribution."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "RBM has two layers and are interconnected (recurrent) operates by flipping the internal states (+/- 1)> Unlike the boltzmann machine, reduced boltzmann machine does not contain interconnections among the same layer. The weight update is done by the differnce in correleation in clamped and  free running mode."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "It is a recurrent network. It opreates by flipping. \n", 
      "\n", 
      "It has two groups of neurons: Visible neurons and hidden neurons. Visible neurons provides interaction between environment and network. Hidden neurons are running freely. \n", 
      "\n", 
      "It has two modes of operation: \n", 
      "    . Clamped State: states of the neurons are clamped.\n", 
      "    . Free running state: Neurons are running in free condition"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "The reduced blotzman machine works by flipping the states of binary neurons based on a probability determined by the activation produced at the neuron. Neurons are arranged in a visible and a hidden layer in a recurrent fashion. There are two states involved called the clamped state in which the visible neuron is connected to the input and a free running state in which both layers run free."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "It consists of only two layers: input and hidden layer. During training data is presented to the input. The hidden layer starts oscillating."
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "The Reduced Boltzman Machine is an stochastical recurrent ANN, that operates with two classes of neurons : hidden and visible. It operates by neuron-flipping with a probability impacted by the neurons arount. So it uses the hebbian rule. An Reduced Boltzman Machine can learn the classify data and can repoduce the learned patterns."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Neurons have to states e.g. on or off. Each neuron has a probability to flip from one state to another. "
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "the binary state of each neuron is flipped by a given probability. Stochastical learning "
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "Two fully connected layers, one input and one hidden layer are used. The input layer is the only connection to the environment. The RBM has a specified energy level which can not be changed. However the distribution of this energy to the nodes can be changed. Based on the data input every node has a chance to flip based on its input connections."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "Boltzmann machines is a neural network having recurrent structure.It is in two states either on which is +1 or off which is -1.The energy function is given by \n", 
      "\n", 
      "$E = 1/(1+exp(-delta E/Temperature))$\n", 
      "\n", 
      "The state of the input x is turned from +1 to -1 based on the change of the energy delta_E and the pseudo temeperature T."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "RBMs work on the principle of binary states, free-running or clamped. The weight update is done based on the Botlzmann's formula using the pseudotemperature, which gives the proobability of error."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "A Reduced Boltzmann machine (RBM) consists of two layers of neurons: visible and hidden. The neurons may only have two states i.e. activated or not and they flip according to a certain probability based on the weights and states of other neurons. The RBM has two modes:\n", 
      "1. Clamped: The visible layer is clamped to a certain input while the hidden neurons are allowed to change state until the network settles. The correlation in this state is given by $\\rho_{ij}^+$\n", 
      "2. Free-running: In this state, the network is allowed to flip all neurons until it settles. The correlation is $\\rho_{ij}^-$  \n", 
      "The weight update rule is given by \n", 
      "$$\\Delta w_{ij} = \\eta (\\rho_{ij}^+ - \\rho_{ij}^-)$$"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The Reduced Boltzman Machines function by using two types of neurons : visible neurons that provide an interface between the environment and he network, an hidden neurons that operate freely. The learning can proceed under two conditions, namely:\n", 
      "1. Clamped state : where the visible neurons are clamped to a particular state of the environment\n", 
      "2. Free running state : where both visible and hidden neurons operate freely. \n", 
      "\n", 
      "If $\\rho^+_{ij}$ indicates the probability of correlation between the states of neurons i and j in clamped state, $\\rho^{-}_{ij}$ indicates the probability of correlation between the states of neurons i and j in free running state, then the weight adjustment $\\Delta w_{ij} = \\eta (\\rho^+_{ij} - \\rho^{-}_{ij})$"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The Reduced Boltzman Machine hast an input layer and a hidden layer. Each neuron has a state and a probability to turn on. If the neuron turns on the data passes trough it and the weights are updated. The probability of turning on is calculated by the network."
     ], 
     "points": 1
    }
   ]
  }, 
  {
   "qid": 13, 
   "question": "Define: Echo State Network (ESN), how are they different to FF NNs?", 
   "answers": [
    {
     "answer": [
      "YOUR ANSWER HERE:\n", 
      "- Echo state networks are recurrent neural networks that have a large resorvoir of oscillator functions that are connected to the input layer.\n", 
      "- In FF NNs, consideredthe outputs at the hidden layers are also considered but in ESNs, the ouputs from the reservoir to the final output layer are only considered."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "ESN are the RNN recurrent neural network which has at least one feedback cyle. \n", 
      "\n", 
      "FF NN are normally forward moving networks where the input from one layer is fed into next layer and generated the output . \n", 
      "\n", 
      "but IN ESN the out put is again fed back as input . ESN is tend to have Resvoir where its randomly connected."
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "Echo State Network is a type of neural network which has a recurrent network of 100 to 1000 neurons called dynamic reservior, as the hidden layer. The weights are choosen randomly. The synaptic weights from the resorvoir to the output layers are only adjusted during the learning process.  \n", 
      "\n", 
      "They are different from the FF NNs in the following regards:\n", 
      "1. ESN have atleat one loop wheras the FF NNs dont.\n", 
      "2. Only the output weights are adjusted in ESN , in FF NNs both the input and output weights are adjusted.\n", 
      "3. ESN s have a memory, FF NNs dont."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE\n", 
      "\n", 
      "* ESN uses a large set of recurrent neurons called reservior.\n", 
      "* The weight of reservior neurons does not change after initialization.\n", 
      "* The network only lears the weight of reservior to output.\n", 
      "* It works very well for one dimentional time series data\n", 
      "\n", 
      "The Feed forward networks works differently. The input is feed through the network layer by layer and error is propaged backward to make the adjustments till the first layer. In case of ESN the adjustment is made to the reservior to output weight only."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "The Echo state netwrork has a large number of recurrent neural network in them. this set of RNN is called the dynamic reservoir. \n", 
      "\n", 
      "They can approximate any dynamic model \n", 
      "\n", 
      "they train the model by changing only the weights of the connection of output of the dynamic reservoir and output of the network\n", 
      "\n", 
      "FF: \n", 
      "\n", 
      "they can approximate any continuous function\n", 
      "\n", 
      "They train by adapting all the weights in the network"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "An echo state network contains of an input layer which is connected to a reservoir, which is a big recurrent network. The output layer is connected to the neurons of the reservoir. While learning in an ESN, only the weights between the reservoir and the output layer are changed, no changes within the reservoir.\n", 
      "\n", 
      "Differences to feed forwared networks are, that the reservoir is recurrent and that during the training not all weights are changed, but only the ones between ouput layer and reservoir."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "* Echo state networks are recurrent neural netwoks with **Dynamic Reservoirs.**\n", 
      "* Weights initialized in the dynamic reservoris will not be updated during training.\n", 
      "* Only the weights in output layer (readout states) is updated after each iteration.\n", 
      "* In FF NN, all neurons are connected with other neurons in next layer and all the weights are updated in each iteration.\n", 
      "* But in ESN, the **neurons are connected randomly** with other neurons and it is **recursive** and the **weights are not updated** in the dynamic reservoir."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "ESN is a type of RNN. It has a dynamic reservoir. All the neuron are connected to each other. "
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Echo state network provides structure and supervised learning for recurrent neural networks. It mainly 1) Directs the fixed, large reccurent neural netorks by providing an input stimuli and also fix a response signals to the neurons which are present inside the reservoir(Pool of neurons) 2) It can be directed to get the desired response by the trainable linear combiner of the response signals. \n", 
      "\n", 
      "Unlike FF NNs, ESN's have memory. They can be also activated without an input stimuli, whereas in case of FF NN, they require a external stimuli so that they are activated. Also the neurons needs to connected in one full cycle. "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Echo State Newtors are type of RNN. It has dynamic reseivoir units which exhibits different dynamics. Weights of these reseivoir units are fixed and are not changed during the training phase. Only the reseivoir to output weights are changed to learn the inputs. These networks converge only if reseivoir units exhibitg echo state property i.e its ouput depends only on the previous inputs. this property is satisfied if spectral norm reseivoir weights is less then 1."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "ESN is a kind of Recurrent NN, which has a large, random , fixed RNN called dynamic reservior and only the weights connecting the reservior and output layer are trained. So ESN combine the desired system function and input/output history echo function."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "The ESN is a type of neural network model that uses a recurrent neural network as a large, random, fixed dynamic reservoir that remains unchanged during training and only changes the weight of the reservoir to output layer. \n"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "ESNs are a form of recurrent neural networks with a least one recurrent input. The ESNs are reservior computers which have memory and can be activated without the inputs. In ESNs, instead of training we evolve the network state by feeding it input sequence.\n", 
      "ESNs are different from FF NNs because ESNs contains at least one recurrent connection (feedback)."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "The basic idea of ESNs is to use a large, random, fixed recurrent NN (referred to as dynamical reservoir) and to train only connections from the reservoir to the output.\n", 
      "\n", 
      "The main difference to FF NN lies in the recurrent part of the network, where back passes are built in, giving feedback previous layers. It is not possible to maintain the reservoir beforhand so it suits the given problem. There is a lack of investigation of reservoir construction. "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "An Echo State Network (ESN) is a modified version of a recurrent network. It has a reservoir, which is a large number of hidden neurons with sparsely-connected random and fixed weights. To train an ESN, only the weights connecting the reservoire and the output layer are adjusted; therefore, the efficiency is better than a normal recurrent network. "
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "A Echo State Network is a RNN, is has a dynamical reservoir of neurons which are connected with each other and itself. the DR typically consists of more that 100 neurons. The outputlayer consists of linear readouts of the DR. So a neuron in the output layer sums up the weighted behaviours of the DR neurons. The DR is randomly initialised and only the output layer is trained by supevised learning. \n", 
      "\n", 
      "The main Diffrence is that ESN is a RNN. In contrast to FFNN it can resemble any dynamical system. Usually it is used for time series prediction."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Echo State Networks are a type of recurrent neural networks, where the input layer is interconnected to a reservoir (a random initialized group of neurons with also random interconnections), and this reservoir is connected to the output. The reservoir will not be adjusted, but the output weights. The output weights can also have recurrent connections with the reservoir. The states on the reservoir neurons will be calculated, and with these states and the output weights, the output will be extracted. \n", 
      "\n", 
      "The main difference with the Feed Forward Neural Networks (FF NN) is that in the FF-NNs there's no recurrency, so the input values will be passed to the next layer."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "In contrast to regular feedforward networks, ESN belongs to the group of Recurrent Neural Networks. It has a regular input layer like the FF, then comes a dynamic reservoir, which is a layer of neurons, where at least one full cycle of connections between the neurons is given. The connections inside this reservoir are not constrained and can thus be any possible connection. This reservoir is randomly initilaized and kept that way. Only the respective connections to the output layer are trained during the learning process. "
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Echo State Networks are recurrent neural network type, meaning there are feedbacks in its structure. It is usually only 1% connected. Main difference is that it has a reservoir as a hidden layer where neurons are very randomly connected, with random weight etc. During learning phase only weight outputing neurons are changed. It is required more that 100 neurons to be in a reservoir."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "ESN are different to FFNN in so far that they consist of a reservoir of hidden neurons, which may be connected recurrent, as opposed to having a feed forward architecture. Here, the inputs are connected to the recurrent dynamic reservoir, whereas the DR is connected to the linear output layer. The Output layer may be again connected to the DR, whereas during training only weights of the last layer are learned. Weights of the DR of the ESN are thus initialized and never learning, although since have been extended to minimal complexity architectures."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "ESN are recurrent neural networls with a large reservoir (or echo chamber) with many nodes (recurrent). The weights are learnt only for the connection between this reservoir and the output layer. The weights are not learnt for the nodes inside the reservoir. The main idea is that during training, the input layer cuases the states inside the reservoir to behave in caertain way, and the weights in the output layer is adjusted to match this and the labelled output.\n", 
      "\n", 
      "FFNN are feed forward networks, i.e., they do not have any recurrent connections, which is the main difference with respect to ESN\n", 
      "\n"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Echo State network are recurrent neural network, which means these networks have feedback. While, in feedforward neural networks, there is no feedback. In feedfoward, training data or inputs are not dependent on each other. They do not have any system memory. In ESNs, training inputs are dependent on each other and they have system memory\n", 
      "\n", 
      "\n", 
      "In Echo state network, there are fixed, random generate reservoir weights. These weights are not trained. While, only output weights are trained"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE An ESN is a recurrent neural network with many layers and fixed weights. There are several differences. An ESN has a cycle that means witin the network there are backwarded connections. Withn a FF NN there are only feedforwad connections. Within a FF NN all weights are trained. Within an ESN only output weights are trained. An ESN can produce an output without any input. A FF NN needs an input to produce an output."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Echo State Network is a type of Recurrent Neural Network and has atleat one cyclic (feedback) connection. ESN consists of a dynamic reservoir and a output layer with neurons. The dynamic reservoir consists of randomly initialized neurons with random sturcture and connections (with atleast one feedback connection). The output layer combines the dynamic behaviours of the reservoir in a required fashion. Only the weights of the output neurons are updated while learning.\n", 
      "\n", 
      "An ESN consists of feedback connections while a FF NN does not.\n", 
      "\n", 
      "An ESN could have persisting activations even when there is no input which is not the case in FF NN.\n", 
      "\n", 
      "An ESN can approximate dynamic systems while a FF NN cannot."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "ESNs are a special class of recurrent neural networks. In contrast to ff they also allow backward node connections and thus are able to memorize data.\n", 
      "They are defined by: $x_i$ input i, $y_i$ output i, a dynamic resaviour, and weights connecting all the components.\n", 
      "The dynamic resaviour is generated randomly and fixed. Its topology including weights is never changed.\n", 
      "Only the weights between output layer and dynamic resaviour are changed during training. Because the dynamic resaviour allows all kinds of connections between its nodes it can contain memory that is able to remember data. It also has a spectral radius."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "An ESN is a recurrent ANN with randome, sparse and fixed interneuron connections in the hidden layers. Just the output layer weights get trained, because the network itself is so complex, it can model very much. If the training was not successful we can just create a new randome ESN. Training an complete ESN would by very complex and would take very very very long.\n", 
      "\n", 
      "A FF NN is not recurrent (no feedback) and all its weights get trained and most of the time the interneuron connections are not sparsly."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The core of an ESN is an arbitrary network with recurrence."
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "echo state networks have dynamical reservoir as hidden layer. The dynamical reservoir consists of recurrent non-linear neurons. Only the linear connections from dynamical reservoir to the output layer are trained. The difference to FF NN is, that the ESN is a recurrent network"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "An ESN is a recurrent neural network, that consists of an input layer, a dynamical reservoir and an output layer. In the dynamical reservoir feedback loops are possible in contrast to a feedforward network. However, this dynamical reservoir is only randomily initialzed and not learned. Only the connections to the output from the reservoir are learned. Normally, in FF NNs all connections are trained."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Echo state networks have dynamic reservoir with echo state property which is a randomely initialized RNN. \n", 
      "Hence it can maintain its own internal state. Which is not possible in FF NN. RNN have feedback connections which ecoes back the state of reservoir as well as previoulsly applied inputs. Hence it can model dynamic systems which not possible with FFNN. "
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "ESN refers to echo state networks. Echo state networks are the recurrent neural networks where the hidden to hidden layer weights are selected randomly and are fixed and hidden to output layer weights are changed by the learning process.Since ESN is recurrent neural network hence the output echoes throgh the network even when there is no input where as in ff nets there is no feedback so there is no output if there is no input."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "ESN are another implementation of RNNs where training method is completely different. They comprise of a dynamic reservoir with fixed hidden to hidden connections which makes up an RNN with sparse connetivity. Only the output weights which connect the dynamic units and the output of the reservoir are trained using error, unlike RNNs, where the hidden weights are also trained. ESNs are less compuationaly expensive since they can be easiliy trained with experimentation .However, RNNs use much less hidden units compared to ESN for a similar task."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "- In the ESN we have a huge recurrent network which is called \"Dynamic Reservoir(DR)\" and we have an output layer connected to this DR and we will train the network by adapting and manipulating the connection weights just to the output layer\n", 
      "- Unlike a feedforward network in a ESN because of the DR we have at least one loops that returns the output of a neuron with some time delay therefore we have memory in our network but in FF NNs we don't have any memory"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "ESNs are recurrent neural networks with at least one cyclic connection and are based on the concept of reservoirs. In contrast FF NNs do not have any cyclic connections. Additionally, in ESN the output weights are trained but the reservoir weights are not whereas in FF NNs all weights are trained. The ESN has memory while FF NNs do not have memory."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "An Echo State Network (ESN) is a neural network that uses a reccurent neural network (RNN) as dynamic reservoir which is not changed during training, and trains only the connection from the dynamic reservoir to the output layer. An echo state network is different from FF NNs due to the presence of feedback connection with the dynamic reservoirs which enables it to maintain activation even without inputs. Each unit within the dynamic reservoir in ESNs are excited differently to different inputs."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "ESN have an input layer connected to a reservoir, which is a recurrent neural network. The reservoir is connected to the output layer. On the connections to the output layer are weights, which are updated by the network. The weights of the reservoir are chosen randomly and not updated at all."
     ], 
     "points": 1
    }
   ]
  }, 
  {
   "qid": 14, 
   "question": "Describe: the structure on an CNN.", 
   "answers": [
    {
     "answer": [
      "YOUR ANSWER HERE: Convolutional neural networks have 4 main layers where input layer is connected to convolutional and subsampling layers followed by another set of convolutional and subsampling layers connected to the output layer. They are designed to specifically recognize 2-d shapes are invariant to skewing, rotation and the actual location of the object."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "CNN is has multiple layers and they dont use multiplication matrix. "
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "Convolutional Neural Network(CNN) has three main layers in them\n", 
      "1. Convolutional Layer\n", 
      "2. Pooling or Subsampling Layer\n", 
      "3. Output layer."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE\n", 
      "\n", 
      "CNN has three components,\n", 
      "* Input\n", 
      "* Convolution stage\n", 
      "* Feed forward network\n", 
      "\n", 
      "In CNN the input pass through one or more convolution stage befor it is feed into a feed forward network. The convolution stage uses a hierarchical set of filters, RELU and polling to extract low level as well as high level concepts from the input. The feed forward network along uses the output of the convolution stage and back propagation is used to make adjustment to the network weights as well the filters in the convolution stage."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "THe CNN will have a \n", 
      "\n", 
      "input layer\n", 
      "\n", 
      "convolutional layer - Here the convolution and sub sampling of the feature maps take place\n", 
      "\n", 
      "Feed Forward - Neural Network layer\n", 
      "\n", 
      "Output layer"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "A convolutional neural network uses the steps of convolution and subsampling alternating in the beginning. Using different kernels during convolution, many feature maps are created. The subsampling step merges the maps to reduce their amount. After some of these steps, a classical feed forward network is in the end to transform the different feature maps to one output layer."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "* Input layer\n", 
      "* Convoluton layer (Affine transformation)\n", 
      "* Filtering layer (Sampling)\n", 
      "* Learning layer\n", 
      "* Output layer"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "CNN has basically four types of layers. They are: convolutional layer, ReLU layer, Pooling layer and the fully connected layer.\n", 
      "\n", 
      "We can arrange the convolutional layer and ReLU layer in different ways.\n", 
      "\n", 
      "One of the ways is to have 1 convolutional layer, 1 Pooling layer, 1 ReLU layer and repreat this 3 layers again and then finally a fully connected layer.\n", 
      "\n", 
      "Another way is to have 1 convolutional layer, 1 pooling layer again repeat the convolutional and pooling layer and then 1 ReLU layer and finally fully connected layer.\n", 
      "\n", 
      "Convolutional layer is used to find the feature space."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "A CNN \n", 
      "1. starts with a input, where we perform the convolution, which provides a piece of activation. \n", 
      "2. Next it is being sent through the activation layer otherwise known as the detection layer. \n", 
      "3. Then the final stage is the pooling. "
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "In CNN we have different Kernels which are used for extracting certain properties of the inputs. These are called feature maps. After this there is a detection phase which introduces non-linearity. Further there is pooling which introduces translational invariance. There can be many such layers of feature maps and pooling. Finally its reduced to single row input and trained using traditional methods like Back Propogation algorithms."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "1. first stage, the layer performs several convolution parallel to produce a set of linear activation\n", 
      "2. detector stage, each linear activation is run through a non-linear activation\n", 
      "3. third stage, use a pooling function to modify the output of layer."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "- The CNN has an input layer\n", 
      "- The input layer is connected to a convolution layer consisting of three phases:\n", 
      "    - convolution stage\n", 
      "    - Detector stage\n", 
      "    - pooling stage\n", 
      "- The next layer (can be a traditional FFNN)"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "CNNs are feed forward neural networks which replaces matrix multiplication task with convolution operation which is much sparse. CNN contain followng stages:\n", 
      "+ Convolution (learns local features)\n", 
      "+ max pooling (coarse-graining to learn better abstraction of input image)"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "In comparison to other NN, in CNN matrix multiplication is replaced with convolution. Everything else remains the same."
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "An CNN (covolutional neural network) contains a set of hidden layers for feature extration (convolutional layers, pooling layers), and fully-connected layers that classifies the features. The covolutional layers are used to carry out the covolution between the incoming signals with a set of filters, resulting in a set of feature maps. The pooling layers are used to reduce the dimensionality of the feature maps, and make the features invariant of rotation or displacement."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "A CNN typically consists of multiple CNN layers and a few fully connected FF Network Layers. I'll assume the fully connected part is not so relevant to this questions.\n", 
      "\n", 
      "A CNN layer is typically a convolution layer and a pooling layer\n", 
      "\n", 
      "In the convolution layer a kernel is convolved onto the input. If zero padding is used the result is in the same dimensionality. Depeding on the Kernel the convolution can be 1, 2 or 3D. \n", 
      "\n", 
      "In the Pooling layer the result of the convolution is reduced to focus ont the importan features. It also helps on translational invariance."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "A Convolutional Neural Networks has the following structure:\n", 
      " - The input is defined in a grid, so any image or video sequence will be used.\n", 
      " - A several number of convolutional layers, where also subsampling (pooling) can be used.\n", 
      " - In the convolutional steps a filter will be used for each layer.\n", 
      " - After applying multiple convolutional layers, a normal feed-forward networks can be applied, where for example a back propagation algorithm can be used for updating the weights in the numerous iterations."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "A Concolutional neural network has alternating layers of convolution and pooling. The convolutional layer is applying a filter to the input, while the pooling layer sub-samples the input. In some networks this is replaced by strided convolution, which combines these two steps into one. The structure at the end of a CNN is equal to that of a regular feedforward network."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Convolutional neural networks are so that first layer is not fully connected but in a way that neuron connections overlap, leading to a grid type structure with overlapping circles. Another layer is connected only with nodes that are responsible for a particular feature (convolutions), then next layer is choosing wich of those convolutions from each ensemble is the most apropriate, after that next layer is fully connected to output neurons."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "CNN learn on grid data (images, 3d volumes) using filters instead of matrix multiplication. Here, the filters are convoluted with the input in the Convolution layer per neuron, where we slide the filter (defined by fiter size $S\\times S$) over the input with a stride (step size), and optional zero padding. Strictly speaking, since for RGB images we are working have three color channels, we work with volumes of filters (For example for RGB images of size $32\\times 32\\times 3$, a filter of window size $S=5$ has the dimensions $5\\times5\\times3$). Instead of learning a volume of weights for each convolution step, we share weights, considering that one feature detected in one part of the image may be of interest in another part. Then, we apply a nonlinearity, commonly the ReLu activation, as to introduce nonlinearity into our model. To reduce spatial size of our input, we can either use higher strided convolutional layers or pooling layers, for example the popular max pooling layer, where the maximum value over a subvolume is picked. These layers are then stacked, while in the last layers fully connected neurons are typically used to reduce data to for example a classification vector."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "A CNN uses convolution instead of matrix multiplication. After this there is a non linearity which may be a function like ReLU. There is also a pooling stage which is used to pool the important features.\n", 
      "\n", 
      "CNNs are translation invartiant."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "In CNN, there are mainly three layers:\n", 
      "\n", 
      "    i. Convolution Layer: It is used to capture the low-level and high level features using kernal over the image.\n", 
      "    \n", 
      "    ii. Pooling Layer: It is used for dimensionality reduction, and for translation invariance\n", 
      "    \n", 
      "    iii. Fully Connected Layer: This layer is same as regular NNs, where all the nodes are fully connected with each other. There is mostly sigmoid activation function is used to compute the probabilities of each output/class.\n", 
      "    \n", 
      "    Furthermore, In CNNs, we use Rectified linear unit(ReLU) activation function  "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE A Convolutional Neural Network has a kernel which is much smaller than the input. This is why it can operate much more efficient than a normal neural network. Normal Neural network O(n \\times m), convolutional neural network O ( n $ \\times $ k), k is much smaller than m. A convolutional Network operates no large images. The input is preproessed in many layers before it is given to a normal neural network. Preprocessing transforms input into a linear separable problem."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "In a Convolutional Neural Network, the layer order is:\n", 
      "\n", 
      "1. Convolutional layer (has kernels which convolve over the input image incase of first layer or feature maps otherwise).\n", 
      "2. Activation layer (ReLU activation).\n", 
      "3. Pooling layer (max or average pooling). These 3 layers can be repeated any number of times.\n", 
      "4. Finally one or more fully connected layers followed by softmax layer.\n"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "A convolutional neural network consits of convolutional layers.\n", 
      "A convolutional layer applies one or multiple kernels (matrix) to an input vector/matrix (typically image) instead of connecting all single inputs of the input vector to the next layer with seperate weights.\n", 
      "Instead in training only the kernel is updated. \n", 
      "After a convolutional layer there is typicall a pooling layer.\n", 
      "Given a window size it reduce the dimensional size of the output of the convolutional layer by using e.g. max or avg pooling.\n", 
      "Afterwards the activation layer applies an activation function to the output of the pooling layer.\n", 
      "In the end of a cnn there are typically some fully connected regular layers resulting in a softmax activation function, which assigns the probabilities to the classes output."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "An Convalutional neuron network assumes the input is an image. Because of that it has a achitecture, so that there are (abwechselnt) covalution and subsampling layers. After the last subsampling layer there is a normal FF NN which classifys the input."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "A CNN conists of one or more convolution layers as well as subsampling or pooling layers followed by a fully connected standard FFN. In the convolutution layer kernels are used to create feature maps. A kernel is smaller matrix that is apllied to all possible positions on the input matrix. In the pooling stage the dimension of the rfeature map is reduced. for example by max pooling. "
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Convolutional Neural Network\n", 
      "\n", 
      "it has often images or video sequences as input. the input is computed by convolution (with different kernels) and downsampling in many steps to smaller but many more input matrices. In last step the matrices are connected to a classical FF NN.  "
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "A basic CNN can be structured into the three layers convolution, detector and pooling.\n", 
      "\n", 
      "In the first layer the convolution operation is performed on the inputs.\n", 
      "\n", 
      "In the second layer the the activation function, mostly ReLU, is applied to the result of the convolution.\n", 
      "\n", 
      "The last layer can be used to reduce the size of the resulting convoluted images, e.g. by max pooling.\n"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "CNN uses convolutional layers to extract primitive information from pattern. \n", 
      "\n", 
      "First data is convolved with the first layer to extract some features.\n", 
      "\n", 
      "Output of this layer is passed through RELU function to rectify it. \n", 
      "\n", 
      "Then is downsampled by pulling layer. It basicaly chooses only relevant outputs of convolution layer for further processing. \n", 
      "\n", 
      "RELU is chosen instead of sigmoid because it doesnt allow gradient to vanish in backpropogation. \n", 
      "\n"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The structure is as follows:\n", 
      "-Convolution: In this layer convolution takes place instead of matrix multiplication\n", 
      "-Deconvolution: In this layer deconvolution takes place , by matrix multiplication\n", 
      "-Average weight layer: This is a max pooling layer "
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "CNN comprises of multile layers of neurons which perform specific tasks. The initia layer is the convolution layer which performs convolution of the input with the elements of a given kernel. Simpler tasks such as edge detecto\u00edon are performed. Detector layer forms a seconf layer here the output of convolution layer if fed through an activation function such as ReLU. Further, the data is pooled in the pooling layers where downsamping is done to reduce dimensionaity. These layers are repeated to perform more complex feature extraction operations."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "A CNN network consists of:\n", 
      "    - Input layer\n", 
      "    - conolution layer\n", 
      "    - Detection layer\n", 
      "    - Pooling layer\n", 
      "    - Next layer(because CNN consists of many layers this will be another block of layers similar to what described)"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "A CNN consists of several stacked Convolutional layers which can be separated by other layers such as Pooling, Activation, Zero-padding and Dropout which is a form of Regularization. The output layer is generally dependent on the task but could be a Softmax Activation from a Fully connected (also called Densely connected) layer. The number of outputs is usually the number of classes."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "A CNN is a neural network that replaces matrix multiplication with a mathematical operation called convolution in one or more layers. The main idea behind the structure of a CNN is to replace the activation of neuron with a flipped filter (Convolution layer) and then apply another function called pooling to adust the output further."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE"
     ], 
     "points": 0
    }
   ]
  }, 
  {
   "qid": 15, 
   "question": "What are three items to be learned for an RBF network? Difference to other NNs, Pros/cons?", 
   "answers": [
    {
     "answer": [
      "YOUR ANSWER HERE:\n", 
      "- RBFs are only dependent on the radial distance i.e., distance from the center to the input"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "data varaince\n", 
      "\n", 
      "Features\n", 
      "\n", 
      "RBF uses suport vector machine which is classifier. it uses different kernels , it doesnot have feedback cycle. \n", 
      "it also classifies non linear classification problem. it mainly works with 2 classes C1 ,C2.\n", 
      "\n", 
      "other NN is can also reggression and there can be feedback (RNN)\n"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "The difference of RBF to other NNS are\n", 
      "1. RBF has only one hidden layer wheras their is no hard limitation on number of hidden layers on other NNs\n", 
      "2. The activation function used in RBF is non linear."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE\n", 
      "\n", 
      "A RBF network learns,\n", 
      "\n", 
      "* The radial function\n", 
      "* weight of the hidden to output neuron\n", 
      "* Centroid of a cluster\n", 
      "\n", 
      "Difference:\n", 
      "\n", 
      "* A RBF is composed of input layer, 1 hidden layer and the output layer. Other NN can generally use as many hidden layers as required.\n", 
      "* The transformation from input to hidden layer in RBF is non linear and hidden to output is linear. In most other NN both are non linear.\n", 
      "\n", 
      "Pros/Cons:\n", 
      "* This is a very simple learner\n", 
      "* There are many variations of RBF available.\n"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "1. Weigths in the network\n", 
      "2. the center of the clusters\n", 
      "3. variation of the cluster ($\\sigma$)\n", 
      "\n", 
      "Difference: \n", 
      "\n", 
      "RBF always have only three layers\n", 
      "\n", 
      "RBF can also trained in an unspervised method\n", 
      "\n", 
      "RBF can also approximate any continuous function"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "- The centroids of the radial basis functions\n", 
      "- The weights of the neurons\n", 
      "- The amount of needed neurons\n", 
      "\n", 
      "A difference to other neural networks is that the centroids of the radial basis functions need to be there."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Three items to be learned,\n", 
      "* origin\n", 
      "* center\n", 
      "\n", 
      "Pros:\n", 
      "* It can transform data from n dimension to infinity dimension.\n", 
      "* It can solve non linear problems easily.\n", 
      "\n", 
      "Cons:\n", 
      "* It may overfit.\n", 
      "* Learning is slow."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Center of the hidden neurons, synaptic weights connecting the neurons and\n", 
      "\n", 
      "RBFs have only 1 hidden layer. There is a non0linear tranformation between the inputs and the hidden space and a linear tranformation between the hidden space and the output space. \n", 
      "\n", 
      "Pros: It can be used for non-linearly separable data.\n"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "The three items that needs to be learnt are the centers, widths and depth. Compared to other NN they have a standard 3 layer structure. They can have just one hidden layer. "
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "In RBF first inputs are transformed to higer dimension using non linear transformation. This is based on unsupervised learning. Inputs are then learned using least square estimation which is an supervised learning. RBF is based on Covers theorem which states that there is higher probability that data will be linearly separable in higher dimension. "
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "1. non-linear transformation function from input space to feature space\n", 
      "2. centers of input data that is used for each hidden neuron\n", 
      "3. synaptic weights connecting hidden layer and output layer"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "- Use distance to center as argument for computation of local fields.\n", 
      "- Use radial basis functions as activations\n", 
      "- RFBs are only global approximators, \n", 
      "- splitted learning instead of global learning"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "+ Kernels\n", 
      "+ Only neighbourhoods are computed based on distances.\n", 
      "+ Radius of neighbourhoods\n", 
      "\n", 
      "Pros\n", 
      "+ RBF are simple and easy to compute. \n", 
      "\n", 
      "Cons\n", 
      "+ They remember the data points"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Differences are:\n", 
      "* RBFN has a single hidden layer. Nonlinear hidden layer.\n", 
      "* Linear output layer.\n", 
      "* Argument of hidden units: Euclidean norm. \n", 
      "* Universal approximation property. Local approximators. \n", 
      "* Splitted Learning.\n"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "The mean of the k clusters, the "
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "This question is really unspecific: Difference to other NNs...\n", 
      "\n", 
      "- Centers\n", 
      "- Widths\n", 
      "- Weights\n", 
      "\n", 
      "The main diffrence is that the RBF uses localized activation functions and it has only one hidden layer.\n", 
      "It applys a non-linear transformation from the input space to the hidden space and a linear transformation from the hidden space into output space. \n", 
      "\n", 
      "It is important to use regularization for RBF\n", 
      "RBF work well for interpolation, so it should work good for regression"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "A Radial Basis Function Network has the following structure:\n", 
      " - An input layer\n", 
      " - A hidden layer, where a non-linear dimensional transformation will be used.\n", 
      " - Each neuron of the hidden layer will have a defined center (extracted in previous steps).\n", 
      " - A linear transformation will be used to the hidden data space, and the output will be calculated.\n", 
      " \n", 
      "So, the three items that must be learning in the RBF networks are:\n", 
      " - The centers of each hidden neuron (using for example k-means neighbours algorithm).\n", 
      " - The radial function that will be used for the non-linear transformation.\n", 
      " - The weights applied into the output layer.\n", 
      " \n"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The centers of the clusters, the widhts of the clusters and the weights. \n", 
      "In contrast to other NNs the output only depends on the radial distance to the center of the clusters."
     ], 
     "points": 1
    }, 
    {
     "answer": [], 
     "points": 0
    }, 
    {
     "answer": [
      "In RBF, we learn the centers of the radial basis functions using unsupervised clustering methods, the weights of the last output layer, and the width of our radial basis functions. As opposed to Multi layer NN, we dont need expensive backpropagation as we only need to train the last layer, while the unsupervised training algorithm does the work the RBF centers. A possbile Con would be that if the RBF centers dont represent the training data point distribution well, some data points may be hard to model."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "1. weights\n", 
      "2. centres (or means) of clusters\n", 
      "3. $\\sigma$ which is the width of the clusters\n", 
      "\n", 
      "Difference: Uses functions which are radially invariant.\n", 
      "\n", 
      "Pros:\n", 
      "- Easy to learn\n", 
      "- Non-linearity\n", 
      "- Only dependent on the radial distance\n", 
      "\n", 
      "Cons:\n", 
      "- Data required is more\n", 
      "- OVerfitting\n", 
      "\n"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "In RBF network, we need to learn **centre** and **width** of gaussian function. We also learn **output weights**\n", 
      "\n", 
      "Difference between RBF and NNs:\n", 
      "\n", 
      "i. In RBF, there is only one hidden layer, while in NNs, there can be more than one hidden layer\n", 
      "\n", 
      "ii. In RBF, activation function of hidden layer is Gaussian so parameters are in euclidean norm. While, in NNs, parameters for activation function are product of weights and inputs. \n", 
      "\n", 
      "iii. Parameter computation is different in RBF as compute to other NNs. Like, we compute centre of cluster in RBF with the help of K-means clustering."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE RBF network need to learn center of activation function. Differenec to other NN is that there are as many activation functions as data points. One con of Radial Basis Funtion is that due to many activation function RBF networks have a huge computational effort. "
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Three items to learn in a RBFN:\n", 
      "\n", 
      "1. Centroids of the input clusters.\n", 
      "2. Widths of the clusters.\n", 
      "3. Weights of the synapses connecting the hidden layer and the output layer.\n", 
      "\n", 
      "The centroids and widths are learned in an unsupervised fashion while the weights in a supervised fashion. So an RBFN combines unsupervised and supervised learning while a regular NN is completely supervised or completely unsupervised.\n", 
      "\n", 
      "Learning is fast and is not so sensitive to the unsupervised part."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "An RBF network relies on a clustering algorithm. This can be e.g. k-means clustering.\n", 
      "The three items to be learned:\n", 
      "1. Cluster center\n", 
      "2. Cluster size\n", 
      "3. weights connecting the hidden nodes to the output layer\n", 
      "\n", 
      "Difference to other NNs:\n", 
      "- only three layers: input, hidden and output\n", 
      "- each node in the hidden layer uses a different activation function depended on the cluster assigned to it\n", 
      "- only output weights are trained"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "If a RBF network used a gauss function as the activation fnction these thinks have to be learned:\n", 
      "\n", 
      "- centroide $c_i$ (unsupervised)\n", 
      "- sigma (unsupervised)\n", 
      "- weights of the output layer (supervised)\n", 
      "\n", 
      "The RBF network is easy learning and not so sesitive to the unsupervised learning part.\n"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Centroids, width, and parameter of function  \n", 
      "The learning of an rbfn is splitted in an unsupervised and a supervised part.   \n", 
      "Only one layer, no vanishing gradient.  \n", 
      "Pros: easy learning  \n", 
      "the unsupervised part is not very sensitive.  \n", 
      "Cons:   \n", 
      "Difficult to approximate constants  "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Centers of the radial basis functions\n", 
      "best model (rbf)\n", 
      "distance of each input pair \n", 
      "\n", 
      "pros:\n", 
      "non-linear functions application\n", 
      "ease to compute \n", 
      "using covers theorem \n", 
      "\n", 
      "cons:\n", 
      "high-dimensional "
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "The clusters, the width of the basis function and the weights.\n", 
      "\n", 
      "The clusters and the width are learned in an unsupervised fashion. While the weights are learning by a standard supervised steepest descent method.\n", 
      "\n", 
      "Pros\n", 
      "RBFs can be very easily trained.\n", 
      "RBFs can achieve better results with less complexity.\n", 
      "\n", 
      "Cons\n", 
      "Not as easy to understand"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "1. Input layer connecting RBF to environment. \n", 
      "\n", 
      "2. Hidden layer: nonolinear tranformation of input space to hidden space \n", 
      "\n", 
      "3. Output layer: linear tranformation of hidden space to output space. \n", 
      "\n", 
      "It is different than other NNs because for learning patterns, it nonlinearly tranforms the input space to higher dimmensional space. Other NNs do not tranform input. \n", 
      "\n", 
      "As it tranforms input patterns to high dimmensional nonlinear space, patterns which are not separable in lower dimmensions have greater chance to be separated. \n", 
      "\n", 
      "But if we select basis functions equal to datapoints, problem is ill-formulated.\n", 
      "\n", 
      "Processing is computationallly heavy. \n", 
      "\n", 
      "Regualation becomes problem specific.\n", 
      "\n", 
      "Hence, unsupervied learning is employed to clusters data initially. "
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "In rbf the main advantage is that it follows cover's theorem and the complex pattern classification problem can be solved ."
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "The three parametrs to be learnedin Generalized RBF are 1) cluster centers of the basis functions 2) spread or the width of the basis functions $\\sigma$ , and 3) weights of connecting the input and the hidden layers.\n", 
      "\n", 
      "RBF are differenent from NNs in different ways.\n", 
      "\n", 
      "1) The kernels are localized functions where as NNs are gobablized\n", 
      "\n", 
      "2) They use euclidean distance in their activation functions where as NNs use inner products\n", 
      "\n", 
      "3) They have a single hidden layer and output is a linear combinaation but NNs compulsarily are not the same."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "The three items that must be learned in RBFs are:\n", 
      "    - The center of the kernel\n", 
      "    - The size(standard deviation) of the kernel\n", 
      "    "
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "The three open parameters of an RBF network are:\n", 
      "1. The centers $c_i$\n", 
      "2. The widths $\\sigma_i$ and\n", 
      "3. The weights $w_i$  \n", 
      "The number of centers $k$ has to be determined by trial and error."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "The weights, the interpolation matrix have to be learned. The RBF maps the input space into a higher dimensional feature space nonlinearly. The feature space is mapped into the output space linearly. The output space is much smaller than the feature space.\n", 
      "\n", 
      "Pros: local learning\n", 
      "\n", 
      "Cons: feature space can be really large, curse of dimensionality"
     ], 
     "points": 1
    }
   ]
  }, 
  {
   "qid": 16, 
   "question": "Describe how learning based on k-nearest neighbors works, use pseudo code!", 
   "answers": [
    {
     "answer": [
      "YOUR ANSWER HERE: Learning based on K-nearest neighbors:\n", 
      "- All the input-output samples from the training set are stored in the memory.\n", 
      "- For a test input, find the k-nearest neighbors.\n", 
      "- Assign the test vector with the class of the most of the neighbours in the neighborhood."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "K-nearest neighbors basically works as follows\n", 
      "\n", 
      "1) the they define randomly the cluster points .\n", 
      "\n", 
      "2) clacluate the mean of the equlidian distance between the data points. here the points from the previous step acts as centrioids.\n", 
      "\n", 
      "3) check the variance of the clusters. \n", 
      "\n", 
      "4) repeat 1-2-3 till you get the proper clusters.\n"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "1. Slect random number of neghbourhood initially\n", 
      "2. Find out the input which is nearest to the weight vector using competitive learning\n", 
      "3. Change only the input which wins\n", 
      "4. decrease the size of neighbourhood\n", 
      "5. Repeat"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE\n", 
      "\n", 
      "for x in input_points\n", 
      "\n", 
      "  neighbours = find_nearest_k_points(x)\n", 
      "  \n", 
      "  for n in neighbours\n", 
      "  \n", 
      "    v = get_vote_of(n)\n", 
      "    \n", 
      "    update_votes_count_for(x,v)\n", 
      "    \n", 
      "  max = get_max_vote_for(x)\n", 
      "  "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Let L be set of labeled data in memory, L ={x1,x2....x_n}, while x_prime is nearest point to the x_test point, in term of euclidean distance. Let class_of be funtion that return class type if certain data point x. And let K be constant number of neighboring points consired in algorithm search. \n", 
      "\n", 
      "Initialize x_prime = {}, L_0 = L, list_of_classes = {}\n", 
      "\n", 
      "for j= 1; j<=K; j++ do:\n", 
      "    \n", 
      "   L_j = L_(j-1)/x_prime\n", 
      "   \n", 
      "   x_prime = nearest neighbor to X_test form L_j data\n", 
      "   \n", 
      "   c = class_of(x_prime)\n", 
      "   \n", 
      "   list_of_classes.append(c)\n", 
      "   \n", 
      "end\n", 
      "\n", 
      "c(x_test):=  most frequent class in list_of_classes"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Step1 : Randomly select the k centers \n", 
      "\n", 
      "Step2 : Cluster the datapoints based on the centers\n", 
      "\n", 
      "Step3 : the centroid of the cluster becomes the new mean\n", 
      "\n", 
      "Step4 : repeat step 2 and 3 until there is no more evidential cahnge in the network"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "    input: labeled data set, one unlabeled data point, number k\n", 
      "\n", 
      "    find the k labeled points, which are closest to the given unlabeled point\n", 
      "    from these points, find the label which occurs most often\n", 
      "    assign this label to the unlabeled data point"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "* Choose a value for k\n", 
      "* K represents the number of neighbors\n", 
      "* Get a sample from the input space\n", 
      "* Find the class based on the majority of votes received from the neighbors. \n", 
      "* For example, if the value of k is 3, then let say there are 2 neighbors from class one and 1 neighbor from class two, then the new input sample belongs to class one."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Step1: We randomly place the n neurons.\n", 
      "\n", 
      "Step2: For each data point whichever neuron is closer to it, the datapoint is assigned to that neuron.\n", 
      "\n", 
      "Step3: Once all the datapoints are assigned, the mean of the datapoints attached to each neuron is calculated and the neuron is shifted to the mean value.\n", 
      "\n", 
      "Step4: Step 2 and 3 are done until there is no more shift in the neurons position.\n", 
      "\n", 
      "In this way the neurons are adjusted."
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "L1 - Data set (x1,x2,x3,x_n)\n", 
      "L2 - Storing the dataset based on the number of neighbors. \n", 
      "x_test - Test data set. \n", 
      "\n", 
      "So we basically have the k value to be an odd number, so that we can select a majority value. \n", 
      "\n", 
      "for i based on the number of l:\n", 
      "    x' = xtest - distance from the neighboring neuron i. \n", 
      "    L2 = smallest x' in this based on the number of K \n", 
      "\n", 
      "x_test = max(L2)\n", 
      "\n", 
      "We select the neurons from the neighborhood by calculating the euclidean distance based on weights. \n", 
      "Then if K is 3, we have 3 neurons. So from that we select the label which is fixed maximum on the dataset given in the K-fields. \n"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "define criterial for finding k nearest neighbours <br>\n", 
      "find k nearest neigbours of test input in training dataset <br>\n", 
      "find the class to which most of the neghbours belong <br>\n", 
      "assign that class to the test input <br>"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "1. identify k classified patterns that lie nearest to the test vector\n", 
      "2. assign the test vector to the class that is most frequently presented to the k nearest neighbors"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Initialize k_neighbors = {}, \n", 
      "\n", 
      "for every neuron\n", 
      "\n", 
      " find the nearest neighbor and add it to k_neighbors\n", 
      " \n", 
      "Return nearest k_neighbors\n", 
      " \n"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "** Pseudo Code **\n", 
      "1. Initiate weights randomly\n", 
      "2. Assign labels to k-inputs that are map neuron is closest to.\n", 
      "3. append all inputs to map neurons using 2.\n", 
      "4. Find centroid of the cluster and move the map neuron to the centroid.\n", 
      "5. Do 2, and 4 until some convergence criteria is reached, e.g. maximum iterations is reached or no updates are performed or net distance is below some specified distance."
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "Given: L; X_TEST not element of L; k = number of neighbors that will taken into consideration; function class_of()\n", 
      "\n", 
      "Set x'={}, L_0=L, Classf={};\n", 
      "\n", 
      "for j=1,...k do:\n", 
      "\n", 
      "    L_{j-1} \\ x'; //exclude all the data points which have been identified as nearest neighbors already\n", 
      "    \n", 
      "    x'=find the closest neighbor of X_TEST in L_j; //e.g. compute eucldea distance\n", 
      "    \n", 
      "    c = class_of(x');\n", 
      "    \n", 
      "    Classf=push(c)\n", 
      "    \n", 
      "set c(x_TEST)= most frequently value in Classf;"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Train the knn by storing the data labeled points.\n", 
      "\n", 
      "Present a test point.\n", 
      "> Compute the distance between the test point and all the training data points.\n", 
      "\n", 
      "> Sort the distance, and choose the k datapoints with smallest distance.\n", 
      "\n", 
      "> Determine the class of the test point by majority vote."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Define K centroids, random intialised\n", 
      "assign each data point a class label\n", 
      "while the is no change anymore\n", 
      "    for each k \n", 
      "        calculate the centroid of the datapoint beloging to that label\n", 
      "        for each datapoint \n", 
      "            determine the nearest centroid\n", 
      "            assign a new class label which belongs to the centroid."
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "K-nearest neighbors can be seen as an unsupervised learning method, where for a defined number of groups k, the nearest neighbors will be calculated.\n", 
      "\n", 
      "1: For a given input data\n", 
      "\n", 
      "2: Define value k\n", 
      "\n", 
      "3: Get the k points that are closer to the given points. \n"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "1. Get the nearest neighbor of the current x'\n", 
      "2. Remove it from L \n", 
      "3. Get the class of the current x \n", 
      "4. Classify x' as the class that occurs the most often in the neighbors\n", 
      "\n", 
      "for 1 to K:\n", 
      "\n", 
      "    L_i = L/x'\n", 
      "    \n", 
      "    x_nn = min(|x-x'|)\n", 
      "    \n", 
      "    c = getclassof(x_nn)\n", 
      "    \n", 
      "    AmountofClasses.add(c)\n", 
      "    \n", 
      "setclassof(x') = Max(AmountofClasses)"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Firstly identify nearest neighbouring weights\n", 
      "then choose k amount of neighbors and adapt their weights\n"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "1. get the input\n", 
      "2. find the k- nearest neighbours by finding the distance (euclidean) from the input to all the nodes and selecting the k closest ones\n", 
      "3. Class of the input is the most frequent class in the k-neighbnours found (as such, k needs to be odd number)"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "i. First we initialize the random points, those points are considered as centroids of clusters\n", 
      "\n", 
      "ii. Then, for each new points, we compute euclidean distance, and points closest to centrodis are assigned their respective clusters\n", 
      "\n", 
      "iii. We again re-calculate the centroids of clusters\n", 
      "\n", 
      "iv. Repeat 2 and 3 untill convergence is achieved, by making sure, no centroids are moving and cost function is minmized "
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE k-nearest neighbor wants to determine encoder $\\C which assigns N inputs to K clusters based on a rule to be defined."
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "K-nearest neighbors:\n", 
      "\n", 
      "1. Take the input data to be classified.\n", 
      "2. Find the first nearest neighbour in terms of euclidean distance.\n", 
      "3. Push the class of this nearest neighbour into a list of labels.\n", 
      "4. Repeat step 2 and 3 for each K which needs to be odd.\n", 
      "5. After all K nearest labels are collected in the list, count the labels in each class.\n", 
      "6. Assign to the input data, the class which as maximum count (majority vote)."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "$N$ number of clusters.\n", 
      "\n", 
      "Given sample data select $N$ different cluster centers by random.\n", 
      "\n", 
      "Assign all sample points to the closest cluster\n", 
      "\n", 
      "repeat until no further change:\n", 
      " - recalucate the cluster centers\n", 
      " - Assign all sample points to the closest cluster"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "given a fixed $k$\n", 
      "\n", 
      "given a point to classify $new$\n", 
      "\n", 
      "given an empty $class$\n", 
      "\n", 
      "given a List of all points $L$\n", 
      "\n", 
      "from 1 to k do\n", 
      "\n", 
      "    find nearest point $x$ to $new$ in $L$\n", 
      "    add class of neares point $x$ in list $class$\n", 
      "    new list L = L without nearest neighboor $x$\n", 
      "    \n", 
      "class of new = most class in $class$\n", 
      "\n"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "training_set := training data  \n", 
      "define #clusters  \n", 
      "select #clusters datapoints as centroids randomly  \n", 
      "\n", 
      "for datapoint in training_set:   \n", 
      "    calculate distance to centroid\n", 
      "    lable dataPoint according to closest centroid\n", 
      "end for\n", 
      "\n", 
      "iterate over clusters:  \n", 
      "    calculate centroid"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "for a given input \n", 
      "    compute distances to other input points\n", 
      "    pick k nearest neighboors\n", 
      "    look at labeling of neighboors\n", 
      "    decide labeling (classification) by highest number of neighboors in one class (german: Mehrheitsentscheid)"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "This learning is based on the memory introduced into the dataset. For each data point the nearest neighbours are found via a distance function.\n", 
      "\n", 
      "for each datapoint d\n", 
      "\n", 
      "    neighbours = get_k_nearest_neighbours_of(d)\n", 
      "\n", 
      "    d.class = get_most_represented_class(neighbours) "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "(K-nearest neighbours is memory based learning.)\n", 
      "\n", 
      "take input x \n", 
      "\n", 
      "calculate calculate distance of x from each training point. \n", 
      "\n", 
      "Select K training points with minimum distce from the data. \n", 
      "\n", 
      "Fetch classes of selected K nearest points. \n", 
      "\n", 
      "Calculate number points per class in k nearest points. \n", 
      "\n", 
      "determine the class C having maximum points in k nearest pioints \n", 
      "\n", 
      "The class of the input point is C."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "$ L = {x1,x2...x_n} $\n", 
      "\n", 
      "$L = L_0$\n", 
      "\n", 
      "$x' = {}$\n", 
      "\n", 
      "for the input (x,d) :\n", 
      "do {\n", 
      "x_test \n", 
      "\n", 
      "}"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "\n", 
      "Parameters: k -number of clusters, x datapoints , c classes\n", 
      "\n", 
      "1) Initialize randomly k centroid of the custers \n", 
      "\n", 
      "2) select a data point and compute the set of nearest neighbours of the point using euclidean distances.\n", 
      "\n", 
      "3) Find the class that maximum number of neighbours belong to and assign the class to the datapoint.\n", 
      "\n", 
      "4) Once the class is assigned, compute the centroid of each cluster or class, considering all the class members.\n", 
      "\n", 
      "5) Iterate over all the datapoints and repeat over all points (from step 2) until no update in centroids is required."
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "    1- randomly define a predefined number of cluster centers(CC)\n", 
      "    2- calculate the distance of each datapoint from each CC\n", 
      "    3- Each data point belongs to the cluster that has the least distance from its CC\n", 
      "    4- Calculate a new CC by getting the average of all the points inside a cluster\n", 
      "    5- Go to 2 and repeat this process untill we reach the termination condition"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "1. Given: Classified data $X$\n", 
      "2. For a new sample $x$:  \n", 
      "    Determine the $k$ nearest neighbours in X  \n", 
      "    Output $y$ := majority vote of the class of nearest neighbours"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "For the input data x the distance to every other data point is calculated using a distance measure.\n", 
      "\n", 
      "Take the k data points, which have the minimum distance to x. These are the k-nearest neighbours.\n", 
      "\n", 
      "The most frequent class from the neighbours is assigned as the class of the input data."
     ], 
     "points": 2
    }
   ]
  }, 
  {
   "qid": 17, 
   "question": "Explain the Bias Variance Dilemma!", 
   "answers": [
    {
     "answer": [
      "YOUR ANSWER HERE"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "Bias is an proides an affine transformation. and it is treated  a extra inputs. which noramll taken as +1"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "High bias and variance is desirable in input. Bias Variance Dilemma is the property of input data where if the bias is increased the variance decreases and vice versa. It is difficult to find a tradeoff between them. "
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE\n", 
      "\n", 
      "Bias: Bias means how much the prediction differs from the true value\n", 
      "\n", 
      "Variance: Variance means how much the prediction varies for different datasets\n", 
      "\n", 
      "The Dilemma is that both generally can not be reduced simultaneously. A learning machine can reduce one at the cost of other."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "Bias : differnce between the estmated output and the actual output\n", 
      "\n", 
      "Variance: The range of output of a network for different training set. \n", 
      "\n", 
      "Bias and Variance can't be decreased at the same time for many networks. ONly one at a time can be decreased\n", 
      "\n"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "NO ANSWER HERE"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "Bias is used to affine transform of $u$.\n", 
      "\n", 
      "It helps to shift the classifier line.\n", 
      "\n", 
      "$$v=u+b$$"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "Bias: How close the estimate is to the true value.\n", 
      "\n", 
      "variance: How much does the estimate vary for different training sets.\n", 
      "\n", 
      "we always have either hugh variance low bias or low variance high bias."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "So in machine learning problem, minimizing the two main source of error simultenously does not allow the networks to be generalised very easy. \n", 
      " \n", 
      "If bias increase, variance decrease. And vice versa also holds.\n", 
      "\n", 
      "1. Bias tells us how close we are to the true value! \n", 
      "2. Variance tells us how they vary for different data set. \n", 
      "\n", 
      "So this is a standard problem in NN"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "High value of bias means netowrk is unable to learn the data whereas higher variance means its difficult to learn the training data successfully."
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "It is refers to the problem of tryning to mantain a balance between two causes of errors in learning algorithms such that the network is able to generalize data beyong that used for training. Namely the bias error and the variance error. Having a high bias error may cause the network to miss important features in the training data, which leads to underfitting. High variance will make the network to memorize noise present in the training data rather than learning features, which lead to overfitting.\n"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "+ One cannot optimize simultaneously the learning algorithm both for learning maximum variance in the data and learning localization which can be termed as bias."
     ], 
     "points": 0
    }, 
    {
     "answer": [], 
     "points": 0
    }, 
    {
     "answer": [
      "The Bias Variance Dilemma tells us that the bias (the difference between the actual and desired output) and the variance (output difference between each trial) cannot be decreased at the same time. A complex model results in small variance and larger variance."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "You have to to a tradeoff between high bias or high variance. You cannot have both. High vaiance means the model is overfitting the data and therefore the variance on input can be quit hight. High bias means the model is generalization is to unspecific. "
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "The Bias is defined as the grade of correctness that a learning algorithm will use. The Variance is defined as the grade of flexibility that the algorithm have given a model to learn. When having the Bias high, but the Variance low, the algorithm will not be flexible into data and will discard any data is not exactly the data that fits into the model. On the other hand, when having the variance high but the bias low, the algorithm will be very flexible into the data and will accept any error data as part of the model to learn."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "When adapting the parameters of a network we can either have a small bias or a small variance. If we have a small bias the approximation of the network is close to the real one, but the variance between trials is very high. If we have a low variance, the bias can't be minimized and the network has a bigger error between the ap\u00fcproximation and the real value. "
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Bias Variance dilemma is coming from the fact that you can not have both at the same time. Your network can not be equally great at outputing with extremely high accuracy extremely hight amount of variables. Therefore you need to find balance between the two that suits needs of your neural network."
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "When training a model on a limited training data set, we must decide wether we accept a biased model which makes assumptions about the test data, but has a better performance on the train data, or a model with more variance which might model the entirety of the data better but be prone to data noise. Usually we have to decide on a trade off between the two, where we may select well balanced models based on VC dimensions or Cross validation results. "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Bias and variance are both undesirable to the learning. Bias defines how far the generated output differs from the true value. Variance defines how much the o/p change on changing the input dataset. However, in most cases, it is only possible to decrease one at the expesne of other. Thus, it is called  Bias Variance Dilemma."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Bias Variance dilemma is used to analyse the generalization error of the algorithm. \n", 
      "If the value of Bias is very high, then network does not learn relations between features and outputs correctly(overfitting)\n", 
      "If the value of variance is very high, then network may model the random noise, and it does not learn intended ouputs(underfitting)\n", 
      "\n", 
      "We have to to tradeoff between Bias and Variance so that our model can generalize properly"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "In machine learning, a choice always needs to be made for the tradeoff between bias and variance. Bias determines how close the result is to the true value and variance determines the sensitivity to flutuations in the training dataset. If bias is reduced variance increases and vice versa. So an optimum tradeoff needs to be chosen which presents a dilemma."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "The bias is the error we make in the assumption by creating the learning machine (how much we we are away from the actual truth)\n", 
      "\n", 
      "the variance is how much the learning machine changes with different training data sets.\n", 
      "\n", 
      "if we have a high bias we habe a low variance and if we habe a low variance we habe a high bias\n", 
      "\n"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Usualy only one of Bias and Variance can be minimized. In an RBFN for example  \n", 
      "few kernels with greater width leads to a high bias but a low variance. If you choose many kernels with smaller width the bias is low but the variance is high. Higher complexity models need more training data."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "Ideally bias and variance would be 0 after learning a machine. However, bias and variance counteract eachother: when bias decreases, variance rises and respectively in the other direction. This leads to the dilemma that either one of the values has to be present."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "Bias variance dilemma refers to the problem of minimizing the two sources of error bias errror and variance error simultaneously which creates probblem in generaliztion of the network.\n", 
      "Bias error: It is the error that occurs while setting the parameters of the network\n", 
      "variance error:It refers to how sensetive the network is to the fluctuations in the dataset."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Bias and variances are the estimation errors.\n", 
      "\n", 
      "Bias corresponds to the inability of the learning machine to appropriately approximate the function to be learnt. Hence this induces a deviation from the actual function\n", 
      "\n", 
      "Variance is the inadequacy of the training data to allow the a learning machine to succesfully learn the function. \n", 
      "\n", 
      "The dilemma is that , to completely learn the actual function( to reduce variance-related error), the training data required should consist of infinite samples. However, this resuts in slower convergence, inturn, bias error increases.\n", 
      "\n", 
      "Therefore trade of between both the errors need to be made."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "- Bias: the bias is the differnce between the predicted value and the desired value in the generalization run\n", 
      "- Variance: is the inadequity in the produced value in the regression and the desired value that we expect from the network"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "Bias is the difference between the predicted and true value. Variance is the range of several predicted values of the same datapoint. It is desirable to have low bias and low variance to ensure the predicted value is consistently close to the true value. The Bias Variance dilemma is that to achieve low bias, the variance becomes high and vice versa. Hence, there is always a tradeoff between the two."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE"
     ], 
     "points": 0
    }
   ]
  }, 
  {
   "qid": 18, 
   "question": "Give the main properties of a SOM!", 
   "answers": [
    {
     "answer": [
      "YOUR ANSWER HERE: Self organizing maps use unsupervised learning by combing the competitive learning principle with the topological structure of the network.\n", 
      "\n", 
      "Properties of SOM:\n", 
      "- Competition: The neurons in the SOM compete against each other to be the winning neuron. The neuron with the maximum value for a user defined discriminant function is the winner neuron.\n", 
      "- Correlation: The neighborhood of the winner neuron is determined by the distance of the neighboring neurons from the winning neuron which shows the correlation among them\n", 
      "- Updation: The weights of the winning neuron and the neurons in the neighborhood of the winning neuron are updated"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "[--] this\n", 
      "\n", 
      "it is unsupervised \n", 
      "\n", 
      "winning neuron takes it all\n", 
      "\n", 
      "uppdating the weights of neuron also effect the local neihbour hood of that neuron.\n", 
      "\n", 
      "Its competitve nature\n", 
      "\n", 
      "cooperation\n", 
      "\n", 
      "adapatation."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE\n", 
      "\n", 
      "\n", 
      "The main properties of SOM are,\n", 
      "\n", 
      "* Compition: To find the winning neuron\n", 
      "* Cooperation: To find the neighbours of the winning neuron to make weight adjustments\n", 
      "* Adoptation: Change the distance for the neighbourhood function $\\sigma$ and learning rate $\\eta$\n", 
      "\n", 
      "$\\sigma_n = \\sigma_0 * e^{\\frac{-n}{T_1}}$\n", 
      "\n", 
      "$\\eta_n = \\eta_0 * e^{\\frac{-n}{T_2}}$\n", 
      "\n", 
      "$T_1$ and $T_2$ are constants"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "- The input layer is fully connected to the map layer\n", 
      "- There is a distance function for all neurons in the map defined\n", 
      "- Within the map competitve learning is used to find the best neuron for each input\n", 
      "- A neighborhood size needs to be defined so that the weights of all neurons within the neighborhood of the winning neuron are changed towards the input\n", 
      "- The neighborhood size and the learning rate should be reduced gradually\n", 
      "- The goal is that similar input should have near winning neurons"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "1. it has two layers including input layer and map layer\n", 
      "2. based on competitive learning, only winning neuron and its neighbors weight vectors are updated\n", 
      "3. Weight vector of winning neuron is most similar to input data\n", 
      "4. adjacent neurons tend to have similar weights\n", 
      "5. provides a good approximation of input data"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "+ SOMs are unsupervised learning algorithms.\n", 
      "+ Self-organization of weights\n", 
      "+ learns topological mapping between the input neurons.\n", 
      "+ Modelled after visual cortex of the brain."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "SOM stands for Self Organizing Map. SOMs are a NN model for unsupervised learning, which combine competitive learning principles with a topological structuring of neurons such that adjacent neurons tend to have similar weight vectors."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "A SOM learns a task in an unsupervised manner. The neurons of the inital network are arranged in a topological order"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "SOM use unsupervised learning for mostly pattern recognition problems. The structure of a SOM ist:\n", 
      "- An input layer\n", 
      "- A map layer that can be 1, 2 or multiple dimensional (although in general 2 or 3D map layers are used).\n", 
      "- Each input neuron is connected to each map layer connection\n", 
      "\n", 
      "The learning goes as follows:\n", 
      "- The distance (euclidean) is used to calculate the winner neuron, where the winner will be the one that have the most similar weights with the input data.\n", 
      "- The winner and a defined neighborhood will be updated. The other neurons' weights remain the same as the previous iteration.\n", 
      "\n", 
      "The strategy of the neighborhood size is to start with a large number of neurons and reducing the number through the iterations. The same strategy is applied to the learning rate (big value and reducing it through the iterations)."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Self organising maps are able to produce classes for data on their own, without supervision. Use 3 main steps (competition, cooperation, adaptation). Structure of a hidden layer is fully connected (grid style for 2d, lettuce style in 3d). Works great for travelling saleseman problem."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "SOMs are unsupervised learning methods, expressing properties of input patterns in their spatial location and their strenght in activation in that point. Just like the human brain, different areas of the SOM map are thus specialized for different input features, which then can be visualzed in a map."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "- Unsupervised\n", 
      "- Competitive learning\n", 
      "- Topological structure of the hidden nodes\n", 
      "- There are three layers:\n", 
      "    - Input layer\n", 
      "    - Hidden layer (which may be 1-D, 2-D or 3-D map)\n", 
      "    - Output layer\n", 
      "- Weights in the same neighbourhood maps to similar features. For example in case of the travelling salesman problem, nearby nodes may refer to being nearby in euclidean distance.\n", 
      "- Three stages of learning:\n", 
      "    - Competion\n", 
      "    - cooperation\n", 
      "    - weight adaptation\n"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "[---]\n", 
      "\n", 
      "SOMs are neural network that uses unsupervised learning by modelling the structure hidden in the data. There is no any additional information about labellings. \n", 
      "\n", 
      "It is combination of competitive learning and topological neurons such that adjusted neurons have similar weight vectors. \n", 
      "\n", 
      "There are three main processes:\n", 
      "\n", 
      "i. Competitive: Neurons compete among themselves, each time only one neuron is activated. We determine this, by computing euclidean distance between input vector and weight vector of all neurons in map layer. Neuron that has minimum euclidean distance to the input vector is considered as winner.  \n", 
      "\n", 
      "ii. Cooperation: In this, we take the neighborhood neurons of the winning neuron\n", 
      "\n", 
      "iii. Weight Updation: Here, we adjust the weights of neibhorhood neurons"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE A SOM consists of a grid within neurons are located. Another important propertie is neighborhood function. Neighborhood function decreases over time and when distance from winning neuron increases. So only weights of neurons close to winning neurons are strengthened. Moreover in the first step of SOM weights are randomly initialized."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "- number of nodes\n", 
      "- neightbour function (what are the neightbours of node i), if gaussian $\\sigma$\n", 
      "- distance function (distance between nodes)\n", 
      "- learning rate\n", 
      "- optinal: modifier for learning rate and neightbour function $\\sigma$"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "A Self Organizing Map is an ANN for unsupervised learning, there we want to find patterns in the given dataset. We use competetive learning and adjacent neurons have simulare weights.   "
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "SOMs have one hidden layer where the neurons are topologically connected to their neighbours in a 1/2/3D grid like fashion.\n", 
      "\n", 
      "SOMs learn in an unsupervised fashion via winner takes all competitive learning."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "1. Unsupervised learning algorithm\n", 
      "\n", 
      "2. Clusterers data into natural group \n", 
      "\n", 
      "3. Competitive learning rule\n", 
      "\n", 
      "4. Three phases : Competition, cooperation, organization\n", 
      "\n"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "SOM is supervised learnign algorithm and finds spatial patterns in the data without external help.\n", 
      "It has two layers:\n", 
      "Input layer: which is connected to all the networks in the layer\n", 
      "Output layer: which is 1 dim, 2 dim or 3 dim map of neighbouhood relations.\n", 
      "It has three properties:\n", 
      "Competition:It takes between the neurons to find the best match\n", 
      "Co-operation: The winning neuron is in the center of the topological neighborhood of co-operating neurons\n", 
      "Adaptation:\n", 
      "ordering phase: $eta_0 = 0.1$\n", 
      "\n", 
      "$h_ji(x) = high$\n", 
      "convergence phase: $eta_0 = 0.01$\n", 
      "\n", 
      "$h_ji(x) = contains only few neighbours$"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "[--]\n", 
      "\n", 
      "Properties:\n", 
      "\n", 
      "1) input space should be comprised of continuous arbitrary vectors\n", 
      "\n", 
      "2) The ouput space should be a topologicaly ordered discrte output features\n", 
      "\n", 
      "3) The learning rate and width are time dependant\n", 
      "\n", 
      "4) Neighbourhood function is be defined by euclidean disctance and is translationaly invariant "
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "- A fully connected input layer\n", 
      "- A 1 or 2 or 3 dimensional output layer\n", 
      "- A predefined method for defining the selected neurons neighborhood(such as a gaussian distribution)\n", 
      "- A method for learning( changing weights of the selected and neighbors weights)"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "1. It is an unsupervised learning algorithm\n", 
      "2. It is based on the concept of competitive learning\n", 
      "3. The network has a topological structure representative of the distribution of data in input space"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "[--] \n", 
      "1. A SOM is neural network model for unsupervised learning that uses a competetive learning principle to adust the weight vectors in such a way that the adjacent neurons have similar weights. \n", 
      "2. SOMs usually start with with a large neighbourhood that usually consists of almost all the neurons in the network, and shrinks gradually during the learing process.\n", 
      "3. The learning process causes a topological arrangement of neigbourhood neurons that resembles the input training examples."
     ], 
     "points": 2
    }
   ]
  }, 
  {
   "qid": 19, 
   "question": "Enumerate all learning rules, which you know!", 
   "answers": [
    {
     "answer": [
      "YOUR ANSWER HERE: Learning rules:\n", 
      "- Error correction learning\n", 
      "- Memory based learning\n", 
      "- Hebbian learning\n", 
      "- Competitive learning\n", 
      "- Boltzmann learning"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "[--] This\n", 
      "\n", 
      "1) Error correction learning rule\n", 
      "\n", 
      "2) Hebbian Learning rule\n", 
      "\n", 
      "3) Widrow-Hoff learning rule\n", 
      "\n", 
      "4) Cost minimization learning rule\n", 
      "\n", 
      "5) Boltzman Learning rule\n", 
      " "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Learning rules:\n", 
      "1. Memory based learning.\n", 
      "2. Error based learning\n", 
      "3. Hebbian Learning\n", 
      "4. Competitive Learning\n", 
      "5. Boltzman Learning"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE\n", 
      "\n", 
      "The learning rules are,\n", 
      "* Error correction\n", 
      "* Hebbian learning\n", 
      "* Compititive learning\n", 
      "* Boltzman learning"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "1. Error based learning rule\n", 
      "2. Memory based learning rule\n", 
      "3. Hebbian learing \n", 
      "4. Bolzmann learning\n", 
      "5. Competitive learninng "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Single layer learning :\n", 
      "\n", 
      "1. Error correction\n", 
      "2. Competitive learning\n", 
      "3. memory based learning\n", 
      "4. boltzmann model\n", 
      "5. Hebbs rule\n", 
      "\n", 
      "Learning as optimization:\n", 
      "\n", 
      "1. Gradient descent \n", 
      "2. Newton\n", 
      "3. Gauss newton\n", 
      "4. Least mean Square\n", 
      "\n"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "- Error correction rule\n", 
      "- Memory based learning\n", 
      "- Hebbian learning\n", 
      "- Boltzmann learning\n", 
      "- Competitive learning"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "* Error correction (Least mean square)\n", 
      "* Memory based learning (K nearest neighbors)\n", 
      "* Competitve learning\n", 
      "* Hebbian learning\n", 
      "* Boltzman machine learning"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "There are 5 learning rules:\n", 
      "1. Delta rule or Widdrow Hoff's rule\n", 
      "2. Hebbian rule\n", 
      "3. Competitive learning\n", 
      "4. Memory based learning\n", 
      "5. Boltzmann learning"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "1. Error correction learning. \n", 
      "2. Hebbian learning. \n", 
      "3. Memory based learning. \n", 
      "4. Competitve learning. \n", 
      "5. Boltzmann learning. "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "* Error-correcrtion learning\n", 
      "* Memory based learning\n", 
      "* Hebbian learning\n", 
      "* Competitive learning\n", 
      "* Botltzmann learning"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "1.Error correction learning\n", 
      "2.Memory-based learning\n", 
      "3.Hebbian learning\n", 
      "4.Competitive learning\n", 
      "5.Boltzmann learning"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "- Error correction learning rule\n", 
      "- Memory based learning\n", 
      "- Hebbian learning\n", 
      "- Competitive learning\n", 
      "- Boltzman learning"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "* Error Correction\n", 
      "* Memory Based Learning\n", 
      "* Hebbian Learning\n", 
      "* Competitive Learning\n", 
      "* Boltzmann Learning"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "1. Error correction learning rule\n", 
      "\n", 
      "2. Memory-based learing rule\n", 
      "\n", 
      "3. Hebbian learning rule\n", 
      "\n", 
      "4. Competition learing rule\n", 
      "\n", 
      "5. Boltzmann learning rule"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "- memory based learning\n", 
      "- boltzmann learning\n", 
      "- error correction learning\n", 
      "- hebbian learing\n", 
      "- competitive learning"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "- Error-correction learning rule\n", 
      "- Hebbian rule\n", 
      "- Regression learning rule\n", 
      "- Memory based learning rule\n", 
      "- Supervised and unsupervised learnung rules"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "1. Error-correction learning\n", 
      "2. Memory based learning\n", 
      "3. Hebbian learning\n", 
      "4. Competitive learning\n", 
      "5. Boltzman learning"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Boltzmann learning, competitive learning, error correction learning, supervised learning, unsupervised learning"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Error correction learning, Hebbian learning, competetive learning, memory based learning"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "1. Error correction (or Widrow hoff or delta rule)\n", 
      "2. Memory based learning\n", 
      "3. Hebbian learning\n", 
      "4. Boltzmann learning\n", 
      "5. Competitive  learning"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "[---]\n", 
      "\n", 
      "There are five learning rules:\n", 
      "\n", 
      "i. Error correction learning rule\n", 
      "\n", 
      "ii. Memory based learning\n", 
      "\n", 
      "iii. Hebbian learning \n", 
      "\n", 
      "iv. Competitive learning\n", 
      "\n", 
      "v. Boltzman learning "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE Hebb Learing rule, positive error rule, negative error rule, Widrow-Hoff learning rule"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "**Answer 1:**\n", 
      "\n", 
      "Learning rules:\n", 
      "\n", 
      "1. Error correction learning.\n", 
      "2. Memory based learning.\n", 
      "3. Hebbian learning.\n", 
      "4. Competetive learning.\n", 
      "5. Boltzmann learning."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "- similar classes activate similar regions of neurons\n", 
      "- different classes activate different regions of neurons\n", 
      "- important classes activate a large number of neurons\n", 
      "- unimportant classes activate a small number of neurons"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "- error correction learning\n", 
      "- memory based learning\n", 
      "- hebbian learning\n", 
      "- competetive learning\n", 
      "- boltzman learning"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Widrow-Hoff  \n", 
      "Hebbian Learning  \n", 
      "Memmory Based learning  (k-means for exapmle)  \n", 
      "bolzmann learning\n"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "1) similar inputs should result in similar outputs\n", 
      "2) different inputs should result in widely different outputs of the NN\n", 
      "3) many neurons should be involved by an important feature\n", 
      "4) prior information should be built in the architecture"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "- Error correction learning\n", 
      "- Memory based learning\n", 
      "- Competitive learning\n", 
      "- Hebbian learning\n", 
      "- Boltzmann learning"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "1. Supervised learning\n", 
      "\n", 
      "2. Unsupervised learning\n", 
      "\n", 
      "3. Reinforcement learning\n"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The learning rules are:\n", 
      "-Error correction learning\n", 
      "\n", 
      "-Memory based learnig\n", 
      "\n", 
      "-Hebbian learning\n", 
      "\n", 
      "-Competitive learning\n", 
      "\n", 
      "-Boltzmann learning\n"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "[--]\n", 
      "\n", 
      "Error correction rule\n", 
      "\n", 
      "Memory based rule\n", 
      "\n", 
      "Competitive learning\n", 
      "\n", 
      "Boltzman learning\n", 
      "\n", 
      "Hebbian learning"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "- Delta rule\n", 
      "- Hebbian rule\n", 
      "- Competetive rule\n", 
      "- Boltzman rule\n", 
      "- Memory based rule"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "1. Error correction (delta) learning\n", 
      "2. Memory based learning\n", 
      "3. Competitive learning\n", 
      "4. Boltzmann learning\n", 
      "5. Hebbian learning"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "[--] \n", 
      "\n", 
      "1. Error- Correction learning rule\n", 
      "2. Memory based learing rule\n", 
      "3. Hebbian Learning rule\n", 
      "4. Competitive learning rule\n", 
      "5. Boltzmann Learing rule"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Error-correction learning, competetive learning, hebbian learning, boltzman learning, statistical learning."
     ], 
     "points": 2
    }
   ]
  }, 
  {
   "qid": 20, 
   "question": "Define sigmoid functions and give at least two examples.", 
   "answers": [
    {
     "answer": [
      "YOUR ANSWER HERE:\n", 
      "\n", 
      "- Sigmoid functions are type of activation functions which are strictly increasing.\n", 
      "- Sigmoid function is given by \n", 
      "\n", 
      "$\\psi (x) = \\frac{1}{1 + \\exp (-x)}$\n", 
      "\n", 
      "- Logistic function is an example for sigmoid function "
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "[--] this\n", 
      "\n", 
      "Signmoid funtion is stricly positve and differentail. it is used as activion funtion . it given by\n", 
      "\n", 
      "1/(1+exp(-av).\n", 
      "\n", 
      "sigmiod funtion is used in Multiperecetron learning . "
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Sigmoiod function is a type of activation function used in ANN which has charecterisctic which balances linear and non-linear models effectively. It can be written as:\n", 
      "$$\\phi(v)= \\frac{1}{1+exp(-av)}$$\n", 
      "\n", 
      "In another form it can also be written as\n", 
      "$$phi(v) = \\frac{v}{1+v^2}$$"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "$\\phi(V) = \\frac{1}{1-exp(-a*V)}$, where V is local field, and $a$ is constant parameter that define shape of sigmoid function. This function is used in for example in backpropagation method for MLP NNs. There, along original sigmoind function, derivatiive of this function is also used: $\\theta(V)^{'} = \\theta(V)*(1-a*\\theta(v)$ "
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "$f(x) = \\frac{1}{1 - e^{- a * x}}$\n", 
      "\n", 
      "$a$ is a parameter of the sigmoid function. The output of the function will always be between 0 and 1. The parameter determines the steepness of the function.\n", 
      "\n", 
      "Two examples:\n", 
      "\n", 
      "$f(x) = \\frac{1}{1 - e^{- 2 * x}}$\n", 
      "\n", 
      "$f(x) = \\frac{1}{1- e^{- 3 * x}}$"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "* Sigmoid function is a strictly increasing function that exhibits a graceful balance between linear and non-linear behaviour.\n", 
      "* Importantly it is diffentiable\n", 
      "* Two types,\n", 
      "* Logistic function\n", 
      "* Tangent function"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Sigmoid function is a combination of linear and non linear behavior. they are strictly increasing functions.\n", 
      "\n", 
      "$\\phi(v) = \\exp(\\frac{1}{1+av})$\n", 
      "\n", 
      "Logistic function is an example of sigmoid function.\n", 
      "\n", 
      "$\\phi(v) = log(\\frac{\\exp(v) + \\exp(-v)}{\\exp(v) - \\exp(-v)})$\n", 
      "\n", 
      "\n", 
      "\n"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Sigmoid function are an activation function which is non linear. \n", 
      "They are in the form ${{1}/{1+e^{-av}}$. They are continuously differentiable. They are used in back propogation as well as in radial basis function "
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "It is a strictly increasing function which has a balance between linear and non-linear behaviour. e.g. logistic function $h (v) = 1/(1+exp(-av)) $, another is tanh function."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "the sigmoid function is an s shaped real value function that incorporates linear and nonlinear behavior. the two examples of sigmoid functions are the logistic function and the hyperbolic tangent.\n", 
      "\n", 
      "$\\phi(v) = \\frac{1}{1 - exp(-av)}$\n", 
      "\n", 
      "$phi(v) = tanh(v)$"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Sigmoid function is given by:\n", 
      "$$ \\sigma(x) = \\frac{1}{1+e^{-x}}$$\n", 
      "\n", 
      "+ Sigmoid is strictly positive and infinitely differentiable. Thus is used as activation function in artificial neurons $$ \\sigma(\\sum_i w_i x_i) = \\frac{1}{1+e^{-\\sum_i w_i x_i}}$$\n", 
      "\n", 
      "+ Sigmoid maps input values to $[0,1]$ and thus is used to normalize the input such that they can be used as probability measures."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "In general a sigmoid function is real valued, monotonic, and differentiable having a non-negative first derivative, which bell-shaped. A sigmoid function is constrained by a pair of horizontal asymptotes as x goes to either plus or minus infinity."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "The sigmoid function is \n", 
      "$$ \\phi(x) = \\frac{1}{1 + e^{-ax}} $$\n", 
      "\n"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "sigmoid functions are non-linear functions which are s shaped. \n", 
      "- 1/1+exp^-av\n", 
      "- tanh()"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Sigmoid functions are a type of functions used normally as activation functions in Neural Networks that have a non-linear behavior, making them more powerfull. Two examples can be:\n", 
      "\n", 
      "$\\phi = \\frac{1}{1 - e^{x}}$\n", 
      "\n", 
      "\n", 
      "$\\phi = tanh(x)$"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Sigmoid functions are able to produce very well ballanced output in terms of linearity and non-linearity.\n", 
      "\n", 
      "For example:\n", 
      "$\\frac{1}{1+(exp(-av)}$, where v is local field, a constant\n", 
      "\n", 
      "and tangent hyperbolic"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Sigmoid functions (in NN) are activation functions which have an S shape, saturating towards their minimum and maximum values. Two examples are the sigmoid and the tanh activation functions. Considering that function values converge against 1 or 0 or -1 in the above examples, many activations & multiplications lead to the vanishing or exploding gradient problem in deep neural nets, for which the ReLu performs better."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Sigmoid functions are differntiable squashing functions with exponential of hyperbolic behaviour dependinf on the input.\n", 
      "\n", 
      "Examples:\n", 
      "- $\\phi(v)={\\frac{1}{1-e^{-av}}}$\n", 
      "- $\\phi(v)=tanh(v)=\\frac{e^v-e^{-v}}{e^v+e^{-v}}$"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "[---]\n", 
      "\n", 
      "Sigmoid function is strictly increasing function that exhibits the behavior of linear and non-linear.\n", 
      "\n", 
      "Examples: \n", 
      "\n", 
      "1 . Sigmoid = $ 1 / 1 + exp(-av)$   ,  v is local field and a is constant parameter \n", 
      "\n", 
      "\n", 
      "2 . Tangent hyperbolic = $$ e^{-av} - e^{av}/ e^{-av} + e^{av}   $$"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE $f(x) = exp(1/a*x)$. a denotes slope of f, if a is made infinitive large f take only value 1 and 0. One example of sigmoid function is Mc Culloch Pitch (slope is $\\frac{1}{2}$ neuron operates only in linear region of activation function )"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "$sigmoid(v) = \\frac{1}{1-e^{-av}}$\n", 
      "\n", 
      "$sigmoid(10000) = 1$, a = 1\n", 
      "\n", 
      "$sigmoid(-10000) = 0$, a = 1"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "A sigmoid function is a function that increases monoton and has a graceful balance between linear and nonlinear behavior. \n", 
      "\n", 
      "\n", 
      "example 1:\n", 
      "$f(x)=\\frac{1}{1+ e^{-a*x}}$\n", 
      "\n", 
      "example 2:\n", 
      "hyperbolic tanges $\\tanh(x)$"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Sigmoid functions are one type of activation functions. The range is between 0 and 1. The are smooth and continous differentiable. Examples are logistic function and tangent hyperbolic (range from -1 to 1)."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Sigmoid functions are S-shaped functions that converge to a value on either side. In the middle the function jumps from the one value to the other with a slope based on additional parameters.\n", 
      "\n", 
      "- hyperbolic tangent tanh(x)\n", 
      "- sigmoid function 1/(1-exp(x))"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Sigmoid function is strictly increasing nonlinear function which shows a unique balance between linear and nonlinear properties. \n", 
      "\n", 
      "e.g.\n", 
      "\n", 
      "1. Logistic function \n", 
      "\n", 
      "2. Hyperbolic tangent function  $\\frac{e^{-ax} - e^{ax}}{e^{-ax} + e^{ax}}$"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Sigmoid function is given by\n", 
      "$phi(v) = 1/1+exp(-a*v))$"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Sigmoid function is the most common function being used as the activation function in the NN and one reason for this is it is derivable which is very important for the Back propagation method.\n", 
      "$$\\frac{1}{1-e^{av}}$$\n", 
      "\n", 
      "The examples are:\n", 
      "- Sigmoid function as mentioned \n", 
      "- $tan^{-1}$"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Sigmoid functions are monotonically increasing, differentiable functions with a smooth transition between linear and saturated states. Examples are\n", 
      "1. Sigmoid $\\varphi(v) = \\frac{1}{e^{-av}}$\n", 
      "2. Hyperbolic tangent $\\varphi(v) = tanh(v)$"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "[--] \n", 
      "\n", 
      "A sigmoid is defined as strictly increasing function that describes a graceful balance between linar and non-linear behaviour and is given by : $\\phi(v) = \\frac{1}{1+exp(-av)}$\n", 
      "\n", 
      "Another example of a non-linear activation function is the tangent hyperbolic function which is defined as : $\\phi(v) = \\frac{exp(v) - exp(-v)}{exp(v) + exp(-v)}$"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "$sign(x) = \\frac{1}{1 + exp(-ax)}$\n", 
      "\n", 
      "$tanh(x) = \\frac{exp(-ax) - exp(x)}{exp(ax) - exp(x)}$"
     ], 
     "points": 1
    }
   ]
  }, 
  {
   "qid": 21, 
   "question": "Architectures of NNs fall into different classes, which?", 
   "answers": [
    {
     "answer": [
      "YOUR ANSWER HERE: Architectures of Neural networks:\n", 
      "- Single layer feed forward neural networks\n", 
      "- Multilayer feed forward neural networks\n", 
      "- Recurrent neural networks"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "[--] this\n", 
      "\n", 
      "Single layer feed foward : they consist single layer of output neurons. it very simple architecture\n", 
      "\n", 
      "Multi- layer feed forward: it consist feedforward multple Hidden layer of neurons . it computionally little expensive than single layer.\n", 
      "\n", 
      "Recurrent : it is multi-layer but it has the feedback which output of the neuron fed back as input.\n"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Architectures of NN:\n", 
      "\n", 
      "1. Single Layer Perceptron Network\n", 
      "2. Multi Layer Perceptron Network\n", 
      "3. Recurrent Network"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE\n", 
      "\n", 
      "* Single layer feed forward network\n", 
      "* Multi layer feed forward network\n", 
      "* Recurrent neural network"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "1. Single layer feedforward NN\n", 
      "2. Multy layer feedforward NN\n", 
      "3. Recurrent NN"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "1. Single layer - has only one hidden layer. eg: perceptron \n", 
      "2. Multiple layer - has multiple hidden layer . eg: convolutional networks, multi layer perceptron\n", 
      "3. recurrent - The nodes are connected to themselves with a unit function $Z^{-1}$"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "- Single layer feed forward\n", 
      "- Multi layer feed forward\n", 
      "- Recurrent netowrks"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "* Single layer feed forward architecture\n", 
      "* Multi layered feed forward architecture\n", 
      "* Recurrent architecture"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "There are three classes:\n", 
      "1. Single feedforward neural network\n", 
      "2. Multilayer feedforward neural network\n", 
      "3. Recurrent neural network"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The three architectures: \n", 
      "\n", 
      "1. Feed forward. Single layer\n", 
      "2. Feed back. Multi layer\n", 
      "3. Recurrent neural networks. "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "* Single layer feedforward network\n", 
      "* Multilayer feedforward network\n", 
      "* Recurrent neural networks\n", 
      "* Convolutional neural networks"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "1. single layer feedforward\n", 
      "2. multilayer feedforward\n", 
      "3. Recurrent Neuron network"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "- Single layer network\n", 
      "- Multiple layer network\n", 
      "- Recurrent network"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "+ Single layer NN : input-output direct mapping\n", 
      "+ Multilayer NN: 1 or more hidden layers\n", 
      "+ Recurrent NN: at least one feedback connection"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "* Single-Layer Feedfoward Networks\n", 
      "* Multilayer Feedforward Networks\n", 
      "* Recurrent Networks"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "1. Single layer feedforward\n", 
      "\n", 
      "2. Mult-layer feedforward\n", 
      "\n", 
      "3. Recurrent"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "- Sigle layer feed forward NN\n", 
      "- Multi Layer feed forward NN\n", 
      "- Recurrent NN"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "- Single layer neural network\n", 
      "- Multiple-layer neural network\n", 
      "- Recursive neural network"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "1. Single layer feedforward\n", 
      "2. Multi layer feedforward\n", 
      "3. Recurrent Networks"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Architecture of neural networks are:\n", 
      "\n", 
      "1.Single layer networks (only input and output layers)\n", 
      "\n", 
      "2.Multi-layer networks (have at least one hidden layers)\n", 
      "\n", 
      "3.Recurrent (have feedbacks in their structure)"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Feed forward NN, Recurrent NN"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "- Supervised\n", 
      "- Unsupervised"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "[---]\n", 
      "\n", 
      "There are three different classes of architectures:\n", 
      "\n", 
      "i. Single layer neural network\n", 
      "\n", 
      "ii. Multiple layer neural network\n", 
      "\n", 
      "iii. Recurrent neural network"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "**Answer 2:**\n", 
      "\n", 
      "Three classes of NN architecture:\n", 
      "\n", 
      "1. Single layer feedforward network.\n", 
      "2. Multi layer feedforward network.\n", 
      "3. Recurrent network."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "- Feedforward NNs: Basically a directed acyclic graph. No backward connections between layers are allowed. Also means the network is stateless and has no memory\n", 
      "  - Radial basis function networks\n", 
      "  - Self ordering maps\n", 
      "- Recurrent NNs: all kinds of connections are allowed, has memory\n", 
      "  - Echo state networks\n", 
      "  - Convolutional neural networks\n", 
      "  - Reduced Bolzmann machines"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "the architectures are:\n", 
      "\n", 
      "-single layer feedforward\n", 
      "\n", 
      "-multy layer feedforward\n", 
      "\n", 
      "-recurrent neural networks "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "single layer feedforward networks\n", 
      "multi layer feedforward networks\n", 
      "recurrent networks"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "- Single Layer Feedforward NNs\n", 
      "    - Single layer perceptron\n", 
      "    - Radial basis functions\n", 
      "    - Support vector machines\n", 
      "- Multi Layer Feedforward NNs\n", 
      "    - Multi layer perceptron\n", 
      "- Recurrent NNs\n", 
      "    - ESN"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "1. Single layer feedforward NN\n", 
      "\n", 
      "2. Multilayer feedforward NN\n", 
      "\n", 
      "3. Recurrent NN\n"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The classes are:\n", 
      "Single layer feedforward nn,Multilayer feedforward and recurrent neural networks\n"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Two main classes:\n", 
      "    - Feed forward network\n", 
      "    - Recurrent network"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "1. Single layer Feed Forward (FF)\n", 
      "2. Multilayer FF\n", 
      "3. Recurrent networks"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "[--]\n", 
      "\n", 
      "Architectures of NNs can fall into the following classes:\n", 
      "1. Single layer feed forward networks\n", 
      "2. Multilayer feed forward networks\n", 
      "3. Recurrent networks"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Single layer feedforward networks, multilayer feedforward networks,recurrent neural networks."
     ], 
     "points": 2
    }
   ]
  }, 
  {
   "qid": 22, 
   "question": "What do we understand by weight sharing?", 
   "answers": [
    {
     "answer": [
      "YOUR ANSWER HERE:\n", 
      "- Weight sharing means that the synaptic links are assigned the same weight i.e., there is only one weight vector that is shared.\n", 
      "- If there is a change in that weight vector, all the connected synaptic links will be effected."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "[--]this\n", 
      "\n", 
      "means that when some neuron weights are changed then wieghts of the neurons in the its local neibhorhood gets changed as well."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE\n", 
      "\n", 
      "In case of weight sharing all the neurons in a layer uses the same weight value."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "All the neurons are connected with the same value of wieght to the next layer of neuron. By this the number learning parameters can drastically reduced. They are mostly used in convolutional neural networks. "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Weight sharing means that the same weight is used for some neurons. This saves computation time and memory and makes the network simpler."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Weight sharing is basically sharing of weight by all the neurons in a particular layer. If the weight changes in one layer, it should change in the other associated layers. So by this number of free parameters that are being used is reduced. "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Weight sharing is a way of putting constraints on weights adjustment. Here same weights are used across different inputs. This is a common technique used in CNN. Same kernel weights are used across all the inputs to generate feature maps."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The weight vector of each neuron is same ."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "It refers to the use of the same sat of weight for a neuron is a layer in order to reduce the number of free parameters."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "If all hidden neurons share the same set of weights for their synaptic connections then we talk about weight sharing."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "It is a way to constrain the structure of a network, such that adjacent neurons have the same weights. It can imporve the efficiency of the network learning."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Using the same weight for multiple neuron connections. Prominent example: Convolution of Kernels in CNN"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Weight sharing is connection type, where the connections (number and value) between two layers will be the same for each neuron."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Usually every neuron will have different weights for the connection with the previous layer, weight sharing is a method, by which the same set of weights is used for every neuron to connect it to the previous layer. This reduces the number of network parameters that have to be adejusted."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Weight sharing is when neurons are getting same weights from neurons that are inputs for them."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "As seen in CNNs, weight sharing is used to both reduce computational complexity, as well as introduce a kind of regularization. As weights are shared for example between spatial locations of a model of a retina, the algorithm is more robust to overfitting."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "It referes to sharing of same weights between different neurons (in the same layer)"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE Weight sharing means that several inputs share a weight. So informations stored in a weight can be shared among inputs."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "If the weights connecting two layers are not seperate for each node combination but instead are used for multiple edges. This reduces number of weights to be trained and thus can reduce time needed for training."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Weight sharing is used for example in CNNs. Some interneuron-connection-groups share the same weights and if one is changed(trained) all change in the same why. This simplifys the network and the training."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Weight sharing means that diffrent neurons share some or all of there weights with other neurons. In CNNs weight sharing is used in the convolution layer by using a kernel."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Weight sharing is used in convolutional NNs. Different convolutional kernels are applied to the input data first. After that we have to compute the weights for each resulting Layer. To reduce computational complexity, the weights are computed and trained once and shared to all layers. "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "[--]\n", 
      "\n", 
      "Weight sharing is sharing of weight parameters among different layers of NN. Shared weights correspond to similarity in the network. They can be used to incorporate prior information or increase the ability to differenctiate between the classes using the evident variances.\n", 
      "\n", 
      "Having similar weight patterns will reduce the number of training samples required, will improve the convergence of the algorithm and hence, improve the performance."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Weight sharing is a technique to include prior knowledge in the network architecture. In this, the neurons in a layer share the same weights. It has the additional advantageous side effect of decreasing the number of parameters."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "When multiple neurons share the same weight it is called weight sharing. When the shared weight is updated it is updated for every neuron, which uses the weight."
     ], 
     "points": 2
    }
   ]
  }, 
  {
   "qid": 23, 
   "question": "Write down and explain Hebb's rule!", 
   "answers": [
    {
     "answer": [
      "YOUR ANSWER HERE: Hebb's rule:\n", 
      "- When the neurons on either side of the synapse are excited synchronously, then the weight of the synapse is increased accordingly.\n", 
      "- When the neurons on either side of the synapse are excited asynchronously, then the weight of the synapse is decreased accordingly."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "[--]this\n", 
      "\n", 
      "Hebbs rule says. \n", 
      "\n", 
      "if the two neurons are excited simultansouly then the sysnaptics weights between those neuron gets stronger.\n", 
      "\n", 
      "if the two neuron not get excited togther or if the excited saperate then the sysnaptic weight between those two neuron tends to get weeker (reduced)."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Hebb's rule;\n", 
      "1. If the neurons on both side of a synapse are activated simultaniously (synchronously) the synaptic strength is strenghtend\n", 
      "2. If neurons on both sides of a synapse are activated asynchronously then the synaptic strength is weakend.\n", 
      "The basic idea of Hebb's rule is neurons that wire together fire together"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE\n", 
      "\n", 
      "\n", 
      "If two neurons connected by a synapse is activated synchronously then the wight of the synapse is selectively increased.\n", 
      "\n", 
      "If two neurons connected by a synapse is activated asynchronously then the wight of the synapse is selectively decreased."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "In simple words, Hebbian rule defines that neurons that fire together fire together. In more details: when two neuros that are connected with synapse, are active at the same time (sychronosly), their sinaptic weight is becoming stronger. On another side, then two neurons, that are connected with synapse, are not active at the same time (asychronosly), their sinaptic weight is becoming weaker."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "\n", 
      "THe neurons that wire together fire together.\n", 
      "\n", 
      "Two neurons on either side of the synaptic weight get activated synchronously, then the strength of the synpatic weight is increased selectively.\n", 
      "\n", 
      "Similarly when they get activate asynchronously, then the weight is selectively decreased or not considered."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "\"Neurons which fire together wire together\"\n", 
      "\n", 
      "The weight between two neurons is increased if both show the same behavior for a given input."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "In the network, neurons fire together wire together.\n", 
      "\n", 
      "* If two neurons are activated simultaneously, then the synaptic links between those neurons are strengthend.\n", 
      "* If two neurons are activated asynchronously, then the synaptic links between those neurons are weakend or eliminated."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Hebb's rule:\n", 
      "\n", 
      "1. If 2 Neurons on the either side of the connection are activated synchronously then the strength of the synapse is increased.\n", 
      "2. If 2 neurons on the either side of the connection are activated asynchronously then the synapse is weakend or vanished."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Hebbs rule states that. \n", 
      "\n", 
      "1. It 2 neurons on the either sides of the synaptic links are activated simultenously, then the stength of the synapses increases.\n", 
      "\n", 
      "2. It 2 neurons on the either sides of the synaptic links are activated asynchronously, then the stength of the synapses decreases."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Hebbs rule states that if 2 neuron are fired together then synaptic connections between the 2 should be strengthened, wheras if 2 neurins are fired asynchronously then synaptic ocnnections between the 2 should be weakened. <br>\n", 
      "\n", 
      "$\\nabla W_{ij}$ = $n F(y_{i}, x_{j})$"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Two neurons on either side of a connection are activated simultaneously then the strenths of the connection is increased. Two neurons on either side of a connection are not activated simultaneously then the strenths of the connection is weakened or eliminated. so weight update is based on $w_{kj} (n+1) = w_{kj} (n) + \\eta y_k(n) x_j(n)$, $\\eta$ is learning rate and $y_k(n)$ is output signal at time step n, $x_j(n)$ is input signal at time step n."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "when axon of cell A is close to fire axon of cell B, and consistently participates in firing it, a special mechanism should take place such that, the weights of A as the neuron that fires B, should be increased. In shot, neurons that fire together, wire together."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "+ In short, neurons that fire together wire together.\n", 
      "+ If firing of neuron A is causally related to the firing of neuron B, the the synaptic strength between A and B is increased.\n", 
      "+ In ML, we use symmetric version of Hebb's rule and reduce synaptic strength of neurons that are not causally related to each other."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The Hebbs Rule describes how couplin between neurons (synaptic value) influences and is influenced by the operation performed by a group of neurons. The Hebb Rule is often summarized with the phrase: What wires together, fires togehter."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "The Hebb's learning rule is defined as follows\n", 
      " - When the connection between to neurons is synchronously (if both neurons are active at the same time step), the weight of this connection will be increased.\n", 
      " - When the connection between to neurons is asynchronously (one is active, the other is not), the weight of this connection will be decreased."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Cells that wire together, fire together. Means that the connection between neurons that are activated synchronously is strengthend. There is also the symmetric Hebb's rule, which overcomes the saturation problems with Hebb's rule, by decreasing the connection strength between asynchronously activated neurons."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "According to Hebb's rule:\n", 
      "- Neurons that wire together fire together\n", 
      "\n", 
      "That means, weight is adapted depending on whether or not the neurons that are connected are fired (or not fired) at the same time."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "[---]\n", 
      "\n", 
      "Neurons that wire together, fire together\n", 
      "\n", 
      "If two neurons are activated synchronously, then strength between two neurons is increased\n", 
      "\n", 
      "If two neurons are activated asynchronously, then strength between two neurons is weakend"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE Neurons which fire together wire together. When neurons are activated synchronously their synase are strengthened when neuron are acivated asynchronously their synapses are weakened."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "**Answer 3:**\n", 
      "\n", 
      "Hebb's rule states that if two connected neurons activate synchronously, then the strength of the synaptic weights between them is increased. This eventually could lead to saturation. Thus, the rule was modified and a new condition was added which states that if two connected neurons activate asynchronously, then the strength of the synaptic weights connecting them is diminished or eliminated.\n", 
      "\n", 
      "Simple form: $\\Delta w = \\eta \\cdot y_k(n)\\cdot x_j(n) $\n", 
      "\n", 
      "Covariance form: $\\Delta w = \\eta \\cdot (y_k(n) - y_m) \\cdot (x_j(n) - x_m)$\n", 
      "\n", 
      "where $y_m$ and $x_m$ are mean activations over time."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "That fires together , wires together\n", 
      "\n", 
      "\n", 
      "for example $w_{ij}= learningrate *(x_i*y_j)$\n", 
      "\n", 
      "if two neurons of each end of one synapse fire synchonly every time the synapse weight between them is increased.\n"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "w+1 = w + n * x * y, where x is the input and y the output, n learning rate.\n", 
      "The idea of hebbs rule is that neurons that fire together wire to gether. If the input and the output are both positive or negativ the weight for that neron is increased. If they have diffrent signs the weight is decreased."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "it followes the rule of \"what fires together, wire together\"\n", 
      "if 2 neurons are reacting similar on a stimulus, then increase their synaptic weigth. \n", 
      "If 2 neurons are reactiong different, than eigther keep the weight or decrese "
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "When two connected neurons are activated simultaneously their synapse strength is increased. When they are fired asynchronously the connection is weakened.\n", 
      "\n", 
      "This means that connections that are used together more often are strenghtened, simulating the function of the brain."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "If cell A is near enough to excite cell b and repeatedly takes part in firing by B, then some growth or metabollic change takes place in one or both cells such that A's efficiency in firing B is increased. \n", 
      "\n", 
      "This rule can be interpreted as neurons those fire together wire together. \n", 
      "\n", 
      "Synaptic connection betwwen the neurons which are fired together are strngthened because they are possibly representing the same feature in the data."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "When the axon of cell A is near enough to excite cell B  and repeatatively takes part in firing it , then some metabolic change takes place in one or both the neurons such that the efficiency of A firing B is increased."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "[--]\n", 
      "\n", 
      "Hebb's rule describes the biological learning process of influence of the closeness of two axons on the strength of the synapse. It states that if the two axons have less proximity, then the tendency to fire together increases, and hence the efficacy of one axon to fire the other. Neurons that fire together , wire together. \n", 
      "\n", 
      "It also states that is the neurons do not fire simultaneously, then the strength of the synapse decreases.\n", 
      "\n", 
      "This way, the weights of the connections between neurons can be influenced by the surrounding neurons"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Neurons that fire together, wire together\n", 
      "\n", 
      "\n", 
      "This means that the synaptic weight between two neurons defines the importance of that connection, if the connection has a big weight both neurons react to the input and they represent a common feature."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "The original Hebb's rule states that is two connected neurons activate at the same time, their synaptic weight should be selectively increased. However, this may lead to saturation leading to the introduction of an additional rule. The synaptic weights of neurons that fire asynchronously are selectively reduced or eliminated. This can be summarized by 'neurons that fire together, wire together'"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "[--]\n", 
      "\n", 
      "Hebb's rule is a two part rule that is stated as follows:\n", 
      "1. If two neurons on the opposite side of a synpase are activated synchronously, the synapse in question is successively strengthened.\n", 
      "2. If two neurons on the opposite side of a synpase are activated asynchronously, the synapse in question is successively weakened.\n", 
      "\n", 
      "Such as synapse is termed as hebbian synapse. In simplest form, the Hebb's rule can be stated as fllows in matematical terms: $\\Delta w_{kj} = \\eta x_j(n)y_k(n)$ where $x_j(n)$ and $y_k(n)$ are the presynaptic and postsynaptic signals to neuron k, and $\\Delta w_{kj}$ is the weight adjustment applied to the neuron k. Thus a positive correlation between the presynaptic and postsynaptic signals strengthen the synapse, while a negative correlation between the presynaptic and postsynaptic signals weakens the synapse."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Hebbs rule says that neurons which fire together wire together. This means that when neuron i is activated and neuron j, which is connected to neuron i, is also activated, the connection between those two neuron has to be increased, which means the weight has to be updated. If they are activated asynchronously the weight is decreased. Depending on how the rule is implemented, the strenght can be increases or decreased when both neurons are not fired simultaneously. $w_{new} = w_{old} - learning\\_rate(x - y)$, where x and y are the values of the two neurons. It is also possible to use the mean of the variance $w_{new} = w_{old} - learning\\_rate((x - x_{mean})(y - y_{mean}))$"
     ], 
     "points": 2
    }
   ]
  }, 
  {
   "qid": 24, 
   "question": "Compare pros and cons of RBFs and MLPs", 
   "answers": [
    {
     "answer": [
      "RBF: \n", 
      "\n", 
      "only three layers always- input, hidden and output\n", 
      "\n", 
      "Hidden layer - nonlinear transformation \n", 
      "\n", 
      "output layer - linear transformation \n", 
      "\n", 
      "property of  global aproximation\n", 
      "\n", 
      "local approximator \n", 
      "\n", 
      "They can also be learned in unsupervised manner\n", 
      "\n", 
      "NN: \n", 
      "\n", 
      "can be single or multiple hidden layers\n", 
      "\n", 
      "Hidden layer - linear/ nonlinear transformation\n", 
      "\n", 
      "property of  global aproximation\n", 
      "\n", 
      "global approximator\n", 
      "\n", 
      "they can be learned only in supervised manner\n", 
      "\n", 
      "YOUR ANSWER HERE"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "1. RBF has only one hidden layer, while MLP has one or more hidden layers\n", 
      "2. model of each hidden neuron in RBF is different, while model of each hidden neuron in MLP share the same one.\n", 
      "3. RBF is local approximations to nonlinear input-output mapping, while MLP is global approximations to nonlinear input-output mapping\n", 
      "4. In RBF output layer is linear, while output layer in MLP is usually nonlinear."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "MLPs:\n", 
      "\n", 
      "- One or many hidden layers.\n", 
      "- Nonlinear hidden layer, and linear or nonlinear output layer.\n", 
      "- Argument: scalar product\n", 
      "- Universal approximators\n", 
      "- Global learning\n", 
      "\n", 
      "\n", 
      "RBFs:\n", 
      "- Non linear hidden layer, and linear output layer.\n", 
      "- One hidden layer.\n", 
      "- Argument: distance to center.\n", 
      "- local approximators\n", 
      "- Splitted learning"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "[---]\n", 
      "\n", 
      "RBFs has single hidden layer, while MLPs can have multiple hidden layer\n", 
      "\n", 
      "In RBFs, Hidden layer applies non-linear transformation from input to hidden layer. Hidden layer to output layer transformation is linear. \n", 
      "\n", 
      "In MLPs, hidden or output layer can be non-linear \n", 
      "\n", 
      "In RBFs, agruments to hidden layer is euclidean norm. While In MLPs arguments are scalar products\n", 
      "\n", 
      "RBFs: local approximators  . MLPs: global approximators"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE Pros RBF: Very good in approximating target functions | Cons RBF: High computational effort, as many activation functions as data points "
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "**Answer 4:**\n", 
      "\n", 
      "RBFs:\n", 
      "\n", 
      "1. Single hidden layer and single output layer.\n", 
      "2. Non linear hidden layer and linear output layer.\n", 
      "3. Input is the euclidean distance.\n", 
      "4. Universal approximation property.\n", 
      "5. Local approximators.\n", 
      "6. Splitted learning.\n", 
      "\n", 
      "MLPs:\n", 
      "\n", 
      "1. Single or multiple hidden layers and single output layer.\n", 
      "2. Non linear hidden layer, linear or nonlinear output layer.\n", 
      "3. Input is the scalar product.\n", 
      "4. Universal approximation property.\n", 
      "5. Global approximators.\n", 
      "6. Global learning."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "1. RBF can separate linearly non-separable data by nonlinearly projecting it to higher dimeension. \n", 
      "\n", 
      "2. If all nuber of functions in RBF is equal to data then problem is ill formed and takes lot computing power.\n", 
      "\n", 
      "3. Preprocessing input is needed to reduce BAsis fn.\n", 
      "\n", 
      "3. Training is easier in RBF than the MPL. \n", 
      "\n", 
      "3. In MLP training is "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "RBF has only one hidden layer , MLP's have many hidden layer.\n", 
      "In rbf the hidden layer is non linear and output layer is linear , in mlp it can be either linear or non-linear"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "[--]\n", 
      "\n", 
      "Pros of RBFs:\n", 
      "\n", 
      "They have less number of layers, output is a linear combination of output of sigmoid functions where as trining an MLP is computationally expensive. \n", 
      "\n", 
      "Use euclidean distances in activation function\n", 
      "\n", 
      "Pros of MLP:\n", 
      "They are based on global approximations  where as RBF involve only the local area around the width of basis functions. Hence small changes in the network is passed throughout the network quickly compared to the RBFs.\n", 
      "\n", 
      "Cons of MLP:\n", 
      "MPs use inner product which can be computationally expensive"
     ], 
     "points": 2
    }
   ]
  }, 
  {
   "qid": 25, 
   "question": "What are some principle problems in machine learning? Give explanations!", 
   "answers": [
    {
     "answer": [
      "YOUR ANSWER HERE \n", 
      "- Pattern Association - Given a set of labelled patterns, a distorted or incomplete pattern should be associated with the correct pattern.\n", 
      "- Pattern Recognition: It is the problem of labelling a a test pattern into one of the classes from the labelled data.\n", 
      "- Function approximation: It is problem of finding a approximate function based on the given input-output samples.\n", 
      "- Control - Controlling a system in an optimal way\n", 
      "- Filter - It is the problem of extracting the particular region of interest especially when there is noise in the data.\n", 
      "- Beam forming: It is a problem of spatial filtering where the interest region is to be extracted in the presence of noisy data as well as it's own background noise."
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "[--] this\n", 
      "\n", 
      "Machine learning proplems \n", 
      "\n", 
      "1) the high dimensionality of the data. if the dimensionaly of input space is increased the computioinal cost gets hight exponentionally.\n", 
      "\n", 
      "2) if the learning algorithm is trained very much then it ends up with the memorising the data. that often termed as overfiting problem .  "
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "1. The similar inputs from similar class should produce similar representation inside the network\n", 
      "\n", 
      "2. The different inputs should produce widely different representation inside the network\n", 
      "\n", 
      "3. More number of neurons should be allocated for imporatant features of the input data"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "Overfitting: The network learns noise in the data\n", 
      "\n", 
      "Too strong generalization: The network generalizes too strong so that the output does not tell anything.\n", 
      "\n", 
      "No convergence: The learning machine may not converge and oscillate.\n", 
      "\n", 
      "There may be too few labelled data available, training need lots of data."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "* Overfitting.\n", 
      "* Slow convergence rate.\n", 
      "* Oscilations.\n", 
      "* Noise in input data.\n", 
      "* Bad choise of hyper parameters.\n", 
      "* Hard to find how many number of training samples required.\n", 
      "* Which network structure and learning algorithm should be used. "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Some of the principle problems in machine learning are curse of dimensionality and overfitting. \n", 
      "\n", 
      "1. Curse of dimensionlity: When the number of features increases, it is very hard to find a pattern and the performance becomes poorer. \n", 
      "\n", 
      "2. Overfitting: When the neural network learns excess of input output sample, it ends up memorsing the training sample. "
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "main problem is generalization from training data to test data avoiding overfitting. Overfitting means the error on the training set is driven to a small value, but when new test data is presented to learning machine, the error is large. That means The network only memorized the training examples, not learned to generalize to new situations."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Generalization: when the model is not able to correctly label new data .\n", 
      "Overfitting: When the model has memorized the training data and is not able to generalize.\n", 
      "Model complexity"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "* Computational Costs"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "Curse of dimensionality\n", 
      "Vanishing gradient problem\n"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Overfitting: The Network memoroizes the data and is not able to generalize\n", 
      "\n", 
      "Curse of Dimensionality: The needed Training data increases with the number of dimensions of the data\n", 
      "\n", 
      "Bias-variance dilemma: explained in Q. 17\n", 
      "\n", 
      "Enough data for training: related to the curse of dimensionality"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "- Overfitting on limited training data, where for exampel a classifier performs worse on test data because it made assumptions on the training data.\n", 
      "\n", 
      "- Closely related to the first, sparsity of (LABELED) training data in high dimensional space (Images, videos etc.). Obviously it is hard to cover the whole problem space with a limited amount of data, thus underlining the importance of a unbiased trainign set.\n", 
      "\n", 
      "- Curse of dimensionality, also related to the first two.\n", 
      "\n", 
      "- Growing hardware+parallel computation requiremetns when working with image and video data, especially made more accessible the introduction of CUDA based libraries."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "- Overfitting\n", 
      "- Generalization\n", 
      "- Number of layers/neurons to use\n", 
      "- Vanishing gradient"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE One principle problem is noisy data ( data which have more information than needed , these extra information have to be removed ), overfiting of neural network ( overfitting = neural network learns training data and it is not able anymore to calculate a similar input - output mapping for similar input ( generalize ) )"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "**Answer 5:**\n", 
      "\n", 
      "Some problems in machine learning:\n", 
      "\n", 
      "1. Bias-variance dilemma- choosing a tradeoff between bias and variance as increasing one reduces the other and vice verse.\n", 
      "2. Overfitting - learner memorizing the training data and failing to generalize.\n", 
      "3. Curse of dimensionality: With increase in dimension of the input data, the amount of data grows exponentially."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "- Data gathering: in order to train a network you need a dataset. The larger the network the larger the dataset.\n", 
      "- Time needed to train. Large networks require a large amount of time to train.\n", 
      "- Topology: Which topology to choose? Which performs the best?\n", 
      "- Blackbox: The networks are basically a blackbox. We don't really know whats going on in there. Even a small change in input can lead to a large change in output."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Training data might be hard to come by. For supervised learning labled data is required.  \n", 
      "Complex data might require higher complexity models for the learning machine. This means computation becomes more expensive, also more complex models require more training data.  \n"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "pattern association. Detect feature on input data and do for example classification\n", 
      "\n", 
      "regression. Find a function, that fits the data well, but does not have to fit each point (not interpolation)\n", 
      "\n", 
      "controling. Use the sensory data to produce controling signals (e.g. in robotics)\n", 
      "\n", 
      "filtering. Filter the input data "
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "The principle problems are overfitting and curse of dimensionality.Overfitting is the production of an analysis that corresponds too closely to the training data, so it cannot add new data and fails to make prediction of future.\n", 
      "\n", 
      "Curse of dimensionality refers to the various phenomena that comes into picture while organizing and analyzing data in higher dimensions.More features reduce the performance."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "- Face recognition\n", 
      "- OCR(Optical Character Recognition)\n", 
      "- Time series prediction\n", 
      "- Dynamic system modeling"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "[--]\n", 
      "Pattern recognition: The input data contains patterns, like a picture with specific features on it. The neural network needs to learn the patterns and recognize it in new input data.\n", 
      "\n", 
      "Classification: The input data is seperated into classes. The network learns the input data and has to classify new input data, where the class labels are missing, to the specified classes.\n", 
      "\n", 
      "Function approximation: The network learns to approximate a function. When unknown data is presented to the network it has to predict the output, which the function would produce."
     ], 
     "points": 0
    }
   ]
  }, 
  {
   "qid": 26, 
   "question": "How to remedy over-fitting?", 
   "answers": [
    {
     "answer": [
      "YOUR ANSWER HERE: Overfitting can be avoided or decreased by the following methods:\n", 
      "- Adding prior information or invariances in the design of the network.\n", 
      "- Early stopping of the algorithm when the error is under some threshold value.\n", 
      "- Assigning a momentum factor to the error function which makes the error function descend slowly for variation in time."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "[--] this\n", 
      "\n", 
      "overfitting can slplved by \n", 
      "\n", 
      "3-way splits method \n", 
      "\n", 
      "hold out method\n", 
      "\n", 
      "cross- validation\n", 
      "\n", 
      "k-random sampling \n", 
      "\n", 
      "k-fold sampling \n", 
      "\n", 
      "leave one out method."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE\n", 
      "\n", 
      "Over fitting can be handled by finding the best learning machin using one of the approaches\n", 
      "\n", 
      "* Cross validation\n", 
      "* AIC\n", 
      "* BIC\n", 
      "* SRMVC"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "One way to remedy over-fitting is to do structural risk minimization. Namely, to perform tradeof between compexity(size) of NN and number of training examples. The idea is to reduce size of NN(number of neurons) as long as the error in training remains minimal. With this idea, this problem is having to complex model of NN for certain number of experiments is minimized.  "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "1. By removing the complexity of the problem\n", 
      "\n", 
      "2. By increasing the number of weights\n", 
      "\n", 
      "3. By doing cross validation during the training phase\n"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "* Cross validation\n", 
      "* Nomalization of input data (Whitening)\n", 
      "* Generalization of data\n", 
      "* Carefully choose the values of hyperparameters\n", 
      "* Keep the learning rate small."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Over fitting can be removed by reducing the training samples. The training data should be in such a way that it can show all the features."
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "1. Remedy for overfitting would be regularisation \n", 
      "2. In CNN using pooling we can reduce overfitting. "
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "1. add noise to input data\n", 
      "2. simplify structure of network"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "- Early stopping\n", 
      "- Regularization"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Over-fitting can be remedied by several ways:\n", 
      "+ Dropout: is known to make NN robust against overfitting. It works by randomly dropping some weights so that NN learns better generalization.\n", 
      "+ Separate data in three parts: training, validation and test. Compare diffrent trained model by evaluating them on validation data. Select best model to test on test data."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "A network that is overfitted does not generaliye well. One method for improving network generalization is to use a network that is just large enought to provide an adequate fit. The larger network you use, the more comlex the functions the network can create.\n", 
      "\n", 
      "If the number of parameters in the network is much smaler than the total number of points in the training set, then there is little or no chance of overfitting. If you can easily collect more data and increase the size of the training set, then there is not need for further techniques to prevent overfitting. If this is not the case then techniques called regularization (modification of the performance function) and early stopping (available data is divided into three subsets: trainig, validation and test set; stopping runs at error minimums) can be applied."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "We can use more examples to traing the network, or reduce the dimensionality of the model."
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "Over-fitting can be remedied by reducing amount of training data, as it causes the network to learn the noise."
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "Using a holdout validation set to stop training when overfitting, i.e. early stopping. Oversampling underrepresetned classes. Using regularization techniques such as weight sharing, dropconnect, dropout."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "- Introduce a momentum term or an added bias to refrain the network from learning the data along with it's noise."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "[---]\n", 
      "\n", 
      "Over-fitting is the problem due to which network cannot generalize properly. \n", 
      "In order to remedy this problem, **regularization** is used, which reduces the complexity of the network"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "**Answer 6:**\n", 
      "\n", 
      "To reduce overfitting:\n", 
      "\n", 
      "1. Reduce the complexity of the learner by simplyfying its structure.\n", 
      "2. Use cross validation to determine whether the learner generalizes.\n", 
      "3. Provide additional diverse inputs."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "- Split data into train and test dataset\n", 
      "- Add noise to training data\n", 
      "- Stop training when error change gets very low and network starts to learn the actual training dataset"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Overfitting cannot happen if the learning machine has a the right amount of power (Structural risk minimisation/ cross validation) and the training phase isen't so long, that the learing machine learns the training set."
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "Regularization: Modified Error function that punishes high complexity therefor the learned function is more smooth."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "By decrease the number of training samples or decrease the complexity (VC-dim).\n", 
      "Also use better training samples:\n", 
      "    1) Use training samples, which result in a higher training error\n", 
      "    2) User training samples, that a widely different from all previous"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Overfitting to the dataset can be counteracted by reducing the complexity of the machine. Less complex machines can not fit the data as accurately and may lead to better generalization. \n", 
      "\n", 
      "By increasing the number of training samples a more general model of the underlying data can be learned."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Overfitting causes because NN learns memorizes each point in training datasets. So it cannot generalize the testing points especially those near the boundry. \n", 
      "\n", 
      "This mainly happens due to use of NN with high expressive power on for training dataset with low number of data. \n", 
      "\n", 
      "Remedy is to decrease the parameters in the NN to reduce its power. Or use high number of training datapoints rich enough to sufficiently express undelying principle. "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "We can remedy overfitting by cross-validation.If we divide the training data into training data  for training the algorithm, validation data for fine tuning of the network and test data for generalization."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "[--]\n", 
      "\n", 
      "1) Cross validation\n", 
      "2) Bias invariance , reducing errors in training samples\n", 
      "3) Decreasing the number of training samples\n", 
      "4) Taking precautions of the complexity of the task and the architecture of the network."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Overfitting can be avoided by splitting the input data into training data, validation data and test data. This way the network only learns from the training data so it has no chance of memorizing the data, because a big part of the data is unknown to the network."
     ], 
     "points": 0
    }
   ]
  }, 
  {
   "qid": 27, 
   "question": "Give the main idea of Cover's theorem and where / how is it used?", 
   "answers": [
    {
     "answer": [
      "YOUR ANSWER HERE: Cover's theorem states that a complex pattern clasification problem cast in high dimension is more likely to be linearly separable than in a low dimension provided the following conditions.\n", 
      "- The transformation is non linear.\n", 
      "- The dimension is high enough.\n", 
      "\n", 
      "It is used to classify non linearly separable patterns by casting them to high dimension."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "[--]this\n", 
      "\n", 
      "the main idea of the  covers theorm says that\n", 
      "\n", 
      "if the dimensionality of the input space higher than the the dimensionality of the output space . then the probablilty of the linearly saperating is closer to one."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Cover's therom states that the classifiaction problem present in certain dimension can be countered by projecting the the bianry input in higher dimension. It is very useful in RBF and SVM"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Covers theorem states that for a pattern classification problem, given data casting in a higher dimension feature space is more likely to be linealry seperable than casting in a lower dimension feature space"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Covers theorem states that, if a set of input data is not lineraly separable, then one can **apply non linear transformation** to the data to project the data in **higher dimensional space** where it can be separable by a linear classifier.\n", 
      "\n", 
      "It is used in **Support vector machines** and using the **kernal function** SVM transforms data in to higher dimensional space and classify them using linear classifer with widest margin.\n"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Cover's theorem states that if data is not linearly separable in dimension C then it might be separable if we increase the dimension. \n", 
      "\n", 
      "This is be used in RBFs. "
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "A complex pattern classification task, cast in higher dimensional space non linearly, can be classified very easily compared to that of a lower dimensional space. \n", 
      "\n", 
      "One place where they use is RBFN. They perform non linear transformation of the data from the input space which is non seperable into a space where it can be linearly seperable. "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Covers theorem states that there is higher propability that data will lineary separated in higher dimension compared to that in lower dimension. It is used in tecniques like SVM to first transform the data in higher dimension using non-linear transformation and then learn the data."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Cover's theorem: a complex pattern classification problem cast in a high dimensional space nonlinearly is more likely to be linearly separable than in a low dimensional space.\n", 
      "\n", 
      "it is used in RBF network for pattern classification problem, like XOR problem. Transforming nonlinearly from input data to a high dimensional hidden space using radial-basis function, then it is separable linearly in the hidden space."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The covers theorem tell us that it is more likely to separate nonlinear data in higher dimensional space than lower dimensional space. It is commonly used in SVMs or RBFs to classify lower dimensional data by elevating it to higher dimensional space where the inherent characteristics of the data is not changed. "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Suppose data sets C_1 and C_2 are linearly seperable. The perceptron convergence algorithm convergeses after n_0 iterations, with n_0 < n_max on training set C_1 U C_2."
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "Cover's theorem tells us that a complex classification problem is more likely to be solved if the data points are cast nonlinearly into a high dimensional feature space than in a lower dimensional space. It is used in RBF networks and SVM to classify nonlinear separable data points by transforming the data into a higher dimensional space."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Covers theorem is about the phi seperability of patterns. It makes the statement that when the dimension of our family of kernel functions is grater than the number of patterns in the input the probability of seperability is closer to 1. We used it to motivate why RBF networks exists and whay the work. Powell then formulated \n", 
      "\n", 
      "$$ F(x)= \\sum w*phi(||xi-x||)$$"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The Cover's theorem declares that if a non-linear multi-dimensional transformation is applied into the input space, the probability that the resulted space is separable is close to 1. The cover's theorem is used for example in the RBFN, where the input space is non-linearly transformed into a hidden space by the radial basis functions. Also it's used in SVMs when using a kernel."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Cover's theorem is used in SVMs in the form of Kernel functions. It says that a problem casted into a higher dimensional feature space non-linearly is more probable to be linearly separable than in lower dimension. "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Covers theorem tells us that, when applying a nonlinear transformation on a dataset which is not linearly seperable, and thus transforming it into a higher dimensional representation, the chance of the dataset being linearly seperable is higher. This is used in RBF, where we transform the input patterns to higher dimensions using the radial basis functions and then learn the linear combination of them in the last layer."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "According to covers theorem, if we have a feature space of m1, and if the dimension of data, m0 is less than m1, the probability of classification tends to 1. \n", 
      "\n", 
      "That is, if the feature space (or number of nodes in the hidden neuron) is more than or equal to the dimension of the dataset, it is more likely to suceed.\n", 
      "\n", 
      "It is used to estimate the number of neurons that needs to be present in the hidden layer"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "[---]\n", 
      "\n", 
      "We mainly use for non-linear separability. This is normally used in radial basis function networks\n", 
      "\n", 
      "Given a family of non-linear functions($m_{0}$), if the dimensions of hidden space(or number of features) are greater than number of training examples, then probability of separability is closer to 1.\n", 
      "\n", 
      "It casts complex features in higher dimension non-linearity are linearly separable than lower dimension.  "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE: A non-linear input is more probably to be linear separable in a higher dimensional space. To solve XOR Problem Cover's idea is used."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "**Answer 7:**\n", 
      "\n", 
      "Cover's theorem states that if data is cast on to a higher dimension non linearly, the probability of it being linearly seperable is higher than that in the lower dimension. When cast on the higher dimension non linearly, probability of being linearly seperable is more close to 1.\n", 
      "\n", 
      "It is used in Radial Basis Function Network (RBFN) where the hidden layer produces many feature spaces from the input data. The number of feature spaces is as many as the number of hidden neurons."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Covers theroem says if data is linearly transformed into a highdimensional space there are more likly saperatable then befor. We use that information if we want so saperates data that is not linearly saperatable in low dimensinal space. (radial basis functions) "
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Covers theorem tells us, that if non linarly seperable data is cast via a nonlinear function to a high-dimensional space (called feature space), it is more likely to be linearly seperable in the highdimensional space. \n", 
      "\n", 
      "it is used in SVMs, when using radial basis functions. Via the kernel of radial basis functions the data is transformed nonlinearly to a higher dimensional space "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "By casting a non linearly seperable problem into a higher dimensional space the probability of linear seperability increases. It is used in RBF networks to seperate non linearly seperable data in a higher dimension."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Covers theorem states that chances of linearly separating data which is linearly non-seaparable in low dimmensions are higher if  nonlinearly transformed to higher dimmensions .  \n", 
      "\n", 
      "This concept is used in clssifiaction using RBF by transforming data into nonlinear high dimmensions and then linearly separate them. "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Cover's theorem states that complex pattern classificaton problem cast in high dimension non linearly is more likely to be linearly separable  than in lower dimension.It is used to make sure that the data is converted to higher dimension to make it linearly separable in RBF and SVM."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "[--]\n", 
      "\n", 
      "The main idea of Cover's theoem is that , as the dimensionality of the data increases, thhe data tends to become linearly separable. Thefore, it can be separated in finite number of iterations in higher dimensiona space.\n", 
      "\n", 
      "This is used when the data is not linearly separable in lower dimension. Hence, the data is mapped to hifgher dimensions using kernel functions such as RBF"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "If the dimension of the hidden layer is bigger than the dimension of the input data the probability that the hidden layer can find a model that fits the data is close to 1. This means that for solving a problem we need a network that has more dimensions than our problems data."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Cover's theorem states that the probability of a data set being linearly separable is greater if it is projected to higher dimensions. It is used as the basis for RBFs where the basis functions are used to enhance the dimension of the data. \n", 
      "$$P(N, m_1) = {\\frac{1}{2]}^N \\sum_{m_1}^{N-1} (N-1 m_1)$$"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "[--]\n", 
      "The main idea of Cover's theorem in conceptual terms is that a complex pattern classification problem cast into a high dimensional space is more likely to be linearly separable compared to a low dimensional space, provided the input space is not densely occupied. Given N data points $\\{x_1,x_2...x_n\\}$, and dichotomy $C^1, C^2$ of the dataset, then from Cover's theorem, the given data points are $\\phi$-separable with a probability of 1, if the dimenion of the input space $m_0$ $<$ dimensionality of the hidden space $m_1$"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Cover's theorem says that the propability of a complex task to be linearly separable is higher in a high dimensional space than in a low dimensional space. This is used in RBF networks, where the input data is cast into a high dimensional feature space to make the problem linearly separable."
     ], 
     "points": 2
    }
   ]
  }, 
  {
   "qid": 28, 
   "question": "Explain the concept of Kernel functions used in SVMs!", 
   "answers": [
    {
     "answer": [
      "YOUR ANSWER HERE: Kernel functions are the functions that are used to transform the the feature space into a new space with higher dimension where the probability of the data to be linearly separable is high. Radial basis functions are one of the kernel functions that can be used in SVMs."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "The kernel functions are used project the input in a higher dimension so that the data non - linearly separable data becomes linearly seperable.\n", 
      "\n", 
      "few kernel functions are:\n", 
      "1. polynomial term\n", 
      "2. Radial basis function \n", 
      "3. gaussian function"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Kernel functions are used in SVMs to put the input into a higher dimension. One dimensional data may not be linearily separatable as it is, but maybe if we project it with a parabola it becomes linearily separatable."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Kernal functions are used in SVMs to project the non linear data points to high dimensional space where the data can be classified using linear decision boundaries."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "SVM tries to maximise the margin of separation between the 2 classes. Kernel functions are used to trasform the non-lineary separable data into higher dimension using non-linear transformation. This is based on Cover's theorem which states that there is higher probability that data will linearly separable in higher dimension. Some common kernels used in SVM are rbf, polynomial etc."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Kernel function is inner product of weight vector and input vector, Transforming nonlinearly from input space to the hidden space (which has a number of support vectors) using polynomial function or radial-basis function, then it is separable linearly in the hidden space and optimal desicion surface is likely to be found."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "One key innovation associated with SVMs is the kernel trick. The kernel trick consists of observing that many machine learning algorithms can be written exclusively in terms of dot products between examples. It allows us to learn models that are nonlinear as a function of x using convex optimization techniques that are guaranteed to converge efficiently. Besides, the kernel function k often admits an implementation that is significantly more computatinal efficient than naively constructing two vectors and explicetly taking their dot product."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "The Kernel functions used in SVMs is a non-linear transformation into the input space dimensionality by increasing the dimension of the input space. As the Cover's theorem mentiones, when applying this transformation into a non separable input data, the resulting input data space can be separable. An example of a kernel function in SVMs can be $k = (x, x^i)$"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Kernel functions in svm transform a problem in a lower dimension into a higher dimension in order to give new view points on the data, that may enable a linear partioning of the data."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Kernel functions in support vector machines are used to increase classification abilities of the network. For example to make a network to be able to classify non-linear problems, a non-linear kernel function is required."
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "Kernel functions in SVMs transpose the input patterns into higher dimensions, making them more likely to be linearly seperable. Commonly used kernel functins are RBFs, or polynomials."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE A kernel maps an input space to a higher dimesional feature space. The concept is that a non separable input becomes linear separable in a higher dimensional feature space."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "**Answer 8:**\n", 
      "\n", 
      "A kernel function is used to cast the data into a higher dimension or to provide a different viewpoint of the data. This enables the SVM to then separate the data linearly. For instance, 1D data could be cast into two dimensions by a polynomial kernel where it could become linearly seperable. Other kernels are RBF, sigmoid."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The kernel functions in SVMs are used to represent data in a different way. There are multiple options:\n", 
      "- squared inputs or even larger exponents\n", 
      "- different linear combinations of inputs\n", 
      "- different activation functions"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Kernels help us to work with high diensional data into a 2 dimension and then we can use a SVM for doing the classification"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Kernel functions are used in SVMs to allow them to classify non-linearly separable data. They project the data in higher dimensions where it becomes linearly separable. Some kernel functions are Polynomial, Radial etc."
     ], 
     "points": 2
    }
   ]
  }, 
  {
   "qid": 29, 
   "question": "What does the Perceptron Learning Theorem tell us?", 
   "answers": [
    {
     "answer": [
      "YOUR ANSWER HERE; Perceptron learning theorem states that the learning converges if the data is linearly separable."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Perceptron Learning only works in case of linearly separable inputs- Perceptrons forms the basic unit of the neural network model. They are divided into layers connected by synaptic weights."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "The theorem tells us that perceptron learning converges if the given data is linearly separatable."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "* Move the hyperplane towards separation in each iteration.\n", 
      "* If the error is positive, then update the weight by adding the error with the input.\n", 
      "* If the error is negative, then update the weight by subtracting the error with the input.\n", 
      "* If there is no error, then dont updtae the weight."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Perceptron Learning theorem tells us that if data is linearly separable then algorithm will converge in $n_{0}$ iterations such that $ n_{0} < n_{max}$"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The perceptron leaning algorithm terminates if and only if it is linearly separable. it can not be used for nonlinearly separable problem."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "+ Perceptron learning theorem states that if the data is perfectly linearly separable, a linear perceptron will always converge in finite number of iterations."
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "+ Perceptron learning theorem states that if the data is perfectly linearly separable, a linear perceptron will always converge in finite number of iterations."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "It tells us that a classification problem with linearly separable dataset can be solved using error correction."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "If the error from desired output and actual output is equal to 0 then learning is finished."
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "The theorem tells us that if a dataset is lineary seperable, the perceptron learning algorithm will converge in a finite number of steps. If it is not, the perceptron learning never converges."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "[---]\n", 
      "\n", 
      "It tells us that if the datasets or training examples are linearly separable then perceptron learning theorem converges"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "**Answer 9:**\n", 
      "\n", 
      "The perceptron learning theorem tells us that if the data to be learned is linearly seperable, then the convergence is definetly attained. If the data is not linearly seperable then there will be no convergence as there is no linear boundary to seperate the data."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The theroem tells us that the learning of a perceptron is finite, by giving us a upper bould for the training iterations."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "[--]\n", 
      "\n", 
      "Perceptron learning theorem tells us that given a set of linearly separable data, a perceptron can fit a linear model in a finite number of iterations. It means that the perceptron convergence algorithm(PCA) will definitely converge after a finite iterations. Given two classes m_0 and m_1, the PCA will converge in n_0 iterations which is always less that n_{max} iterations required for the dataset of union of classes m_0 and m_1."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "It tells us that given two linearly separable sets C1 and C2, the perceptron learning algorithm converges in $n_0$ iterations which is bound by the finite value $n_{max}$"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "[--] \n", 
      "The perceptron learning algorithm tells that given a set of training examples $\\{x_i,d_i\\}$ that are linearly separable, the algorithm converges by finding a decision surface in the form of a hyperplane that separates the given patterns into the respective regions. The algorithm however cannot learn examples that are not linearly separable"
     ], 
     "points": 2
    }
   ]
  }, 
  {
   "qid": 30, 
   "question": "What is three-way data split and how to use if for NN training?", 
   "answers": [
    {
     "answer": [
      "YOUR ANSWER HERE:\n", 
      "- Three-way data split is the process of dividing the available dataset into three parts.\n", 
      "- The training dataset, validation dataset and the testing dataset.\n", 
      "- After the network is presented with the training dataset, validation dataset is used find the most appropriate method i.e., which produces the least error.\n", 
      "- Then the test dataset is used to find the generalization performance of the network."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "[--]this\n", 
      "\n", 
      "Three-way data split is \n", 
      "\n", 
      "Training : you use training data to train the prameters of the network.  \n", 
      "\n", 
      "Validation : In this process you do the validation by some validation data sets. here you tune the parameter of the NN.\n", 
      "\n", 
      "Testing : this is final test data sets. which used to test the performance of the Neural Networks.\n", 
      "\n", 
      "to use with NN you devide the Data into 3 sets which mentioned above. \n", 
      "and train initially then do some turning with validation set this will be final tuning/ modification.\n", 
      "then test with data."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The three way data split in NN training is dividing the data into training set, validation set and test set.\n", 
      "Training set is used to learn the parameters of the network and determine the network structure. Validation set validates the learnt model and optimizes it. The test set evaluates the performance of the learnt model No parameters are adjusted after the validation state."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE\n", 
      "\n", 
      "\n", 
      "Three way data split is splitting the data into three groups, training set, validation set and test set.\n", 
      "\n", 
      "* The training set is used for adjusting the weights of the network\n", 
      "* The validation set is used to adjust parameters like stopping criteria, numbers of layers, number of neurons in the layers etc.\n", 
      "* The test set is used to find generalization error."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "The data is split into three groups:\n", 
      "\n", 
      "1. training data:  They are used train the network\n", 
      "\n", 
      "2. validation data: They are a small part of the training data. They are used validate the trained data and compare with the other networks. \n", 
      "\n", 
      "3. testing data: They selected network is validated with this dataset"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Data is split into training, validation and test data.\n", 
      "\n", 
      "First, different networks are trained using the training data. After that, all trained networks are tested using the validation data. The best network is choosen and then trained again with training and validation data. Using the test data the error of this final network is computed."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The data is split into training data, evaluation data and test data.\n", 
      "\n", 
      "First the NN is trained with training data and using the evaluation data the weights are adjusted. This is repeated until there is no change in any of the weights. Now the test data is used to test and know the accuracy of the NN."
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "Three way data split. \n", 
      "1. Training stage: In this stage we set the parameter for classifier. \n", 
      "2. Generalisation stage: In this stage we adjust the parameter for classifier, such that it will be the last stage before testing. So the classifier in this stage is the best one. \n", 
      "3. Testing stage: Here we check the parmaeters, how the learner performs. \n", 
      "\n", 
      "After testing we dont adjust anything."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "In NN training data is splitted into training dataset, validation dataset and test dataset. Initially the models are trained using training dataset and tested with validation dataset to test the models. Then the model with minimum error is chosen and again trained with training plus validation dataset. Newly trained model is finally tested on testing dataset."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "+ Training set: for learning NN models\n", 
      "+ Validation set: for evaluating various NN models for performance\n", 
      "+ Test set: Evaluating performance of NN that performed best on validation set."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Three-way data split separates the given data points into training set and test set, and the training set is divided into two groups: one for model training and the other for model selection. The test set is used to validate the model."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "In a three-way data split, the data is spit into three sets, the training set, the validation set and the test set. If different archictectures have to be evaluated, the three-way split helps to choos the architecture of the network. For this purpose all architectures are trained on the training set. The validation set is then used to determine a training error. From the results the best performing architecture is choosen and trained on the training and validation set. The test set is the used to accquire the final error of the choosen architecture."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Three-way data split is splitting the dataset what you have in following categories, so that data from one of them is not part of other two:\n", 
      "\n", 
      "1.Training data (network is trained using this dataset)\n", 
      "\n", 
      "2.Verification data (verify your training results)\n", 
      "\n", 
      "3.Test data (test your network on this dataset)"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Training dataset is used for tuning of weight parameters of the model. The Validation set is used to determine if the model is improving on unknown data or overfit on the training data. The test set is used to report the final classifier or regression error on a new dataset, and should be only used a single time, for eyample in reporting classificatin results in a publication."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "- The input data is split three ways:\n", 
      "    - Training set\n", 
      "    - Validation set\n", 
      "    - Test set\n", 
      "- The training set is used to train several modes (say, M_1 to M_n)\n", 
      "- The validation set is used to \"test\" the results of the different models to get errors (E_1 to E_N)\n", 
      "- Then the model with minimum error is selected.\n", 
      "- This model is trainied again with the training and validation sets combined.\n", 
      "- Test set is used to get the error of this model"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "[---]\n", 
      "\n", 
      "Three-way data split is :\n", 
      "\n", 
      "i. Training set\n", 
      "\n", 
      "ii. Validation set\n", 
      "\n", 
      "iii. Test set\n", 
      "\n", 
      "First we train the algorithm only on training set and we adjust parameters based on training set to get optimized model. We adjust parameters based on error between current output and desired output. This can be done using Back-propagation algorithm\n", 
      "\n", 
      "After that, we evaluate that trained model from training set on validation set. Again, we optimized the parameters of model based on validation set. \n", 
      "\n", 
      "There are methods using those, we can generate validation set. Such as, Random subsampling, k-fold cross validation and so on. This is generated from training set. Like, from every batch of training, we can take one set for validation and save it for later testing of model\n", 
      "\n", 
      "\n", 
      "Now in Test set, we do not train any parameters. We only test and compute the accuracy of the model.\n", 
      "\n"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "**Answer 10:**\n", 
      "\n", 
      "A three-way data split splits the labeled data available into training set, validation set and test set. Different NN structures could be trained on the training set and the performance of each of the structures could be measured on the validation set. The structure which performs best is selected and then trained on both training and validation set to produce the final model. The final model is then tested on the test set to get the performance and determine the generalization ability of the final model (as the test set is unseen)."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "A dataset is split into train, test and verification data.\n", 
      "It the train dataset is used to train different network topologies. These are than evaluated and compared using the test dataset. Once the best performing topology is found is is newly training using train and test data. Finally it's performance is determined using the verification dataset."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The three data-split is to split the given data in three groups:\n", 
      "\n", 
      "- training data -> given to train models \n", 
      "- validation data -> given to optimize the parameters of the final model\n", 
      "- test data -> given to test the final model\n", 
      "\n", 
      "if we have enouth data we can find the best NN-Model to use by saperating the data in thee groups. "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Data is splitted into training data and two types of test data (a and b). Training data is used to train diffrent models of a NN. Then test data a is used to test the trained models. Choose model with lowest test error. Train the selected model with training data and test data a. Then test with test data b.  "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Spilt the given training data into \n", 
      "1) training data set\n", 
      "2) validation data set\n", 
      "3) test data set\n", 
      "First many differnet arcitectures are trained with the same training data. Then the best model (lowest error) is picked by using the validation set and compute the error for each model. At last the best model architecture is picked and trained with traning and validation data, to ensure more traning data and a better generalization. At last the error of the trained NN is determined by using the test data set. \n", 
      "It is related to the curse of dimensionality "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Three way split data split is a training and testing method for different NN models.\n", 
      "The three splits are training, testing and validation.\n", 
      "The training split is used to train the different models and verify them with the testing data. The gathered knowledge is used to generate a combined model which is then tested against the validation split."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Three way data split states that the training data into training data  for training the algorithm, validation data for fine tuning of the network and test data for testing the performance of the network."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "[--]\n", 
      "\n", 
      "Data is split into training, testing and validation subsets.\n", 
      "\n", 
      "Training data is used to fin dthe weight parameters of NN that model the desired function with the help of the labels.\n", 
      "\n", 
      "Testing data is used to test the accuracy of the trained \n", 
      "model.\n", 
      "\n", 
      "Validation data is used to validate the model for different conditions and parameters."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The three-way data split is \n", 
      "1. Training data\n", 
      "2. Validation data\n", 
      "3. Test data\n", 
      "The training and validation data is used for model selection (for e.g. Structural Risk Minimization). Once the best model is determined, it is trained usinf both training and validation data. This trained model is then evaluated using the test data which should be completely new to the network."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "[--]\n", 
      "\n", 
      "The three-way data split refers to dividing the input data into 3 parts : namely the training set, validation set and the test set. The training set is first used with different models to learn the parameters of the network. The validation set is then applied to further reduce the error during training. The training and validation set are then combined and used together to learn the parameters of the network to further minimze the error. The learned parameters are then used with the test set to test the results."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Three-way data split splits the input data into training data, validation data and test data. The NN is trained only on the training data. After this the NN is used on the validation data to check how good the network performs on unknown data. At the end the test data is used to further test the network. This way of training helps to prevent overfitting of the network."
     ], 
     "points": 2
    }
   ]
  }, 
  {
   "qid": 31, 
   "question": "Explain the behavior of train and test error, if we add more and more training samples", 
   "answers": [
    {
     "answer": [
      "[--]this\n", 
      "\n", 
      "If we add more more training samples then the when we train the network, it there is will less trainning error it will try to fit for the trainging data. \n", 
      "\n", 
      "may end up memorising the  training data. \n", 
      "\n", 
      "and  test data is from the traing set then there will very less or no error. if it is not from the training set then there might be relativeliy high error in test data."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "If we add more trainning smaples their is a risk of overfitting. The training examples are learnt very well, which results in decrease of training error, but can increase test error due to lack of generalization"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE\n", 
      "\n", 
      "TESTERROR <= TRAINERROR + VC-Conf\n", 
      "\n", 
      "VC-Conf is inversely proportional to the number of training data points. So if we increate training samples then the VC-Conf will decrease and the upper bound of the TESTERROR will decrease too.\n", 
      "\n", 
      "So adding more and more traning sample will reduce the test error."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "As we increase the training samples the train error and test error might decrease but after a specific point the train error goes to zero and the test error increases. This is due to overfitting. The machine memorizes the train data and not be able to estimate the output for new data properly."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "If we add more and more training samples then training error will decrease as per statistical learning theory. Further statistical learning theory states that test error bound is given by training error and VC confidence which depoends on VC dimension the machine. Thus with decrease in training error, test error bound will also decrease."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The Neural network learns better generalization after seeing more and more data. Therefore if we increase the number of training samples, the test error should either reduce or stay the same if the new samples are not \\emph{good} representatives of the underlying distribution."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Adding more and more training examples can lead to the problem of overfitting. In this case the training error becomes smaller and smaller with additional training samples, but the test error becomes larger and larger. This is due to fact, that the NN have learned features of less importance and became too specific. "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The test error is bounded by the training error and a term dependent on the VC dimension of the given task. Both errors change with the number of training samples: if we add more training samples, the training error will become smaller while the test error will increase."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "When adding more training samples, the training error will be reduced. But, if we add too much training samples we will have what is call generalisation error. The generalisation error occurs when over-fitting the neural network with too much training samples, and the neural networks become unflexible and remember just the training samples that where given."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "We are not able to calculate the test error of a network since we would need all possible test cases for this. So we can instead approximate the test error by computing a training error on a given training set that contains a subset of all examples. So the more samples we add, the closer the training set gets to containig all examples and thus the trainig error approximates the test error closer."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Train error is what you get when training your network, as we add more samples it will be reducing. But if we will be adding to many training examples test error will increase, as in the end we will learn the noise from training data)"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "- If we add more training  samples, then the training error will decrease. In other words, the Bias will decrease\n", 
      "- But, this will result in higher test error when we check with previously unseen data; i.e., variance will increase.\n", 
      "- This generally means that the system is overfitting to the training data."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE If we add more and more training samples the network tends to overfit (neural network learns training data), so testerror increases."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Because the network is only trained with the training samples, the train error will go down. If we decrease the train error too far, the network might learn the actual training samples and their noise. This results in an increasing test error."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "If we add many many more training examplex the training error approximates the test error. If we use all possible data in the world the errors are the same, because were isn't a difference between training set and test set anymore. "
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "The trainig error will decrease with more training examples. The test error will get closer to the Trainig error. The test error can not be better than training error."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The train error is steady decresed by adding more training samples. But the more samples, the less the error is decreased (it stagnates (german: stagniert)). The test error is first decresed by adding more training samples until it reaches a minimum. When adding even more traning samples, the test error is increased because of overfitting. "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Training error always generally decreases with increasing training samples. \n", 
      "\n", 
      "Testing error reduces upto some point with the training samples. But after a point VC confidence starts increasing with the training samples hence testing error is also increased. "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "By adding more and more training samples there is a possibilities that the network becomes overfit and learns everything in the training data set such as noise and this means we will have a very small training error but when we start to test our network with samples that it hasn'e seen before we will have a very big error."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "As we add more and more training samples, the test error decreases while the training error increases as the network begind to overfit the data by memoring the mappings instead of generalizing."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The train error will become smaller when adding more and more training samples. The test error will become bigger, because the network overfits and memorized the training samples. New unkown test data will produce errors because it can be different from the trained data."
     ], 
     "points": 2
    }
   ]
  }, 
  {
   "qid": 32, 
   "question": "Define and explain the term local gradient in back-propagation!", 
   "answers": [
    {
     "answer": [
      "YOUR ANSWER HERE:\n", 
      "\n", 
      "The local gradient in back propagation is the local component of the error function that is to be calculated for every neuron in the direction against the synaptic flow.\n", 
      "- If a neuron is a output node, the local gradient is equal to the product of the derivative of the activation function and the error signal.\n", 
      "- If a neuron if a hidden node, the local gradient is equal to the product of the derivative of the activation function and the sum of the products of the local gradient and the ouput of the neuron in the next layer."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The term local gradient in back propagation is  when the output error is fed back into the hidden layer , for each synapse the error is calculated locally by steppest descent and the weights are adjusted. This is done by calculating the gradient locally for that connection only."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "* Local gradient tells how much the weight should be updated for a neuron.\n", 
      "* The synaptic weight updated is directly proportional to **partial derivatives**\n", 
      "* Local gradient is calculated at ouput neurons and hidden neurons.\n", 
      "* Local gradient at output neurons are calculated using the observed error.\n", 
      "* But the error function is missing in the hidden neurons, so the local gradient of hidden neuron j is calculated recursively from the local gradients of all neurons which are connected directly to the hidden neuron j. "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Local gradient is the jacobian of the cost function with respect to weights. It is used in steepest descent method in backpropogation. The weights are adjusted in the opposite direction of the local gradient to reduce the error. "
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "An hidden layer is not directly connected with feedback layer, so it cannot directly contribute to it. In order ro contribute to that we find local gradients. Local gradients are basically nothing but variation of cost function with respect to the weight. This is particular to a single hidden neuron."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "$$\\delta_j(n) =  \\phi^{'}_j(v_j(n)) e_j(n) \\phi^{'}_j(v_j(n)) \\sum_{k}{} \\delta_k(n) w_{kj}(n) $$"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "The local gradient is the proportion of the activation corresponding to a neuron j when the error is being back propagated into hidden layer neurons. Since we we need compute error $e = d - y$, and $y$ does not exists yet in the hidden layers, we use the local gradient, which is a calculated using the derivative of the activation function. "
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Local gradient is the partial derivative of the cost function to the induced local field of each neuron. It is required in back-propagation to adjust the weights of each neurons."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "The term local gradient will be calculated in each neuron of the hidden layers in the back-propagation algorithm. These gradients values will be used in the backward phase, where the weights of the hidden neurons will be adjusted."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "A local gradient is the measure of how much the neuron that the gradient belongs to contributes to the final error. So it can be used to adjust the weights of a neuron in a multilayer perceptron. It depends on the neurons position how this gradient is calculated. "
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Local gradient for a neuron is partial derivative of the output function. There are two cases, first is when we are dealin output neuron, then we need to take partial derivative of the error of the output (desired output minus actual output). Second case is for neurons that are located further away from output. Then local gradient will consist from partial derivatives of all the previous neurons that we computed local gradient for."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "The local gradient is the sum of weighted deltas in backpropagation of the error in a hidden layer from previous layers (either other hidden layers or the output layer). This is due to the derivation from the chain rule for derivation, since we only have the error signal in the output layer and thus must backpropagate the error."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "- Local gradient is the gradient that is calculated at each ndoe (including the hidden nodes)\n", 
      "- This is used in back propagation to pass the error from the output layer to the inner layers."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "[---]\n", 
      "\n", 
      "Local gradient is partial derivative of error with respect to weight.\n", 
      "\n", 
      "In order to minimize the error of the model and adjust weight parameters. We compute the gradient of error with respect to weight. However, in case of output neuron it is easier to compute. \n", 
      "\n", 
      "For hidden layer neurons, we use chain rule and compute gradient of each recursively. "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE The local gradient in back-propagation is the derivation of error function which is given by:  $ \\frac{1}{2}\\sum e^{2} $ The errror is given by $ e = d - y $. We calculate the derivation of error function as we want to determine the minimum of error surface. To do so we calculate the local gradient which points into direction of highest increase, by multiplying gradient with -1 we get direction in which error surface decreases most."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "The local gradient used in back-propagation determines how the weights of a neuron changes. It is different for general and output neurons:\n", 
      "- For node i in an output layer: $\\delta_i(v_i) = \\varphi^\\prime(v_i)(d_i - y_i)$\n", 
      "- For node i in other layers: $\\delta_i(v_i) = \\varphi^\\prime(v_i)\\sum_{j\\in C} w_ji \\delta_j(v_j)$, where $C$ are all the nodes that use node i output as an input"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The local gradient is a vector, that showes in direction of steepest ascend of a function at one point (local). In back-propagation the negative gradient is used to get the direction of steepest descent. It is used to adjust the weights of each neuron while follow in direction of steepest descent of the error function"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "Local gradient is the derivative of local error of a neuron with respect to the local field of that neuron. \n", 
      "\n", 
      "$d_{i} = \\frac{de_{i}}{dv_{i}}$\n"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "Local gradient is the gradient of the all the output error of the neuron(from all the connections to the next layer) divided by the gradient of the activation function and the inputs multiplied by their respective weights.\n", 
      "\n", 
      "This gives us the amount of error each input is responsible for for the input of the each neuron"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "The local gradient is the partial derivative of the cost function with respect to the induced field.\n", 
      "$$\\delta_j(n) = - \\frac{d \\xi(n)}{d v_j (n)}$$ \n", 
      "d is partial derivative. \n", 
      "\n", 
      "The value is different for output and hidden neurons. For output neuron, $\\delta_j(n) = \\varphi'_j(n) y_i (n)$. For hidden neuron $\\delta_j(n) = \\varphi'_j(n) \\sum_{k in C} \\delta_k(n) y_{i} (n)$"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "[--]\n", 
      "The local gradient in back-propagation is defined as :\n", 
      "$\\phi^{'}_{j} (d(n)-y(n))$ if j is a output neuron"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "The local gradient $\\delta = \\sum w\\delta x$ is the summation of the error of the neurons, which are connected to the current neuron multiplied by the weights and the input data. The weights of the current neuron are updated using the local gradient because the error of all following neurons influence the weight update. The error is backpropagated through the network with the local gradient."
     ], 
     "points": 1
    }
   ]
  }, 
  {
   "qid": 33, 
   "question": "Reproduce the formulas for training error and test error!", 
   "answers": [
    {
     "answer": [
      "Training error is the average mean square error across the entire training dataset. <br>\n", 
      "Training error = $\\frac{1}{R}\\sum_{i=0}^{R} e^{2}(i) $ <br>\n", 
      "Test error is the error between network output and desired output. <br>\n", 
      "Test error = |d(n) - y(n)|"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Training error=amount of correctly identified samples/total amount of  training samples\n", 
      "\n", 
      "Test error=amount of correctly identified samples/total amount of test samples"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE Testerr = $\\frac{1}{N}\\sum_{1}^{N} d_{i} - y_{i} $"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "$TRAINERR(x) = \\frac{1}{R_{TRAINERR}} \\sum^{R_{TRAINERR}}_{i = 1} (d_i - y_i)^2$, where d is the desired output and y the actual output and $R_{TRAINERR}$ is the number of training samples.\n", 
      "\n", 
      "$TESTERR(x) = \\frac{1}{R_{TESTERR}} \\sum^{R_{TESTERR}}_{i = 1} (d_i - y_i)^2$, where d is the desired output and y the actual output and $R_{TESTERR}$ is the number of training samples."
     ], 
     "points": 1
    }
   ]
  }, 
  {
   "qid": 34, 
   "question": "What is Newtons method in general? How can it be utilized for NNs?", 
   "answers": [
    {
     "answer": [
      "YOUR ANSWER HERE:\n", 
      "\n", 
      "In Newton's method, the quadratic approximation of the error signal around a weight vector at time step n is used. It can be utilized for NNS if\n", 
      "- The hessian matrix is positive definite\n", 
      "- The error function is twice differentiable.\n", 
      "\n", 
      "Newton's method is smoooth and no zigzag behavior is seen."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "[--] this\n", 
      "\n", 
      "Newtons is quadratic approximation method. \n", 
      "\n", 
      "2nd order differential equation.\n", 
      "it can be used for NN to reduce the learning time and it converges faster than other algorithm."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Newtons method in genral uses a Hessian matrix of the error function to adjust the weights of the network. Only problem is the Hessian matrix has to be positive definite. It removes the zigzaging nature of trajectory of weight adjustment caused by high learning rate in steepest descent and also converges faster. "
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE\n", 
      "\n", 
      "Newton's method is an iterative approach of finding the root of a function.\n", 
      "\n", 
      "* In neural network it is used to minimize the error\n", 
      "* It converges quickly\n", 
      "* It does not give zigzag effect\n", 
      "* It requires the error function to be twice differentiable"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "The Newtons method in general, is a method used for optmizing certain non-linear funtion. This method uses a second order approximation of the cost function, based on second order Tailor expansion, for perdorming optimization procedure. In contrast to steepest descent method where the cost function is approximited with first order function-line, in this method cost function is approximated with quadratic function. Newton method does not exibit osicilatory path while leaning process, but it requires additionaly second derivative(gradient) of a cost function, and also this graddient must be always positive definite. THis method is hard to implement, because we do not have always second gradient available, and if we have, it is not guaratiened that this gradient will always stay positive definite. \n", 
      "Newton method can be used for learning in  NN , such that it can be applied for searching(finding) the minimum of a error funtion. The error funtion is defined as difference between desired signal and output signal from NN. The Newton method searchs for min of errror function, by changeing values of synaptiic weigths, and by then performing learning process of NN."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Newton method is an approxiamtion of second order derivative.\n", 
      "\n", 
      "They construct a slope for the function to be predicted using the know current step values. \n", 
      "Based on the x intersect of the slope and the other known values the next slope is estimated. \n", 
      "\n", 
      "They are used as a learning technique in the Neural networks. "
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Newtons method is a method for finding minima or maxima in a function using the hessian matrix. It is more robust against local minima and maxima than the method of steepest descent. It can be used in neural nets to change the weights in the right direction, because the error should be minimized."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "* Newton method minimizes the quadratic transformation of the error cost function $E$ around the vector (w).\n", 
      "* It uses Second order taylor series\n", 
      "\n", 
      "How can it be utilized for NNs? \n", 
      "\n", 
      "* Steepest decent methond finds only the direction to reach global minima to reduce the error.\n", 
      "* But Newton method also finds the velocity (steps) of moving the weight vector to reduce the error.\n", 
      "* Newton method doesn't work always, because it requires the hessian matrix (H) should be positive definite for all values."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "In newton method we try to minimize the cost function. It is used in backpropogation for adjusting the weights."
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "Newton method minimize the quadratic approximation of cost function E(w) around the current point w(n). It is basically used to reduce the value of the cost function. The hessian matrix produc by the second order of the taylor series must be positive definite."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Newtons method is second order version of a steepest descent method. It minimises the quadratic approximation of the error function. In neural network it is used as an iterative unconstrained optimization learning technique. It is used to adjust the weights such that second order approximation of the error function is minimises. Newtons method converges only if Hessian matrix is postive definite."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The newton method is an unconstrained optimization method that uses the squared error as cost function to minimize. Unlike the steepest descent, it requires a second derivative of the cost function and knowledge about the mxm Hessian matrix dependent on the input."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "+ Newton mathod learning rule: $w(n+1) = w(n) - H^{-1} e(n)$ $H$ is hessian of $e(n)$.\n", 
      "+ The convergence criteria is met only if the hessian of error vector is positive definite.\n", 
      "+ In general, we cannot be sure of the positive definiteness of the hessian."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "The Newton's method is an improvement of the steepest descent method, where the minimization of the error will be calculated by using the Hessian Matrix. For the Newtons method to work properly, the Hessian matrix must be a positive defined matrix. This approach will then converge faster and also the zig-zagging behavior (from the steepest-descent function) will be removed. This method can be utilized when adjusting the weights of the NN and reducing then its error."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Newtons method is used to optimize a function by using the second order tylor expansion on a point, then getting the minimum for that expansion and take it as the next point. In NNs it is used to optimize the weights of the network by finding the weight vector that minimizes the error between output and desired output."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Newton method is a method of weight adaptation that uses second order derivatives, therefore is converges a lot faster and non in zig-zagging manner as stepest descent. But in order for it to work Hessiam patrix must be positive and fully defined, which is not always the case. Weights of neural networks can be addapted using this method."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "[---]\n", 
      "\n", 
      "It is an unconstrained optimization technique. Where we minimize the error of the network by adjusting the weights\n", 
      "\n", 
      "Newtons method approximates the quadratic function of the cost with respect to weight. It converges faster than steepest descent. \n", 
      "\n", 
      "This method works:\n", 
      "    . Hessian is positive definite matrix\n", 
      "    . In real problem, this is not always possible."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Newtons method find the root of an differantal function. We can optimize the NN by using Newtons method if the Hessian matrix is invertable. If not we can use gauss-netwon. The newtons method minimzises the quadratric approximation of the cost function around the current point w(n)."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Newtons method makes quadratic approximation of an underlying function. But it requires a positive definit matrix. In NN it is used to reach the minimum of the cost function by quadratic approximation of the current error"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "Newtons method is a gradient descent method deriving from steepest descent.\n", 
      "Instead of using the gradient directly a Taylor series approximation is used to converge to the minimum. This avoids the oscillation problem of steepest descent.\n", 
      "\n", 
      "It can be used to train NNs instead of the steepest descent method, however it only works when the Hessian is positive definite."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Newton's method is a zero finding method which tends to minimze the cost function . It uses second order taylors' series for this purpose , hence the hessian matrix needs to be positive definite for newton's  method to work.It is utilized in NN's to mind the local or glolbal minima or to minimize the cost funcion."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "[--]\n", 
      "\n", 
      "Newton's method utilized the second order approximation of the estimated average cost function. This is to overcome the possibility of divergence due to steepest descept method. The weight si updated using second order Taylor's approxmation. This involves computation of Hessian matrix and requires it to be non-singular."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Newtons method is a stepwise approximation to the zero point of a function. It uses the first taylor polinomial to approximate the function and to get closer to the zero point in every step. It converges in quadratic time. This can be used in NNs to minimize the error function. This is done by using the Hebbian of the error function. The Hebbian has to be positive definite for newtons method to work. This converges faster than the Steepest Descent."
     ], 
     "points": 1
    }
   ]
  }, 
  {
   "qid": 35, 
   "question": "What do we understand by \"momentum\" in context of learning?", 
   "answers": [
    {
     "answer": [
      "In case of steepest descent method of weight adjustment for learning, high learning rate($\\eta$) results in oscillatory (zigzaging) nature in weight adjustment process. This can be countered by adding a momentum term ($\\alpha$) in the learning equation.\n", 
      "$W(n) = W(n-1)-\\alpha\\eta\\Delta W$"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE\n", 
      "\n", 
      "\n", 
      "$W_{n+1} = \\alpha W_n + \\eta e_n x_n$\n", 
      "\n", 
      "In a learning machine $\\alpha$ is the momentum, It\n", 
      "\n", 
      "* Reduces the zigzag effect while making adjustment of the weights\n", 
      "* Speed up the convergence in a steady down hill"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The momentum term is added in delta learning rule, such that is enables(keeps) smooth path, a path without occilations, while searching for min of error function, in negative gradient direction. IN other words, it accelerates seach in direction of steepest descent, such that search stays in that direction-does not ocilates.\n", 
      "\n", 
      "It has similar effects on seach for min error in NN, like effects in mechanics, when momentum(a moment  of inertia)  keeps certain body moving in its already defined direction, until some stronger force changes its direction."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "$ delta w(n) = \\alpha delta w(n-1) + \\eta e_k . x_j$\n", 
      "\n", 
      "$ \\alpha $ - momentum. \n", 
      "\n", 
      "They decide how fast the network learns from the training data\n", 
      "\n", 
      "THey are used to solve the problem of over damping and underdamping state caused by learining rate"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The momentum is a value which tells how strong the weight change of the last iteration is taken into account for the current weight change. It therefore is a value for the momentum of the weight change. The momentum is used to avoid oscillating behavior."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Momentum is used to increase the convergence rate. It basically varies for the various values of the learning rate. "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The momentum accelerate the gradient in direction to the steepest descent. It also stabilizes the function in the directions where it oscilates."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Momentum term stabilizes the gradient descent learning in the direction of the descent."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Momentum constant is a term to improve the training of a network. It can increase the learning process while mitigate the undesirable oscillation of the learning path. It is used in the generalized delta rule."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "momentum is an additional term which can be applied to the widrow hoff delta rule to increase the convergence. It is a variable factor which incoporated the slope of change of the weights. So when we are in a straight down hill direction we can accelerate convergence."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Momentum is a parameter used in learning machines that will stabilize the effect of the learning rate into the progression of learning. If learning rate is large, then we have an unstable learning progression, and if learning rate is smalle we have an slow learning progression. The momentum helps to find an stable learning state, where both effects (learn fast and stable) can be obtained."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "[---]\n", 
      "\n", 
      "As we know, when learning rate is lower there is slower rate of convergence.\n", 
      "when learning rate is higher, then algorithm become unstable\n", 
      "\n", 
      "In order to overcome this problem, we can use momentum.\n", 
      "\n", 
      "Momentum avoids the fluctuations or it smoothes the behavior, when gradient is oscillatory\n", 
      "\n", 
      "It accelerates the steepest descent to the direction of steady state\n", 
      "\n"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "**Answer 11:**\n", 
      "\n", 
      "A momentum is a term used to speed up the descent of weights and to attain faster convergence. The term is based on the previous weight update and a factor $\\alpha$. The term encourages movement along the steepest downhill faster. It has a stabilizing effect on weight updates which oscillates with time."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The momentum in learning basically uses the old $\\Delta w(n-1)$ from previous iteration to determine the new $\\Delta w(n)$.\n", 
      "\n", 
      "By doing so we prevent oscillation in weight changes and can improve learning speed."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Momentum can be used to prevend oscillation during learning. A part of the weight change from the last iteration is added to the next iteration."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The momentum is a parameter used steepest descent method in back-propagation learning. It increases the learning speed in steady downhill directions to increase speed. In other case it slowes down the steepest descent to increase stability and convergance"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Momentum can be used to adjust the learning speed of a machine. By increasing the speed of learning during stable convergence and stabilizing the learning in phases of oscillation."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Momentum is added turn in the adjusting weights to keep the learing rate fast in the begining and then stabilize it.\n", 
      "\n", 
      "$\\del w[n] = \\alpha * \\del w[n - 1] + \\eta * g(n) * x(n)$\n", 
      "\n", 
      "$\\alpha$ is momentum constant."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The momentum is a term added alon with learning rate to avoid oscillations while finding the transient response of the algorithm."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "[--]\n", 
      "\n", 
      "Momentum is used to maintain stability in the learning process by reducing the oscillations that the network without stability is prone to.\n", 
      "\n", 
      "Momentum can also pass on the required information that needs to be retained in the network's memory."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Momentum helps the learning process in the steepest descent methode. As mentioned before when we have a big learning rate we move very fast toward the global minima but we will oscilate around it because of the step size in each jump but the momentum will handel this situation and while it lets the methode to move fast toward the global minima at the beginning but while we get closer to the global minima it controls the scilation and we can reach the global minima."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Momentum is an additional term used in the weight update rule. It reduces the impact of the learning rate by -\n", 
      "1. Steadying the descent in directions where the algorithm oscillates\n", 
      "2. Faster convergence n directions where the gradient is smooth"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The momentum is a additional parameter, which can be added during learning. When updating the weights the formula is adapted using the momentum $w_{new} = \\alpha w_{old} + learning\\_rate \\cdot x \\cdot e$. Similar to the learning rate the momentum changes how fast the network learns. It smoothes the descent of the learning. The momentum is adapted with time."
     ], 
     "points": 2
    }
   ]
  }, 
  {
   "qid": 36, 
   "question": "What is \"normalization\" of inputs?", 
   "answers": [
    {
     "answer": [
      "[--] this\n", 
      "\n", 
      "Normlization of inputs consist of scaling the inputs to the same scale so that it has least variance . \n", 
      "\n", 
      "Normalizing is also reduce the data between 0-1. for complexity redcution.  \n", 
      "\n", 
      "PCA is one of the form. "
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Normalization of the input takes place in following steps:\n", 
      "1. Mean removal\n", 
      "2. Uncorrelation of data points.\n", 
      "3. Decrease the covariance.\n", 
      "PCA is a useful tool for data normalization or whitening of inputs"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE\n", 
      "\n", 
      "Normalization of input is a way of making the data independent of units. For example in a given data of total working hours and salary for a goup of people, the range of the values will be different for salary and total working hours. Normalization is a process to convert these values within a similar range (say 0 to 1) to make computation easier."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Normalization is a process of preparing input data, such that it is independent of its units, and enables easer learning.\n", 
      "\n", 
      "First step is remove the mean from the data, to center the data.\n", 
      "Next step is to make data uncorelated, by performing PCA on it.\n", 
      "Next step is to reshape decorealated data,  such that to make its covariances equal. "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "When features of different range has to be used by the network, then is advised to do normalise the input.\n", 
      "\n", 
      "the normalisation involves three steps:\n", 
      "\n", 
      "1. Mean removal\n", 
      "2. Un correlate the data (PCA)\n", 
      "3. Scale to approximate the covarianvce of the data\n", 
      "\n", 
      "By this all the weights in the network change uniformly. "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Before input data is passed to a network it should be normalized. Normalizing means mean subtraction, correlation normalization and covariance normalization. Using this the network will not learn any biases but only the structure of the data."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "* Normalization is a scaling process that makes the inputs to have **zero mean and variance of 1.**\n", 
      "* The set of input variables are uncorrelated using PCA.\n", 
      "* Then the decorrelated values are scaled, shifted/rotated such that all values should have **approximately equal covariance.**"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "For better training the inputs variables should be uncorrelated. The decorrelated variables are then manipulated so that they have equal covariance. This whole process is called normalization of inputs of whitening the data."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Before the learning process the data may be higly correlated, so we need to\n", 
      "\n", 
      "1. Remove the mean. \n", 
      "2. Decorrelate using the PCA and \n", 
      "3. And try to make the data set have high covariance. \n", 
      "\n", 
      "This is basically used to reduce the computation complexity and in order to consider the measuring units. "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "It refers to rescaling the inputs such that each input has equal influence on the output of the network.  "
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "make data independent of measurement units and has a variance of 1."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "+ The inputs of neural network could take arbitrary values and the distribution cannot be learnt well.\n", 
      "+ Normalization of the input is mapping the input to a probability space $[0,1]$ by dividing it by the total sum of the inputs."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "The input variables contained in the training set should be uncorrelated. In order to prevent this PCA is a technique that can solve the issue. Further the decorrelated input values should be scaled so that their covariances are approximetely equal, thereby ensuring that the differnt synaptic weights in the network learn at approximetey the same speed."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Normalization of inputs is to make inputs uncorrelated and with equal covariances among each other. It is used to remove the dependence of inputs on measurement units and make the weights of a network learn at similar rate. "
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "normalization or whiting is transforming the input data so that it is easier to compute and the network is working independent of the measuarment units. \n", 
      "\n", 
      "Techniques:\n", 
      "- mean removeal\n", 
      "- decorrelation\n", 
      "- covariance equalization\n", 
      "- changing the codomain to ie [0,1]"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Normalization of inputs is basically making inputs invariant in scaling, so that inputs go through covariance matrix and getting normalize, as if they dont some weights will be trained faster then other ones, which is undesirable."
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "Normalization of inputs is used to transform input patterns into an uniform range, making them usable for sigmoidal functions or other bounded activation functions. Often, this is either done through min max normaliyation between 0 and 1, or subtracting the mean and dividing by the standard deviation."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Normalization of inputs refers to processing the inputs as per below:\n", 
      "- Mean removal\n", 
      "- De-correlation\n", 
      "- Covariance removal\n", 
      "\n", 
      "This is also called whitening and is used to ensure that the weights are learned in the same pace and are not scaled different magnitudes of data due to differebt units."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "[---]\n", 
      "\n", 
      "Normalization of inputs means making the data independent of the measurement units. We also make sure that data is properly distributed, so we centered the inputs or training exmaples. This can make the computations faster and easier. "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE Normalization determines method to map inputs into a normalized distribution. A normalized distribution helps network to perform better."
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "**Answer 12:**\n", 
      "\n", 
      "In normalization, mean is removed from the input data and decorrelalized with the help of PCA. The data is then put through covariance equilization. This ensures that the data has similar effects on all the wieghts.\n", 
      "\n", 
      "Normalization is required to rid the data from its dependency to a measurement unit."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Also called whitening of data:\n", 
      "- Mean removal, center data for each dimension\n", 
      "- Decorrelation, typically principal component analyses.\n", 
      "- variance equalization"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The input should be normalized, so that the NN weights learn approxamtly the same speed. We want to decorrelate the date (PCA) and make the covariance the same. In the beginning we make mean removal."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "In normalization the variance of the data is brought to 1."
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "By normalizing or whitening data the unwanted correlations between the data points, as well as scaling or rotation of the data set should be removed. With a covariance matrix equal to the identity matrix there is no correlation and a variance of 0, which leads to better learning results."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Normalization is also refered to as whitening of data. First the data is made uncorrelated using PCA. Then the decorelated data is scaled so that the covariances are same , so that each parameter takes equal amount of time while training."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "[--]\n", 
      "\n", 
      "Normalization of inputs is the scaling of data. This removes biases and possible effects of noise on the data. It can be done by subtractionng the mean of the data and dividing it by the range,. It makes it easy for data comparison."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "It means that by excution of some mathematical oparators on the inputs we eliminate the effect of non relevant information such as units and this will simplifies working with the data."
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "Normalization of inputs includes following steps -\n", 
      "1. Mean removal (centering)\n", 
      "2. Decorrelation (using PCA)\n", 
      "3. Scaling of covariances\n", 
      "It is done so as to allow the weights to learn at the same rate."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The normalization of inputs removes the mean of the input data, decorrelates the input data using PCA and equalizes the covariance of the input data. This is done to normalize the input so that every input data has a similar influence on network as other input data."
     ], 
     "points": 2
    }
   ]
  }, 
  {
   "qid": 37, 
   "question": "When designing a feed-forward NN how to determine the correct number of layers?", 
   "answers": [
    {
     "answer": [
      "YOUR ANSWER HERE:\n", 
      "- We can start with large number of layers and decrease them until the performance degrades.\n", 
      "- We can start with small number of layers and increase them until the performance is acceptable."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "[--] this\n", 
      "\n", 
      "It depends on the application.\n", 
      "There are two methods for determining\n", 
      "\n", 
      "1) Start with more number of layers and check the performace . start reducing the layers and stop till you get the satisfacory performance.\n", 
      "\n", 
      "2) start with less number of layers and check the performance . keep adding layers till you get satisfactory performance."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE\n", 
      "\n", 
      "* We can start with a simple network and keep adding layer untill the expected performance is achieved\n", 
      "* We can start with a complex network and keep removing layers while performance is within expected level."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Trial and error: \n", 
      "\n", 
      "1. Design the network with more number of layers and reduce them gradually. compare the output for all configurations\n", 
      "\n", 
      "2. Design the network with more least of layers and increase them gradually. compare the output for all configurations\n", 
      "\n", 
      "the First method is the prefered method"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The correct number of layers can be found by trial and error. For boolean function we know that no hidden layer is needed, for any continuos function we know that one hidden layer is sufficient, but for any other unknown problem we try to increase the amount of layers and check how the error behaves."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "* Number of layers/neurons is completely depend on specific tasks.\n", 
      "* This problem is solved by **trial and error** method.\n", 
      "* There are two ways to do this,\n", 
      "* Start with a larger network and try to remove some layers/neurons until there is a degradation in performance.\n", 
      "* Start with a smaller network, and try to add layers/neurons until the performance criteria satisfies.\n"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The number of layers are determined by trail and error approach.\n", 
      "1. We can start with more number of layers and reduce the layers until the performace is good.\n", 
      "2. We can start with less number of layers and increase the layers until the performace starts to go bad."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "There are 2 ways of determining correct number of layers in feed forward networks:\n", 
      "* Add large number of layers. Then train the network until the performance is satisfactory. Then start removing 1-layer at a time until it keeps producing reasonable output.\n", 
      "* Start with few layers and keep adding more layers until network achieves satisfactory performance."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The number of layers and of neurons depends on the specific task. In practice the issue is solved by trial and error. However there exist two types of adaptive algorithms that can be used to approach the problem:\n", 
      "\n", 
      "* Start from a large network and successively remove some neurons and links until the network performance degrades.\n", 
      "* Begin with a small network and introduce new neurons until performance is satisfactory."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The number of layers depends on the given task. One way is to start with a large network, and reduce the layers until the performance of the network decreases. Another way is to start with a small network, and increase the layers until the performance of the network cannot be improved."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "There are two ways:\n", 
      "1. Start with a small network and increase the number of neurons/layers until the error is sufficent for the problem\n", 
      "2. Start with a big network and reduce the number of neurons/layer until the error significatly changes\n", 
      "\n", 
      "Also there are model selections techniques like 10-CV, SRMVC, AIC, BIC that can be used to choose promising models"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "In order to determine the number of layers, different numbers of layers have to be implemented and tested. The one with the best performance is then chosen. "
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "This is more or less trail and error, but there are two ways:\n", 
      "\n", 
      "1.We can start with many hidden layers and start reducing them until the desired error rate is not below our threshold.\n", 
      "\n", 
      "2.We start with very small amount of layers and gradually increase them until desired error rate is reached."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "[---]\n", 
      "\n", 
      "\n", 
      "It depends upon the task for which we are designing the feed-forward NN. This is mostly done by trail-and-error\n", 
      "\n", 
      "We can also apply this:\n", 
      "\n", 
      "    i. We start from the large number of layers  and neurons, and each time we reduce the amount of layers untill we achieve good performance.\n", 
      "    ii. or We can start from very small of layers, and then every time we add one layer and see when we achieve good performance. "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "**Answer 13:**\n", 
      "\n", 
      "The correct number of layers can be indentified by using three-split of labeled data into training, validation and set. NNs with different layers are trained on the training set. Best generalizing NN on the validation set could be selected as the final model.\n", 
      "\n", 
      "Other ways include starting from a large number of layers, obtaining the generalization, reducing the number of layers till reaching a good number of layers. It is also possible to start from one layer and go up until the desired generalization is reached."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "If we want two know the korrekt number of layers we have to know how complex the problem is and how much power a NN has. We can use Structural Risk minimisation or cross validation to find out which model fits best."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "There are two ways to do this:\n", 
      "1) start with high number of layers and continously reduce number of layser still error is acceptable\n", 
      "2) start with less layers and increase layers until generalization is sufficient "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "There is no solid rule on number of layers in feedforward NNs.\n", 
      "\n", 
      "Generally a NN with large enough number of layers is chosen and trained.\n", 
      "Then number of layers are decreased until performance starts degrading. \n", 
      "\n", 
      "OR\n", 
      "\n", 
      "Start with a small NN and then keep on adding layers until satisfactory performance is achieved. "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The number of layers can be determined using two approaches, one approach would be to increase the number of neurons until the generalization performance is optimum , other approach would be to start with a large number of layers and reduce it until the performance degrades. Number of layers depend upon the application."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "[--]\n", 
      "\n", 
      "This is done by trial and error.\n", 
      "\n", 
      "Two methods are possible:\n", 
      "\n", 
      "A network with large numbe rof layers can be initialized and later reduced by checking errors.\n", 
      "or a smal network can be initialized and addition of nodes and connection can be done until satifactory performance is obtained."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The number of layers is usually dependent on the nature of the problem and is determined by trial and error. There are two possible ways:\n", 
      "1. Start with a large network (with more layers) and successively trim layers until performance degrades.\n", 
      "2. Start with a small network and add layers until the performance is satisfactory.  \n", 
      "The former is considered more popular."
     ], 
     "points": 2
    }
   ]
  }, 
  {
   "qid": 38, 
   "question": "How many training examples are needed for training an NN?", 
   "answers": [
    {
     "answer": [
      "YOUR ANSWER HERE:\n", 
      "- The number of training examples needed for training an NN should be atleast 5 to 10 times the number of weights.\n", 
      "- The lower bound for the number of training examples, m, can be calculated when the VC dimesion is given as h and the error propabability is 1- $\\sigma$\n", 
      "\n", 
      "$m \\leq \\sqrt\\frac{(4h\\log(2/\\sigma)) - 8 log(13 \\sigma)}{h}$"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "[--]this \n", 
      "\n", 
      "This depends on the numbe of features. it not fixed because it vary from application to application\n", 
      "\n", 
      "Normally it should be 5 -10 times the numeber of weights. \n", 
      "\n", 
      "it decide the NN performance."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Number of training examples for training a neural network follows a rule of thumb, it is usully 5-10 times the number of weights.\n", 
      "There is also another rule which can be useful:\n", 
      "it is equal to $\\frac{|W|}{1-\\alpha}$ where W is the number of weights and $\\alpha$ the expected accuracy of the learning process."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE\n", 
      "\n", 
      "\n", 
      "* The number of training example is 5 to 10 times of the numer of weights in the network\n", 
      "* The number can also be expressed as $\\frac{|W|}{1-a}$, a is the accuracy of the training data"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The number of training examples should be 5 to 10 times the number of weights in the network.\n", 
      "\n", 
      "$$ nunmber of samples = \\beta |\\omega^2|/ \\alpha^2$$"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "We can use VC dimension to know the number of training examples need for training an NN.\n", 
      "\n", 
      "Number of examples = $ \\frac{1}{\\epsilon} [4 \\log_{2}(\\frac{2}{\\delta}) + 8 VCdim(H) \\log_{2}(\\frac{13}{\\epsilon})]$"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "The number of training examples needed for the NN should be 5 times the number of weights \n", 
      "\n", 
      "or we can calculate using \n", 
      "\n", 
      "N > |W|/1-a \n", 
      "\n", 
      "Here the numerator denotes the number of weights and a denotes the accuracy of the test data set"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "We can use statistical learning theory to calculate the minimum number of training examples based on accuracy we want and VC dimension of the machine. Another way of determining approximate number of training examples required is using the $\\frac{W}{1-a}$ where W no. of adjustable weights and a is the amount of accuracy we want."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "It depends, on the application, but the rule of thumb is to use at least 5 to 10 times the amount of weigths in the network. You can also calculate it with the following formula:\n", 
      "\n", 
      "$N = \\frac{W}{1-\\alpha}$\n", 
      "\n", 
      "where N is the number of training samples, W the number of weigths, and $\\alpha$ the desired degree of accuracy of the model.\n"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "As a general rule of thumb, we require 5-10 times the number of samples to the number of weights we want to train in the network."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Two ways to determine that:\n", 
      "\n", 
      "1) Rule of Thumb: The number of training examples should be at least 5-10 times the number of weights of the network.\n", 
      "\n", 
      "2) Other Rule: N>|W|/(1-a); W=number of weights; a=expected accuracy on test set."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "A rule of thumb is that the traning examples should be at least five times the number of the synaptic weights in the network."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "According to the rule of thumb we need 5-10 times training examples than the amount of features that we have"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Generally dependent on the task, but, an estimate can be taken as $\\frac{|W|}{\\epsilon}$ where W is the weight vector and the $\\epsilon$ is the desired accuracy"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "[---]\n", 
      "\n", 
      "The number of training examples should be 5 to 10 times the number of weights in the network\n", 
      "\n", 
      "Rule of Thumb:\n", 
      "\n", 
      " $$ N > w / |1- a  $$\n", 
      " \n", 
      " where w is number of weights in the network, a is accuracy"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Rule of thumb: 5 to 10 times the number of nodes, BUT:\n", 
      "It obviously depends on the application and input data. E.g. if we want to classify images into 1000 different classes we will need much more sample data.\n", 
      "Also the share between train and test dataset varies."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "German:\n", 
      "Eine Faustregel lautet: \n", 
      "5 bis 10 mal mehr als Gewichte im Netz vorhanden sind "
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "As per the rule of thumb the number of training examples should be 5-10 times the number of neurons in the layer."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "[--]\n", 
      "\n", 
      "Number of training sampples,m is determined by the formula\n", 
      "\n", 
      "m should be greater than or equal to $\\frac{4\\ln(2/\\delta) + 8*VC(H)*\\ln(13/\\epsilon)}{\\epsilon}$ where \\delta and \\epsilon are the errors and VC (H) is the vc dimension. $\\ln$ is logarithmic to the base 2."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The number of training examples depend on the problem given. For a MLP the training samples should be 5-10 times as many weights in the network. Using a probability and desired error of the network it can also be calculated using this formula $m \\leq \\frac{4\\cdot log(2/probability) - log(13 / error)}{error}$."
     ], 
     "points": 1
    }
   ]
  }, 
  {
   "qid": 39, 
   "question": "Give some examples of families of RBF functions!", 
   "answers": [
    {
     "answer": [
      "YOUR ANSWER HERE: Families of RBF functions:\n", 
      "- Multiquadric functions\n", 
      "- Inverse multiquadric functions\n", 
      "- Gaussian functions"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "* Guassian \n", 
      "* Quadratic"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Mutliquadrics, Gaussiona function, Polynomial functions"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "1. Multi quadraics\n", 
      "2. Inverse multi quadraics\n", 
      "3. Gaussian function. "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "1. polynomial functions\n", 
      "2. Gaussian functions\n"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "- Gaussian functions\n", 
      "- Mutiquadratic\n", 
      "- Inverse multiquadratic"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "* Gaussian\n", 
      "* Multiquadratic\n", 
      "* Inverse Multiquadratic\n", 
      "* Polyharmonic Spline"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Gaussian, single layer perceptron"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "1. Gaussian function\n", 
      "2. Multi Quadrics\n", 
      "3. Inverse Multiquadrics"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "**Answer 14:**\n", 
      "\n", 
      "1. Multiquadrics.\n", 
      "2. Inverse multiquadrics.\n", 
      "3. Gaussian functions."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "gaussan function\n", 
      "multiquadrics\n", 
      "inverse multiquadrics\n", 
      "\n", 
      "(all covered by michellis theroem)"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "multi quadric functions  \n", 
      "inverse multi quadric functions  \n", 
      "Gaussian functions  "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "- Gaussian functions\n", 
      "- Quadric functions\n", 
      "- Multiquadric functions"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "1. Exponetial \n", 
      "\n", 
      "2. Gaussian \n", 
      "\n", 
      "3. Polynomial \n", 
      "\n"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "[--]\n", 
      "\n", 
      "1) multivariate functions \n", 
      "\n", 
      "4) inverse quadratic functions \n", 
      "\n", 
      "3) gaussian fzunctions"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "1. Non-localized: $\\sqrt{{||x - c_i||}^2 + l^2}, l > 0$  \n", 
      "2. Localized: $\\frac{1}{\\sqrt{{||x - c_i||}^2 + l^2}}$, $exp(- \\frac{{||x - c_i||}^2}{2 \\sigma^2})$ "
     ], 
     "points": 2
    }
   ]
  }, 
  {
   "qid": 40, 
   "question": "Enumerate and explain all variants of minimum complexity Echo State Network (mcESN)!", 
   "answers": [
    {
     "answer": [
      "1. Delay line Reservoir mcESN\n", 
      "2. Delay line Rservoir with a feedback mcESN: Here every neurons in the hidden layers are interconnected.  \n", 
      "3. Simple cycle Reservoir: Here the feed back will be of one full continuous cycle "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Delay line reservoir: The dynamic reservoir has a time-delay connection running from one neuron to the next without feedback.\n", 
      "\n", 
      "DLR with feedback: The same as the Delay line, only this time each neuron is connected over a feedback to the previous one.\n", 
      "\n", 
      "Single Cycle reservoir: The same as Delay line, only the last neuron is connected to the first one of the delay line via a feedback connection."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "**Answer 15:**\n", 
      "\n", 
      "1. Delay line reservoir (DLR): The neurons in the reservoir is arranged one by one and the output of every neuron is fed to the next neuron.\n", 
      "2. DLR with feedback connections (DLRB): Similar to DLR but in addition the last neuron feeds back to the neuron before it and so on.\n", 
      "3. Simple cyclic reservoir (SCR): Similar to DLR but the fast neuron feeds back to the first neuron."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "I am not sure about the names\n", 
      "\n", 
      "1) direct linked reservoir.\n", 
      "each neuron in the reservoir is connected to one other, so that a queue of neurons exist\n", 
      "2) single loop reservoir\n", 
      "same as direct linked reservoir but the last neuron in the queue is connected to the fist one (recurrent)\n", 
      "3) \n", 
      "the queue is connected in both directuions. So each neuron is connected to the previous and to the next neuron in both directions. "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "In all minimum complexity ESNs the reservoir consists of a line of neurons\n", 
      "\n", 
      "o -> o -> o -> o\n", 
      "\n", 
      "- Delay line network\n", 
      "\n", 
      "        Each neuron in the reservoir has a connection to itself.\n", 
      "    \n", 
      "    \n", 
      "- Delay line network with feedback\n", 
      "\n", 
      "        Each neuron in the reservoir has a connection to the previous neuron.\n", 
      "\n", 
      "\n", 
      "- Single cycle network\n", 
      "\n", 
      "        The last neuron is connected to the first neuron in line."
     ], 
     "points": 2
    }
   ]
  }, 
  {
   "qid": 41, 
   "question": "Give an easy example  for a non-linear single feedback neuron systems which shows very complex behavior", 
   "answers": [
    {
     "answer": [
      "The single cycle echo state network. It has only one feedback loop in its dynamical reservoir, from the last neuron back to the first of the neuron chain. This ESN can be used to model dynamical systems."
     ], 
     "points": 1
    }
   ]
  }, 
  {
   "qid": 42, 
   "question": "Why and how are recurrent NNs unfolded in back-propagation-through-time?", 
   "answers": [
    {
     "answer": [
      "In back-propagation-through-time the samples at each time step is considered by unfolding. For each time step the weihts are adjusted and after completion it is folded again. It is a effictive technique used in RNNs"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "They are unfolded because it will be easy to handle the back propagation when they are considered as single FNN network.\n", 
      "\n", 
      "1. The recurrent neural networks are unfolded and stacked \n", 
      "2. Each of them are considered to be a normal FNN\n", 
      "3. The back propagation is executed on each network"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "1. because the learned model can have same input size regardless of sequence length\n", 
      "2. it is possible to use same transition function with same parameters at every time step"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "It is unfolded because if we want to make use of the recurrent connection we also have to train the impact of the signal before it passed the recurrence. When unfolding the RNN is copied for each timestep for at each reccurence."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Recurrent parts of an RNN can be represented by unfolding the recurrent part into several repetitions of the NN structure through time. This will help to understand better, how the recurrency works in neural networks and gain better insights of the learning process."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Since RNN show recurrent connections, simple backrpopagaton doesnt work. Thus, we unroll the RNN as if the RNN was a big FFNN, depending on how many time-steps we want to unroll. Then, we can train the FFNN with basic backpropagation."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "For tarining the recurrent NN, we need to consider the state of the NN at previous dectrete time instances. To achieve training through BP, we need to propogate the error to previous states as well. Hence the recurrent NN is unfolded through time, to achieve a structure like FF NN. To do this RNN is represented as FFNN at each iteration and feedback connection is considersed as individual input to a neuron from previous time step or iteration.  "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "In this situation we treat the time delay loop as an extra input and work with it like a normal input."
     ], 
     "points": 0
    }
   ]
  }, 
  {
   "qid": 43, 
   "question": "What is a bifurcation and how does this relate to NNs?", 
   "answers": [
    {
     "answer": [
      "Bifurication is state where the error signals doesn't change smoothly. They also don't converge.\n", 
      "\n", 
      "This is the problem with the Echo state network a type of recurrent neural network"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "Bifurcation refers to changing the parameters in dynamic system such that new fixed (accumlations) points are created or existing fixed points are destroyed. Parameters responsible for this are called bifurcation parameters. Its an important concept behind echo state networks. Simple difference equations shows bifuraction. So weights can act as bifurcation parameters and in such case network will find it very difficult to learn."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Bifurcation means that a minimal change in the parameters can lead to a drastic outcome. This is a problem in finding parameters for RNN. It is hard to tell the impact on changes."
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE Bifurcation denotes the term that a function converges to several values. You can observe bifurcation within Multilayer Backpropagation Networks."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Bifurcation appears when try to learn the parameters of a dynamical reservoir in a recurrent NN. It showes, that the complexity for learning is to high. To avoid this, ESN has the approach to let the dynamical reservoir as it is and adjust only the weights from dynamical reservoir to the output neurons"
     ], 
     "points": 0
    }
   ]
  }, 
  {
   "qid": 44, 
   "question": "Describe two cases, why spheres in higher dimensions behave counter intuitive.", 
   "answers": [
    {
     "answer": [
      "1. Most of the mass of the high dimensional sphere is concentrated only within the top (analogous to the crust), and is not distributed evenly.\n", 
      "2. "
     ], 
     "points": 1
    }
   ]
  }, 
  {
   "qid": 45, 
   "question": "What general underlying problem is solved when fitting models to data?", 
   "answers": [
    {
     "answer": [
      "It is always about finding a unkown function which resembles the patterns in the data. "
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE The general problem of regression is solved when fitting models to data"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Regression"
     ], 
     "points": 0
    }
   ]
  }, 
  {
   "qid": 46, 
   "question": "What are Gabor functions in the context of CNNs?", 
   "answers": [
    {
     "answer": [
      "Gabor function are kernels which are used for convolution. The are low-level functions which determine a value and a direction in data. The human eye also does something similar to Gabor functions."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Gabor functions are a special type of filter. It is able to find texture in certain direction. In CNN gabor functions can find edges of objects for example. Usually multiple gabor filters with diffrent directions are used\n"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Gabor functions are used as kernels in CNNs. Gabor functions help to detect edges in images."
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "Gabor functions in general are directed edge filters. In CNNs different Kernels are learned in the convolutional layers of a network. These learned kernels are very similar to the gabor filters."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Gabor functions are filters learned in the filters of neurons in the neurons of a CNN. As in computer vision techniques, gabor texture filters capture features of an image, and may be visualized in the layer of a CNN."
     ], 
     "points": 1
    }
   ]
  }, 
  {
   "qid": 47, 
   "question": "Explain the term \"k-fold cross validation\"", 
   "answers": [
    {
     "answer": [
      "[--]this\n", 
      "\n", 
      "K fold cross validation\n", 
      "\n", 
      "its basically helps computing performance .\n", 
      "\n", 
      "you divide the data set into traning and test data. into k folds . \n", 
      "\n", 
      "then clacluate the error for each fold and find out average all errors. "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE\n", 
      "\n", 
      "In k-fold cross validation, for each experiment k-1 fold of the data is used training and the remaining data is used for testing.\n", 
      "\n", 
      "Large number of folds makes the process more computionally complex"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Step 1: The training set is divided into k folds. \n", 
      "\n", 
      "Step 2: Among them one fold is left for validation while the others are used to train the network\n", 
      "\n", 
      "Step 3: After training each of them are the K-fold dataset are shuffled\n", 
      "\n", 
      "Step 4: Step 2 and 3 are repeated until a least error is achieved "
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "k- fold cross validation means that we take k data points from the given set and don't use it for training but for testing of the net. We do this several times, each time take other k random points and use them only for testing and not for training."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "During cross validation some part of the training data is taken for validation and this is called as a fold. This is done k times and then the error is averaged."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Given a dataset. K-fold cross validiation have a sequence of training data. It will be of a k-1 folds. So that all the data included for training. At the end the average test error from the test data(which was basically splitted from the training data) gives the global test error"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "+ In k-fold cross validation, we separate the dataset in set of k sequentially separated datasets and we perform cross-validation of these data-sets.\n", 
      "+ This is done to prevent the NN from learning the data too well and gain better generalization capabilities."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "It divides data into k groups. Each group is used once as the test set while other as the training set. The training is carried out k times."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "It is a method for model selection. The idea to seperate the input data in k partitions and check the the training error for the model. This gives an upper bound for the testerror."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "In K-fold-cross validation the training set is split into K equal sized parts. While one of the parts is used for testing the others are used for training. This method is used to overcome the lack of training data. "
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "We repeat the train and validation procedure on splits of datasets, where we use randomly selected parts for training and validation. The extreme case is leave one out CV, where we validate on one single patter, and is used when data is very sparse."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "- The leraning is splitted into k- folds.\n", 
      "- In each fold, n-k part of the input dataset is used to train the network and the remaining to test it.\n", 
      "- This ensures that we always use the entire dataset for both testing and training at the end of k-folds."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "**Answer 16:**\n", 
      "\n", 
      "In k-fold cross validation, the training data is split into k different sets. In each experiment, the network is trained by all sets except one. All experiments leave out a different set. The errors in each experiement is averaged to get the final error."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The k-fold cross validation is then we split the given data in k -folds and use each fold one time to test the NN. The rest is used to train the NN and we compute the error each time, so we can use the whole set to train the NN to find out how good it is. For each fold the traing has to start from the beginning."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "The data is splitted into k-folds. The network is trained k-times each time a diffrent fold is left out and used for training. after k traings all folds have been used for traing ones."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "K-fold cross validation is a training method where the given dataset is split into training and testing subsets for k folds. For each fold a different training and testing dataset is used and the whole dataset is used to its fullest. In the end the average of the training is used as the real trained machine."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "\"k-fold cross validation\" means that we divide our whole data into \"k\" equal sets and train we run the network for k times and each time we keep one set as out test and train the network with the other sets"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "In k fold cross validation, the test data is separated into k groups and in each training, one is left out to be used as the validation set. The error is the combination of errors obtained in each run."
     ], 
     "points": 2
    }
   ]
  }, 
  {
   "qid": 48, 
   "question": "Give two robotical problems (at least) which may be solved using ESNs?", 
   "answers": [
    {
     "answer": [
      "Two robotic problems solved using ESN\n", 
      "1. Control of Motor\n", 
      "2. RBG image classification"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Modelling of robot model offline and controlling it online in terms of actuations in wheels and second offline modelling robot arm in terms of dynamic parameters, such as mass and intertia."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Robot motor control ; handwritten address recognition"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "- Robot motol control\n", 
      "- Speech recognition"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "- Control\n", 
      "- Action recognition\n", 
      "- Non-linear mapping"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "- Predict the bahaviour of a manipulator given some commands and past state.\n", 
      "- Task planning: based on current environment state what to do next?"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "1. Modelling inverse dynamics of robotic arm (input required acceleration, ouput torque needed to be appiled at joint) \n", 
      "\n", 
      "2. Dynamic obstacle position prediction providing only previous positions of obstacle (not velocities), it can calculate velocities as it remembers previous positions. "
     ], 
     "points": 2
    }
   ]
  }, 
  {
   "qid": 49, 
   "question": "Give samples for problems with can be solved using SOMs and explain how.", 
   "answers": [
    {
     "answer": [
      "YOUR ANSWER HERE\n", 
      "\n", 
      "Travelling sales person problem, grouping a set of given RGB colors into groups such problems can be solved with SOM because,\n", 
      "\n", 
      "* SOM gives topological structure of the neurons where adjacent neurons tends to have similar value. \n", 
      "* The network maps an input to a neuron closest to the input.\n", 
      "* The neuron is the centroid of the points in a cluster\n", 
      "\n", 
      "So in case of travelling sales person problem the network will give structure of the locations to travel and the adjacent locations will be presented by adjacent neurons.\n", 
      "\n", 
      "In case of grouping colors the network will group similar colors together and adjacent neurons will have similar values."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Traveling salesman problem of fingin optimal path along all consireded cities in the problem. Perform this without desired signal."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "The traveling salesman problem can be solved using a self organized map. Points on a circle in the center of all cities are the starting weights, then the cities are given as an input to the network so the circle will spread to the cities. This will give a good but not necessarily optimal soultion to the problem.\n", 
      "\n", 
      "A line can be fit to a space using a SOM to generate an optimal grid. This can be used to find a short way which covers a field with a certain minimum distance."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "* Travelling sales man problem can be solved using SOMs.\n", 
      "* Randomly initialize weights for neurons.\n", 
      "* Select inputs which are the actual locations of cities in the weight space.\n", 
      "* Take inputs iteratively and find the winning neuron (closest neuron to the current input)\n", 
      "* Find the neighbors of winning neuron.\n", 
      "* Update the weights of winning neuron and it neighbors.\n", 
      "* Repeat the process until thers is no noticable changes in the map space.\n", 
      "* Stop the learning and sort the neurons in a topological order to get the list of cities need to be visited in order."
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "Travelling sales man problem can be solved using SOMs. Say the number of cities is n, initially we place n or more than n neurons randomly. Then we sample the data and adjust the winner neuron. This repeats until atleast one neuron is paired with one city. Once we connect all the neurons we get the path for TSP.  "
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "SOM can be used for solving Travelling SalesMen Problem. As its based on competitive learning if we adjust the initial weights in circular fashion then SOM will try to assign one city to each output neuron. Since transvering cities in circular fashion can lead to shortest distasnce, SOM can give us optimal or very close to optimal solution. "
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "The traveling salesman problem\n", 
      "- The problem must be one dimensional.\n", 
      "- Each neuron of the network corresponds to one city.\n", 
      "- If the weight of a neuron is similar or equal to the coordinated of a city, then that neuron is selected to represent the city."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "+ Travelling Salesman Problem as we did in the exercises.\n", 
      "+ K-means clustering problems.\n", 
      "+ Facial recognition can be learnt by learning the correspondance maps for faces (Philipp Wolfram, C. von der Malsburg, et. al. FIAS, 2008, I think)."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The TSP can be solved appoximatly using som. For each Node introduce a neuron. The neurons are connected 1d. The neurons are initialised in the mean of the points. If we now run tsp and go along the connections between the neurons in the lattice we get an approximate tour"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "SOMs will be able to solve mostly pattern recognition patterns by calculating the most similar neurons with these patterns. Multiple patterns can be trained, and the result will be that the different regions of the SOM will be able to identify the multiple patterns."
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "Travelling salesman problem can be solved using self organising maps, firstly we need to have more neurons than cities that are to be visited. Then these neurons must be connected to form a circle. After SOM algorithm finishes neurons will represent the path for a salesman to visit.\n", 
      "Given unlabled dataset and passing it through a SOMs algorithm, it will be able to create classes for data and classify it accordingly."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE One sample problem solved using SOM is traveling salesman agent problem."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "**Answer 17:**\n", 
      "\n", 
      "SOMs can be used to solve the travelling salesman problem. The neurons in the lattice can be arranged in the form of a circle in the space consisting the cities. During learning, neurons move towards the cities in the ordering phase and fine tune the map in the convergence phase. The final map provides a path close to the shortest path.\n", 
      "\n", 
      "SOMs can also be used to cluster words in a document for document analysis. The words would be clustered according to similarity."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "- Traveling salesman problem: number of nodes atleast number of cities to visit, the nodes neighborhood relation is a cirlce-> each node has two neighbours. Apply SOM. A good but typically not optimal solution is represented by the order of the nodes after SOM.\n", 
      "- Fit a one dimensional line to a multidimensional space."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "One example problem that can be solved with SOMs is the traveling salesman problem.\n", 
      "By initializing the SOM with at least as many neurons as cities in an indexed circle and then training it, all of the neurons should cover a city. Now the indices can be used to get a route for the TSP.\n", 
      "\n", 
      "Also similarities between objects/animals can be extracted, by using a semantic SOM to order the animals."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Travelling saleman problem. \n", 
      "Initialize 2D SOM in circular mesh. \n", 
      "Feed 2D locations of city. \n", 
      "After training, order of vising is the order in which neurons are adjusted. \n", 
      "\n", 
      "\n", 
      "Clustering.\n", 
      "\n", 
      "Initialize SOM vectors with same dimensions as data.\n", 
      "feed input data. After trainig clusters in data are same as the clusters of neurons. \n", 
      "\n"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "[--]\n", 
      "Traveling salesmen pronblem by considering every neuron corrwsponding to a city. Using 1 dimensional  arrangement of lattice. Computing the distance and optimising the arrangement\n", 
      "\n", 
      "2) They can also be used for identifying patterns in the unput"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The traveling salesman problem can be solved using SOMs. For this, neurons which are connected in a circular way are created. There should be as many neurons as cities in the problem. The cities are fed into the network and the neuron with the weight closest to the city is selected as winner. Then the weights are updated and the neuron moves closer to the city. Here it is only necessery to update the winning neuron, but using a neighbourhood function which also changes neighbours does also work. In the end the neurons form a circle trough all the cities."
     ], 
     "points": 1
    }
   ]
  }, 
  {
   "qid": 50, 
   "question": "Explain the central idea behind the Gauss-Newton method and where can it be applied in NN learning?", 
   "answers": [
    {
     "answer": [
      "[--] this\n", 
      "\n", 
      "Gauss Newton Methods is also aproaximation function  which uses the Hessian funtion .\n", 
      "\n", 
      "It helps to convergere the algorithm faster in NN . and but for calculating Hessain it needs Strictly positive matrix . "
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "Gauss- newton Method can only be applied in case of quantized error function.\n", 
      "$$E = o.5\\sum_k e_i^2$$"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE\n", 
      "\n", 
      "* It requires a error function represented as sum of squared error\n", 
      "* It is a batch learning approach"
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "Gauss-Newton is least square method, used for minimizing squared value of instantaneous error. Here instantaneus value is a error value for each  neuron. Usage of this method results in Widrow-Hoff delta learning rule.  "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The idea is to use the sum of squared errors as the cost function to minimize. "
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "+ Gauss Newton methed learning rule: $w(n+1) = w(n) - (J^TJ)^{-1} J e(n)$, where $J$ is the Jacobian of the error vector.\n", 
      "+ We need to make sure that the Jacobian is non-negative definite.\n", 
      "+ Approximation version of least mean squares."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "The Gauss-Newton method is an optimization of the Newton method, where it can also be applied into cost functions that are represented with squared errors. The optimization is that no Hessian matrix has to be calculated, so no second derivatives, making the method computationally smaller. This method will be applied in the adjustment step, when calculating the learning direction for the minimization of the error."
     ], 
     "points": 0
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "It is a speicial case of newtons method where the loss function can be expressed as a mean squared error.\n", 
      "\n", 
      "It can be used in NN learning similar to newton's method, but with the added advantage that we only need to know the Jacobian of the error function. And the term is always a positive definite."
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "The problem with newtond method is that the Hessian matrix needs to be positive definit matrix. So they came up with Gauss newton method which is a steepest descent method for minimizing the squared error function. We need to find the jacobian of error function and the multiplication of jacobian and jacobian transpose should be non-negative , non singular."
     ], 
     "points": 2
    }
   ]
  }, 
  {
   "qid": 51, 
   "question": "Define max-pooling and the term ReLU in context of CNNs.", 
   "answers": [
    {
     "answer": [
      "Max pooling in CNN is further adjustment of the convoluted network to make it tarnslation invariant. That is, for small translation in input the output remains unaffected. \n", 
      "\n", 
      "Rectified Linear Unit is a type of activation function used in CNN. It can be written as\n", 
      "$$\\phi(x)= max(0,x)$$\n", 
      "It is a type of picewise activation function and removes the danger of vanishing gradient problem which is a charecteristic of sigmoid function"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "YOUR ANSWER HERE\n", 
      "\n", 
      "Max polling: Max polling a filter which gives the maximum value within the filter frame. In CNN it helps in extracting the high level filters and making the learning transformation invarience.\n", 
      "\n", 
      "Relu: ReLU is rectified linear unit. In CNN it helps in solving the vaninshing gradient problem.\n", 
      "\n", 
      "In case of ReLU $f(x)= max(0, x)$ "
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "This function is defined as ReLu:= max(0, v), where v is local field of  neuron"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "* Max pooing selects the maximum value in the specified sliding window and forms a new layer of values.\n", 
      "* Rectified linear unit selects the maximum value between 0 and induced field (v)."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Max Pooling: In Max pooling for reducing the dimension fo feature matrix, we select the value of the highest cell to be carried into the new low dimension matrix. \n", 
      "ReLU: Rectifiec linear unit is used to remove the negative terms so that we have some non-linearity."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Max-pooling is used for extracting only certain information from the feature maps of the CNN. It is one of the factor behind translation invariance observed in CNN. ReLU is an activation function used to introduce non-linearity in the system. It is computationally efficient compared to other activation functions such as sigmoidal function. Its given by max(v,0)."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Max-pooling is a process of coarse-graining the matrix/image by taking the maximum value of an element among a selected sub-matrix/image area (e.g. 2x2 pixel area).\n", 
      "A = $\\begin{pmatrix} 2,3\\\\\n", 
      "4,5 \\end{pmatrix} \\Rightarrow maxpool(A)= 5$. \n", 
      "\n", 
      "Rectified linear Unit (ReLU) is a linear rectifier that responds linearly to the input."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "max pooling is one technique to realise the pooling layer. \n", 
      "relu is an activation function often used for cnn"
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Pooling is a method used in CNNs where, for a given convolutional step, a single value will be extracted from the result of a convolution. In the max pooling, the maximal value of the convolution's result will be used. ReLu is a type of activation function used in CNNs. ReLu is a better activation function than the sigmoid, since the ReLu works for value between 0 and 1 (negative values not used in images), and also when using sigmoid functions the resulting values will be very large making it computationally difficult."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Max pooling refers to a type of layer where our input volume (e.g. RGB images) are spatially reduced in size, reducing both computational need and condensing information through picking the maximum value in a given window. Historically, other pooling methods such as mean pooling have been used, but where later replaced by max pooling or even all convolutional layers with an increased stride to reduce the volumes spatially. As with FFNN, we introduce nonlinearity through our activation function ReLU, being a partwise linear function its less computatinally expensiye in both activation and derivation, and less so has the problem of vanishing gradients in deep CNN."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "[---]\n", 
      "\n", 
      "In max-pooling, we take maximum of all values inside the kernal. For example, If kernal size is 2 by 2, we overlay this kernal over the image, we just take maximum value among all 4 values(as 2 by 2 will be over 4 values)\n", 
      "\n", 
      "Max-pooling is used for dimensionality reduction as well translation invariance\n", 
      "\n", 
      "\n", 
      "ReLu is activation function is that is used in CNNs. \n", 
      "\n", 
      "It is defined as: max(0,x) where x is input. Whenever, any input has negative value, it results will be 0 else it will return same value. \n", 
      "\n", 
      "The reason we are using this because it does not have vanishing gradient problem. Furthermore, computations become easier and faster.   \n", 
      "\n", 
      "\n"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "- Max pooling refers to a pooling layer with a sliding window where the maximum value in the window is used to represent the windows value.\n", 
      "- ReLU is an activation function used: $\\varphi(v) = max(0, v)$. It used because its compulational less complex than sigmoid or tanh but still makes the network behave nonlinear."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "max pooling is subsampling by finding the maximum in each square. The relu (rectivied linear unit) function is the activation function they use in CNN given by $phi(x)= max{0,x}$, which is differantial (threshold function)."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "Max-pooling is used to do subsampling in CNNs it takes the maximum of a predefined  number of elements. "
     ], 
     "points": 1
    }, 
    {
     "answer": [
      "Max pooling is used in the process of subsampling. Out of windows the maximum value is used in the downscaled variant.\n", 
      "\n", 
      "ReLU is an activation function used in CNNs to counteract the vanishing gradient problem. Its derivative does not scale down with lowering values and resembles the step function."
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "[--]\n", 
      "Max poling is done using a kernal of finite size passed over the data and computing maximum of data elememts coered by kernel. This is also called downsampling\n", 
      "\n", 
      "ReLU are the rectilinear activation function used as activation functions in NN. The overcome the vanishing gradient problem and are computationaally less expensive"
     ], 
     "points": 2
    }, 
    {
     "answer": [
      "In convolution networks we have a convolution(such as a median or gaussian filter) that we move it over a fixed size window and the result of this oparation will be a window with the same size but new values. In the max-pooling method we choose the maximum value from all the values in this window."
     ], 
     "points": 1
    }
   ]
  }
 ]
}